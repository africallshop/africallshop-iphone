/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g
 *     -                            On : 2013-10-13 10:59:31
 *     -                for the parser : belle_sip_messageParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/*
    belle-sip - SIP (RFC3261) library.
    Copyright (C) 2010  Belledonne Communications SARL

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "belle_sip_messageParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pbelle_sip_messageParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pbelle_sip_messageParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pbelle_sip_messageParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pbelle_sip_messageParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_message scope set 
 */
static pbelle_sip_messageParser_message_SCOPE   pbelle_sip_messageParser_messagePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL messageFree(pbelle_sip_messageParser_message_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL messageFree(pbelle_sip_messageParser_message_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser message scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_messageTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_message_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_message_SCOPE
pbelle_sip_messageParser_messagePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_message_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_messageStack->size(ctx->pbelle_sip_messageParser_messageStack) > ctx->pbelle_sip_messageParser_messageStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_message_SCOPE)ctx->pbelle_sip_messageParser_messageStack->get(ctx->pbelle_sip_messageParser_messageStack, ctx->pbelle_sip_messageParser_messageStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_message_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_message_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_messageStack->push(ctx->pbelle_sip_messageParser_messageStack, newAttributes, (void (*)(void *))messageFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_messageStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_message_raw scope set 
 */
static pbelle_sip_messageParser_message_raw_SCOPE   pbelle_sip_messageParser_message_rawPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL message_rawFree(pbelle_sip_messageParser_message_raw_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL message_rawFree(pbelle_sip_messageParser_message_raw_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser message_raw scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_message_rawTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_message_raw_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_message_raw_SCOPE
pbelle_sip_messageParser_message_rawPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_message_raw_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_message_rawStack->size(ctx->pbelle_sip_messageParser_message_rawStack) > ctx->pbelle_sip_messageParser_message_rawStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_message_raw_SCOPE)ctx->pbelle_sip_messageParser_message_rawStack->get(ctx->pbelle_sip_messageParser_message_rawStack, ctx->pbelle_sip_messageParser_message_rawStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_message_raw_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_message_raw_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_message_rawStack->push(ctx->pbelle_sip_messageParser_message_rawStack, newAttributes, (void (*)(void *))message_rawFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_message_rawStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_request scope set 
 */
static pbelle_sip_messageParser_request_SCOPE   pbelle_sip_messageParser_requestPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL requestFree(pbelle_sip_messageParser_request_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL requestFree(pbelle_sip_messageParser_request_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser request scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_requestTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_request_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_request_SCOPE
pbelle_sip_messageParser_requestPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_request_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_requestStack->size(ctx->pbelle_sip_messageParser_requestStack) > ctx->pbelle_sip_messageParser_requestStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_request_SCOPE)ctx->pbelle_sip_messageParser_requestStack->get(ctx->pbelle_sip_messageParser_requestStack, ctx->pbelle_sip_messageParser_requestStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_request_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_request_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_requestStack->push(ctx->pbelle_sip_messageParser_requestStack, newAttributes, (void (*)(void *))requestFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_requestStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_response scope set 
 */
static pbelle_sip_messageParser_response_SCOPE   pbelle_sip_messageParser_responsePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL responseFree(pbelle_sip_messageParser_response_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL responseFree(pbelle_sip_messageParser_response_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser response scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_responseTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_response_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_response_SCOPE
pbelle_sip_messageParser_responsePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_response_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_responseStack->size(ctx->pbelle_sip_messageParser_responseStack) > ctx->pbelle_sip_messageParser_responseStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_response_SCOPE)ctx->pbelle_sip_messageParser_responseStack->get(ctx->pbelle_sip_messageParser_responseStack, ctx->pbelle_sip_messageParser_responseStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_response_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_response_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_responseStack->push(ctx->pbelle_sip_messageParser_responseStack, newAttributes, (void (*)(void *))responseFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_responseStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_generic_param scope set 
 */
static pbelle_sip_messageParser_generic_param_SCOPE   pbelle_sip_messageParser_generic_paramPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL generic_paramFree(pbelle_sip_messageParser_generic_param_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL generic_paramFree(pbelle_sip_messageParser_generic_param_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser generic_param scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_generic_paramTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_generic_param_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_generic_param_SCOPE
pbelle_sip_messageParser_generic_paramPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_generic_param_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_generic_paramStack->size(ctx->pbelle_sip_messageParser_generic_paramStack) > ctx->pbelle_sip_messageParser_generic_paramStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_generic_param_SCOPE)ctx->pbelle_sip_messageParser_generic_paramStack->get(ctx->pbelle_sip_messageParser_generic_paramStack, ctx->pbelle_sip_messageParser_generic_paramStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_generic_param_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_generic_param_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_generic_paramStack->push(ctx->pbelle_sip_messageParser_generic_paramStack, newAttributes, (void (*)(void *))generic_paramFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_generic_paramStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_allow scope set 
 */
static pbelle_sip_messageParser_header_allow_SCOPE   pbelle_sip_messageParser_header_allowPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_allowFree(pbelle_sip_messageParser_header_allow_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_allowFree(pbelle_sip_messageParser_header_allow_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_allow scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_allowTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_allow_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_allow_SCOPE
pbelle_sip_messageParser_header_allowPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_allow_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_allowStack->size(ctx->pbelle_sip_messageParser_header_allowStack) > ctx->pbelle_sip_messageParser_header_allowStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_allow_SCOPE)ctx->pbelle_sip_messageParser_header_allowStack->get(ctx->pbelle_sip_messageParser_header_allowStack, ctx->pbelle_sip_messageParser_header_allowStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_allow_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_allow_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_allowStack->push(ctx->pbelle_sip_messageParser_header_allowStack, newAttributes, (void (*)(void *))header_allowFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_allowStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_authorization scope set 
 */
static pbelle_sip_messageParser_header_authorization_SCOPE   pbelle_sip_messageParser_header_authorizationPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_authorizationFree(pbelle_sip_messageParser_header_authorization_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_authorizationFree(pbelle_sip_messageParser_header_authorization_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_authorization scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_authorizationTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_authorization_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_authorization_SCOPE
pbelle_sip_messageParser_header_authorizationPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_authorization_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_authorizationStack->size(ctx->pbelle_sip_messageParser_header_authorizationStack) > ctx->pbelle_sip_messageParser_header_authorizationStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_authorization_SCOPE)ctx->pbelle_sip_messageParser_header_authorizationStack->get(ctx->pbelle_sip_messageParser_header_authorizationStack, ctx->pbelle_sip_messageParser_header_authorizationStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_authorization_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_authorization_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_authorizationStack->push(ctx->pbelle_sip_messageParser_header_authorizationStack, newAttributes, (void (*)(void *))header_authorizationFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_authorizationStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_call_id scope set 
 */
static pbelle_sip_messageParser_header_call_id_SCOPE   pbelle_sip_messageParser_header_call_idPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_call_idFree(pbelle_sip_messageParser_header_call_id_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_call_idFree(pbelle_sip_messageParser_header_call_id_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_call_id scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_call_idTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_call_id_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_call_id_SCOPE
pbelle_sip_messageParser_header_call_idPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_call_id_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_call_idStack->size(ctx->pbelle_sip_messageParser_header_call_idStack) > ctx->pbelle_sip_messageParser_header_call_idStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_call_id_SCOPE)ctx->pbelle_sip_messageParser_header_call_idStack->get(ctx->pbelle_sip_messageParser_header_call_idStack, ctx->pbelle_sip_messageParser_header_call_idStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_call_id_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_call_id_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_call_idStack->push(ctx->pbelle_sip_messageParser_header_call_idStack, newAttributes, (void (*)(void *))header_call_idFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_call_idStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_contact scope set 
 */
static pbelle_sip_messageParser_header_contact_SCOPE   pbelle_sip_messageParser_header_contactPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_contactFree(pbelle_sip_messageParser_header_contact_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_contactFree(pbelle_sip_messageParser_header_contact_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_contact scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_contactTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_contact_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_contact_SCOPE
pbelle_sip_messageParser_header_contactPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_contact_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_contactStack->size(ctx->pbelle_sip_messageParser_header_contactStack) > ctx->pbelle_sip_messageParser_header_contactStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_contact_SCOPE)ctx->pbelle_sip_messageParser_header_contactStack->get(ctx->pbelle_sip_messageParser_header_contactStack, ctx->pbelle_sip_messageParser_header_contactStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_contact_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_contact_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_contactStack->push(ctx->pbelle_sip_messageParser_header_contactStack, newAttributes, (void (*)(void *))header_contactFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_contactStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_contact_param scope set 
 */
static pbelle_sip_messageParser_contact_param_SCOPE   pbelle_sip_messageParser_contact_paramPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL contact_paramFree(pbelle_sip_messageParser_contact_param_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL contact_paramFree(pbelle_sip_messageParser_contact_param_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser contact_param scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_contact_paramTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_contact_param_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_contact_param_SCOPE
pbelle_sip_messageParser_contact_paramPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_contact_param_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_contact_paramStack->size(ctx->pbelle_sip_messageParser_contact_paramStack) > ctx->pbelle_sip_messageParser_contact_paramStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_contact_param_SCOPE)ctx->pbelle_sip_messageParser_contact_paramStack->get(ctx->pbelle_sip_messageParser_contact_paramStack, ctx->pbelle_sip_messageParser_contact_paramStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_contact_param_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_contact_param_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_contact_paramStack->push(ctx->pbelle_sip_messageParser_contact_paramStack, newAttributes, (void (*)(void *))contact_paramFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_contact_paramStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_content_length scope set 
 */
static pbelle_sip_messageParser_header_content_length_SCOPE   pbelle_sip_messageParser_header_content_lengthPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_content_lengthFree(pbelle_sip_messageParser_header_content_length_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_content_lengthFree(pbelle_sip_messageParser_header_content_length_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_content_length scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_content_lengthTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_content_length_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_content_length_SCOPE
pbelle_sip_messageParser_header_content_lengthPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_content_length_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_content_lengthStack->size(ctx->pbelle_sip_messageParser_header_content_lengthStack) > ctx->pbelle_sip_messageParser_header_content_lengthStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_content_length_SCOPE)ctx->pbelle_sip_messageParser_header_content_lengthStack->get(ctx->pbelle_sip_messageParser_header_content_lengthStack, ctx->pbelle_sip_messageParser_header_content_lengthStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_content_length_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_content_length_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_content_lengthStack->push(ctx->pbelle_sip_messageParser_header_content_lengthStack, newAttributes, (void (*)(void *))header_content_lengthFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_content_lengthStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_content_type scope set 
 */
static pbelle_sip_messageParser_header_content_type_SCOPE   pbelle_sip_messageParser_header_content_typePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_content_typeFree(pbelle_sip_messageParser_header_content_type_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_content_typeFree(pbelle_sip_messageParser_header_content_type_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_content_type scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_content_typeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_content_type_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_content_type_SCOPE
pbelle_sip_messageParser_header_content_typePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_content_type_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_content_typeStack->size(ctx->pbelle_sip_messageParser_header_content_typeStack) > ctx->pbelle_sip_messageParser_header_content_typeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_content_type_SCOPE)ctx->pbelle_sip_messageParser_header_content_typeStack->get(ctx->pbelle_sip_messageParser_header_content_typeStack, ctx->pbelle_sip_messageParser_header_content_typeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_content_type_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_content_type_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_content_typeStack->push(ctx->pbelle_sip_messageParser_header_content_typeStack, newAttributes, (void (*)(void *))header_content_typeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_content_typeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_cseq scope set 
 */
static pbelle_sip_messageParser_header_cseq_SCOPE   pbelle_sip_messageParser_header_cseqPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_cseqFree(pbelle_sip_messageParser_header_cseq_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_cseqFree(pbelle_sip_messageParser_header_cseq_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_cseq scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_cseqTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_cseq_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_cseq_SCOPE
pbelle_sip_messageParser_header_cseqPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_cseq_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_cseqStack->size(ctx->pbelle_sip_messageParser_header_cseqStack) > ctx->pbelle_sip_messageParser_header_cseqStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_cseq_SCOPE)ctx->pbelle_sip_messageParser_header_cseqStack->get(ctx->pbelle_sip_messageParser_header_cseqStack, ctx->pbelle_sip_messageParser_header_cseqStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_cseq_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_cseq_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_cseqStack->push(ctx->pbelle_sip_messageParser_header_cseqStack, newAttributes, (void (*)(void *))header_cseqFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_cseqStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_date scope set 
 */
static pbelle_sip_messageParser_header_date_SCOPE   pbelle_sip_messageParser_header_datePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_dateFree(pbelle_sip_messageParser_header_date_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_dateFree(pbelle_sip_messageParser_header_date_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_date scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_dateTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_date_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_date_SCOPE
pbelle_sip_messageParser_header_datePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_date_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_dateStack->size(ctx->pbelle_sip_messageParser_header_dateStack) > ctx->pbelle_sip_messageParser_header_dateStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_date_SCOPE)ctx->pbelle_sip_messageParser_header_dateStack->get(ctx->pbelle_sip_messageParser_header_dateStack, ctx->pbelle_sip_messageParser_header_dateStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_date_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_date_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_dateStack->push(ctx->pbelle_sip_messageParser_header_dateStack, newAttributes, (void (*)(void *))header_dateFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_dateStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_expires scope set 
 */
static pbelle_sip_messageParser_header_expires_SCOPE   pbelle_sip_messageParser_header_expiresPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_expiresFree(pbelle_sip_messageParser_header_expires_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_expiresFree(pbelle_sip_messageParser_header_expires_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_expires scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_expiresTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_expires_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_expires_SCOPE
pbelle_sip_messageParser_header_expiresPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_expires_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_expiresStack->size(ctx->pbelle_sip_messageParser_header_expiresStack) > ctx->pbelle_sip_messageParser_header_expiresStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_expires_SCOPE)ctx->pbelle_sip_messageParser_header_expiresStack->get(ctx->pbelle_sip_messageParser_header_expiresStack, ctx->pbelle_sip_messageParser_header_expiresStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_expires_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_expires_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_expiresStack->push(ctx->pbelle_sip_messageParser_header_expiresStack, newAttributes, (void (*)(void *))header_expiresFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_expiresStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_from scope set 
 */
static pbelle_sip_messageParser_header_from_SCOPE   pbelle_sip_messageParser_header_fromPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_fromFree(pbelle_sip_messageParser_header_from_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_fromFree(pbelle_sip_messageParser_header_from_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_from scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_fromTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_from_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_from_SCOPE
pbelle_sip_messageParser_header_fromPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_from_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_fromStack->size(ctx->pbelle_sip_messageParser_header_fromStack) > ctx->pbelle_sip_messageParser_header_fromStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_from_SCOPE)ctx->pbelle_sip_messageParser_header_fromStack->get(ctx->pbelle_sip_messageParser_header_fromStack, ctx->pbelle_sip_messageParser_header_fromStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_from_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_from_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_fromStack->push(ctx->pbelle_sip_messageParser_header_fromStack, newAttributes, (void (*)(void *))header_fromFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_fromStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_max_forwards scope set 
 */
static pbelle_sip_messageParser_header_max_forwards_SCOPE   pbelle_sip_messageParser_header_max_forwardsPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_max_forwardsFree(pbelle_sip_messageParser_header_max_forwards_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_max_forwardsFree(pbelle_sip_messageParser_header_max_forwards_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_max_forwards scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_max_forwardsTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_max_forwards_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_max_forwards_SCOPE
pbelle_sip_messageParser_header_max_forwardsPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_max_forwards_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_max_forwardsStack->size(ctx->pbelle_sip_messageParser_header_max_forwardsStack) > ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_max_forwards_SCOPE)ctx->pbelle_sip_messageParser_header_max_forwardsStack->get(ctx->pbelle_sip_messageParser_header_max_forwardsStack, ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_max_forwards_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_max_forwards_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_max_forwardsStack->push(ctx->pbelle_sip_messageParser_header_max_forwardsStack, newAttributes, (void (*)(void *))header_max_forwardsFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_proxy_authenticate scope set 
 */
static pbelle_sip_messageParser_header_proxy_authenticate_SCOPE   pbelle_sip_messageParser_header_proxy_authenticatePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_proxy_authenticateFree(pbelle_sip_messageParser_header_proxy_authenticate_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_proxy_authenticateFree(pbelle_sip_messageParser_header_proxy_authenticate_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_proxy_authenticate scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_proxy_authenticateTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_proxy_authenticate_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_proxy_authenticate_SCOPE
pbelle_sip_messageParser_header_proxy_authenticatePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_proxy_authenticate_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->size(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack) > ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_proxy_authenticate_SCOPE)ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->get(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack, ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_proxy_authenticate_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_proxy_authenticate_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->push(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack, newAttributes, (void (*)(void *))header_proxy_authenticateFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_qop_opts scope set 
 */
static pbelle_sip_messageParser_qop_opts_SCOPE   pbelle_sip_messageParser_qop_optsPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL qop_optsFree(pbelle_sip_messageParser_qop_opts_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL qop_optsFree(pbelle_sip_messageParser_qop_opts_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser qop_opts scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_qop_optsTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_qop_opts_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_qop_opts_SCOPE
pbelle_sip_messageParser_qop_optsPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_qop_opts_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_qop_optsStack->size(ctx->pbelle_sip_messageParser_qop_optsStack) > ctx->pbelle_sip_messageParser_qop_optsStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_qop_opts_SCOPE)ctx->pbelle_sip_messageParser_qop_optsStack->get(ctx->pbelle_sip_messageParser_qop_optsStack, ctx->pbelle_sip_messageParser_qop_optsStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_qop_opts_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_qop_opts_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_qop_optsStack->push(ctx->pbelle_sip_messageParser_qop_optsStack, newAttributes, (void (*)(void *))qop_optsFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_qop_optsStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_proxy_authorization scope set 
 */
static pbelle_sip_messageParser_header_proxy_authorization_SCOPE   pbelle_sip_messageParser_header_proxy_authorizationPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_proxy_authorizationFree(pbelle_sip_messageParser_header_proxy_authorization_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_proxy_authorizationFree(pbelle_sip_messageParser_header_proxy_authorization_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_proxy_authorization scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_proxy_authorizationTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_proxy_authorization_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_proxy_authorization_SCOPE
pbelle_sip_messageParser_header_proxy_authorizationPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_proxy_authorization_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->size(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack) > ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_proxy_authorization_SCOPE)ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->get(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack, ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_proxy_authorization_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_proxy_authorization_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->push(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack, newAttributes, (void (*)(void *))header_proxy_authorizationFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_service_route scope set 
 */
static pbelle_sip_messageParser_header_service_route_SCOPE   pbelle_sip_messageParser_header_service_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_service_routeFree(pbelle_sip_messageParser_header_service_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_service_routeFree(pbelle_sip_messageParser_header_service_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_service_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_service_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_service_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_service_route_SCOPE
pbelle_sip_messageParser_header_service_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_service_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_service_routeStack->size(ctx->pbelle_sip_messageParser_header_service_routeStack) > ctx->pbelle_sip_messageParser_header_service_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_service_route_SCOPE)ctx->pbelle_sip_messageParser_header_service_routeStack->get(ctx->pbelle_sip_messageParser_header_service_routeStack, ctx->pbelle_sip_messageParser_header_service_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_service_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_service_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_service_routeStack->push(ctx->pbelle_sip_messageParser_header_service_routeStack, newAttributes, (void (*)(void *))header_service_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_service_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_srv_route scope set 
 */
static pbelle_sip_messageParser_srv_route_SCOPE   pbelle_sip_messageParser_srv_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL srv_routeFree(pbelle_sip_messageParser_srv_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL srv_routeFree(pbelle_sip_messageParser_srv_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser srv_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_srv_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_srv_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_srv_route_SCOPE
pbelle_sip_messageParser_srv_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_srv_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_srv_routeStack->size(ctx->pbelle_sip_messageParser_srv_routeStack) > ctx->pbelle_sip_messageParser_srv_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_srv_route_SCOPE)ctx->pbelle_sip_messageParser_srv_routeStack->get(ctx->pbelle_sip_messageParser_srv_routeStack, ctx->pbelle_sip_messageParser_srv_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_srv_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_srv_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_srv_routeStack->push(ctx->pbelle_sip_messageParser_srv_routeStack, newAttributes, (void (*)(void *))srv_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_srv_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_record_route scope set 
 */
static pbelle_sip_messageParser_header_record_route_SCOPE   pbelle_sip_messageParser_header_record_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_record_routeFree(pbelle_sip_messageParser_header_record_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_record_routeFree(pbelle_sip_messageParser_header_record_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_record_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_record_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_record_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_record_route_SCOPE
pbelle_sip_messageParser_header_record_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_record_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_record_routeStack->size(ctx->pbelle_sip_messageParser_header_record_routeStack) > ctx->pbelle_sip_messageParser_header_record_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_record_route_SCOPE)ctx->pbelle_sip_messageParser_header_record_routeStack->get(ctx->pbelle_sip_messageParser_header_record_routeStack, ctx->pbelle_sip_messageParser_header_record_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_record_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_record_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_record_routeStack->push(ctx->pbelle_sip_messageParser_header_record_routeStack, newAttributes, (void (*)(void *))header_record_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_record_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_rec_route scope set 
 */
static pbelle_sip_messageParser_rec_route_SCOPE   pbelle_sip_messageParser_rec_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL rec_routeFree(pbelle_sip_messageParser_rec_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL rec_routeFree(pbelle_sip_messageParser_rec_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser rec_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_rec_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_rec_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_rec_route_SCOPE
pbelle_sip_messageParser_rec_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_rec_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_rec_routeStack->size(ctx->pbelle_sip_messageParser_rec_routeStack) > ctx->pbelle_sip_messageParser_rec_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_rec_route_SCOPE)ctx->pbelle_sip_messageParser_rec_routeStack->get(ctx->pbelle_sip_messageParser_rec_routeStack, ctx->pbelle_sip_messageParser_rec_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_rec_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_rec_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_rec_routeStack->push(ctx->pbelle_sip_messageParser_rec_routeStack, newAttributes, (void (*)(void *))rec_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_rec_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_route scope set 
 */
static pbelle_sip_messageParser_header_route_SCOPE   pbelle_sip_messageParser_header_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_routeFree(pbelle_sip_messageParser_header_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_routeFree(pbelle_sip_messageParser_header_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_route_SCOPE
pbelle_sip_messageParser_header_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_routeStack->size(ctx->pbelle_sip_messageParser_header_routeStack) > ctx->pbelle_sip_messageParser_header_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_route_SCOPE)ctx->pbelle_sip_messageParser_header_routeStack->get(ctx->pbelle_sip_messageParser_header_routeStack, ctx->pbelle_sip_messageParser_header_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_routeStack->push(ctx->pbelle_sip_messageParser_header_routeStack, newAttributes, (void (*)(void *))header_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_route_param scope set 
 */
static pbelle_sip_messageParser_route_param_SCOPE   pbelle_sip_messageParser_route_paramPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL route_paramFree(pbelle_sip_messageParser_route_param_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL route_paramFree(pbelle_sip_messageParser_route_param_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser route_param scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_route_paramTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_route_param_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_route_param_SCOPE
pbelle_sip_messageParser_route_paramPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_route_param_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_route_paramStack->size(ctx->pbelle_sip_messageParser_route_paramStack) > ctx->pbelle_sip_messageParser_route_paramStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_route_param_SCOPE)ctx->pbelle_sip_messageParser_route_paramStack->get(ctx->pbelle_sip_messageParser_route_paramStack, ctx->pbelle_sip_messageParser_route_paramStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_route_param_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_route_param_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_route_paramStack->push(ctx->pbelle_sip_messageParser_route_paramStack, newAttributes, (void (*)(void *))route_paramFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_route_paramStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_to scope set 
 */
static pbelle_sip_messageParser_header_to_SCOPE   pbelle_sip_messageParser_header_toPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_toFree(pbelle_sip_messageParser_header_to_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_toFree(pbelle_sip_messageParser_header_to_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_to scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_toTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_to_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_to_SCOPE
pbelle_sip_messageParser_header_toPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_to_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_toStack->size(ctx->pbelle_sip_messageParser_header_toStack) > ctx->pbelle_sip_messageParser_header_toStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_to_SCOPE)ctx->pbelle_sip_messageParser_header_toStack->get(ctx->pbelle_sip_messageParser_header_toStack, ctx->pbelle_sip_messageParser_header_toStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_to_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_to_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_toStack->push(ctx->pbelle_sip_messageParser_header_toStack, newAttributes, (void (*)(void *))header_toFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_toStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_user_agent scope set 
 */
static pbelle_sip_messageParser_header_user_agent_SCOPE   pbelle_sip_messageParser_header_user_agentPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_user_agentFree(pbelle_sip_messageParser_header_user_agent_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_user_agentFree(pbelle_sip_messageParser_header_user_agent_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_user_agent scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_user_agentTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_user_agent_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_user_agent_SCOPE
pbelle_sip_messageParser_header_user_agentPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_user_agent_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_user_agentStack->size(ctx->pbelle_sip_messageParser_header_user_agentStack) > ctx->pbelle_sip_messageParser_header_user_agentStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_user_agent_SCOPE)ctx->pbelle_sip_messageParser_header_user_agentStack->get(ctx->pbelle_sip_messageParser_header_user_agentStack, ctx->pbelle_sip_messageParser_header_user_agentStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_user_agent_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_user_agent_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_user_agentStack->push(ctx->pbelle_sip_messageParser_header_user_agentStack, newAttributes, (void (*)(void *))header_user_agentFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_user_agentStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_via scope set 
 */
static pbelle_sip_messageParser_header_via_SCOPE   pbelle_sip_messageParser_header_viaPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_viaFree(pbelle_sip_messageParser_header_via_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_viaFree(pbelle_sip_messageParser_header_via_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_via scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_viaTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_via_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_via_SCOPE
pbelle_sip_messageParser_header_viaPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_via_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_viaStack->size(ctx->pbelle_sip_messageParser_header_viaStack) > ctx->pbelle_sip_messageParser_header_viaStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_via_SCOPE)ctx->pbelle_sip_messageParser_header_viaStack->get(ctx->pbelle_sip_messageParser_header_viaStack, ctx->pbelle_sip_messageParser_header_viaStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_via_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_via_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_viaStack->push(ctx->pbelle_sip_messageParser_header_viaStack, newAttributes, (void (*)(void *))header_viaFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_viaStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_via_parm scope set 
 */
static pbelle_sip_messageParser_via_parm_SCOPE   pbelle_sip_messageParser_via_parmPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL via_parmFree(pbelle_sip_messageParser_via_parm_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL via_parmFree(pbelle_sip_messageParser_via_parm_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser via_parm scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_via_parmTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_via_parm_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_via_parm_SCOPE
pbelle_sip_messageParser_via_parmPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_via_parm_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_via_parmStack->size(ctx->pbelle_sip_messageParser_via_parmStack) > ctx->pbelle_sip_messageParser_via_parmStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_via_parm_SCOPE)ctx->pbelle_sip_messageParser_via_parmStack->get(ctx->pbelle_sip_messageParser_via_parmStack, ctx->pbelle_sip_messageParser_via_parmStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_via_parm_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_via_parm_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_via_parmStack->push(ctx->pbelle_sip_messageParser_via_parmStack, newAttributes, (void (*)(void *))via_parmFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_via_parmStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_www_authenticate scope set 
 */
static pbelle_sip_messageParser_header_www_authenticate_SCOPE   pbelle_sip_messageParser_header_www_authenticatePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_www_authenticateFree(pbelle_sip_messageParser_header_www_authenticate_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_www_authenticateFree(pbelle_sip_messageParser_header_www_authenticate_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_www_authenticate scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_www_authenticateTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_www_authenticate_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_www_authenticate_SCOPE
pbelle_sip_messageParser_header_www_authenticatePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_www_authenticate_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_www_authenticateStack->size(ctx->pbelle_sip_messageParser_header_www_authenticateStack) > ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_www_authenticate_SCOPE)ctx->pbelle_sip_messageParser_header_www_authenticateStack->get(ctx->pbelle_sip_messageParser_header_www_authenticateStack, ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_www_authenticate_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_www_authenticate_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_www_authenticateStack->push(ctx->pbelle_sip_messageParser_header_www_authenticateStack, newAttributes, (void (*)(void *))header_www_authenticateFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_subscription_state scope set 
 */
static pbelle_sip_messageParser_header_subscription_state_SCOPE   pbelle_sip_messageParser_header_subscription_statePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_subscription_stateFree(pbelle_sip_messageParser_header_subscription_state_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_subscription_stateFree(pbelle_sip_messageParser_header_subscription_state_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_subscription_state scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_subscription_stateTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_subscription_state_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_subscription_state_SCOPE
pbelle_sip_messageParser_header_subscription_statePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_subscription_state_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_subscription_stateStack->size(ctx->pbelle_sip_messageParser_header_subscription_stateStack) > ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_subscription_state_SCOPE)ctx->pbelle_sip_messageParser_header_subscription_stateStack->get(ctx->pbelle_sip_messageParser_header_subscription_stateStack, ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_subscription_state_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_subscription_state_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_subscription_stateStack->push(ctx->pbelle_sip_messageParser_header_subscription_stateStack, newAttributes, (void (*)(void *))header_subscription_stateFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_replaces scope set 
 */
static pbelle_sip_messageParser_header_replaces_SCOPE   pbelle_sip_messageParser_header_replacesPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_replacesFree(pbelle_sip_messageParser_header_replaces_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_replacesFree(pbelle_sip_messageParser_header_replaces_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_replaces scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_replacesTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_replaces_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_replaces_SCOPE
pbelle_sip_messageParser_header_replacesPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_replaces_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_replacesStack->size(ctx->pbelle_sip_messageParser_header_replacesStack) > ctx->pbelle_sip_messageParser_header_replacesStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_replaces_SCOPE)ctx->pbelle_sip_messageParser_header_replacesStack->get(ctx->pbelle_sip_messageParser_header_replacesStack, ctx->pbelle_sip_messageParser_header_replacesStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_replaces_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_replaces_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_replacesStack->push(ctx->pbelle_sip_messageParser_header_replacesStack, newAttributes, (void (*)(void *))header_replacesFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_replacesStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_privacy scope set 
 */
static pbelle_sip_messageParser_header_privacy_SCOPE   pbelle_sip_messageParser_header_privacyPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_privacyFree(pbelle_sip_messageParser_header_privacy_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_privacyFree(pbelle_sip_messageParser_header_privacy_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_privacy scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_privacyTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_privacy_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_privacy_SCOPE
pbelle_sip_messageParser_header_privacyPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_privacy_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_privacyStack->size(ctx->pbelle_sip_messageParser_header_privacyStack) > ctx->pbelle_sip_messageParser_header_privacyStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_privacy_SCOPE)ctx->pbelle_sip_messageParser_header_privacyStack->get(ctx->pbelle_sip_messageParser_header_privacyStack, ctx->pbelle_sip_messageParser_header_privacyStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_privacy_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_privacy_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_privacyStack->push(ctx->pbelle_sip_messageParser_header_privacyStack, newAttributes, (void (*)(void *))header_privacyFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_privacyStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_paramless_uri scope set 
 */
static pbelle_sip_messageParser_paramless_uri_SCOPE   pbelle_sip_messageParser_paramless_uriPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL paramless_uriFree(pbelle_sip_messageParser_paramless_uri_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL paramless_uriFree(pbelle_sip_messageParser_paramless_uri_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser paramless_uri scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_paramless_uriTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_paramless_uri_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_paramless_uri_SCOPE
pbelle_sip_messageParser_paramless_uriPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_paramless_uri_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_paramless_uriStack->size(ctx->pbelle_sip_messageParser_paramless_uriStack) > ctx->pbelle_sip_messageParser_paramless_uriStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_paramless_uri_SCOPE)ctx->pbelle_sip_messageParser_paramless_uriStack->get(ctx->pbelle_sip_messageParser_paramless_uriStack, ctx->pbelle_sip_messageParser_paramless_uriStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_paramless_uri_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_paramless_uri_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_paramless_uriStack->push(ctx->pbelle_sip_messageParser_paramless_uriStack, newAttributes, (void (*)(void *))paramless_uriFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_paramless_uriStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_uri scope set 
 */
static pbelle_sip_messageParser_uri_SCOPE   pbelle_sip_messageParser_uriPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL uriFree(pbelle_sip_messageParser_uri_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL uriFree(pbelle_sip_messageParser_uri_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser uri scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_uriTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_uri_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_uri_SCOPE
pbelle_sip_messageParser_uriPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_uri_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_uriStack->size(ctx->pbelle_sip_messageParser_uriStack) > ctx->pbelle_sip_messageParser_uriStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_uri_SCOPE)ctx->pbelle_sip_messageParser_uriStack->get(ctx->pbelle_sip_messageParser_uriStack, ctx->pbelle_sip_messageParser_uriStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_uri_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_uri_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_uriStack->push(ctx->pbelle_sip_messageParser_uriStack, newAttributes, (void (*)(void *))uriFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_uriStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_userinfo scope set 
 */
static pbelle_sip_messageParser_userinfo_SCOPE   pbelle_sip_messageParser_userinfoPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL userinfoFree(pbelle_sip_messageParser_userinfo_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL userinfoFree(pbelle_sip_messageParser_userinfo_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser userinfo scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_userinfoTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_userinfo_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_userinfo_SCOPE
pbelle_sip_messageParser_userinfoPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_userinfo_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_userinfoStack->size(ctx->pbelle_sip_messageParser_userinfoStack) > ctx->pbelle_sip_messageParser_userinfoStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_userinfo_SCOPE)ctx->pbelle_sip_messageParser_userinfoStack->get(ctx->pbelle_sip_messageParser_userinfoStack, ctx->pbelle_sip_messageParser_userinfoStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_userinfo_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_userinfo_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_userinfoStack->push(ctx->pbelle_sip_messageParser_userinfoStack, newAttributes, (void (*)(void *))userinfoFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_userinfoStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_hostport scope set 
 */
static pbelle_sip_messageParser_hostport_SCOPE   pbelle_sip_messageParser_hostportPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL hostportFree(pbelle_sip_messageParser_hostport_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL hostportFree(pbelle_sip_messageParser_hostport_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser hostport scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_hostportTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_hostport_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_hostport_SCOPE
pbelle_sip_messageParser_hostportPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_hostport_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_hostportStack->size(ctx->pbelle_sip_messageParser_hostportStack) > ctx->pbelle_sip_messageParser_hostportStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_hostport_SCOPE)ctx->pbelle_sip_messageParser_hostportStack->get(ctx->pbelle_sip_messageParser_hostportStack, ctx->pbelle_sip_messageParser_hostportStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_hostport_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_hostport_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_hostportStack->push(ctx->pbelle_sip_messageParser_hostportStack, newAttributes, (void (*)(void *))hostportFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_hostportStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_host scope set 
 */
static pbelle_sip_messageParser_host_SCOPE   pbelle_sip_messageParser_hostPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL hostFree(pbelle_sip_messageParser_host_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL hostFree(pbelle_sip_messageParser_host_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser host scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_hostTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_host_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_host_SCOPE
pbelle_sip_messageParser_hostPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_host_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_hostStack->size(ctx->pbelle_sip_messageParser_hostStack) > ctx->pbelle_sip_messageParser_hostStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_host_SCOPE)ctx->pbelle_sip_messageParser_hostStack->get(ctx->pbelle_sip_messageParser_hostStack, ctx->pbelle_sip_messageParser_hostStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_host_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_host_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_hostStack->push(ctx->pbelle_sip_messageParser_hostStack, newAttributes, (void (*)(void *))hostFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_hostStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_uri_parameters scope set 
 */
static pbelle_sip_messageParser_uri_parameters_SCOPE   pbelle_sip_messageParser_uri_parametersPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL uri_parametersFree(pbelle_sip_messageParser_uri_parameters_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL uri_parametersFree(pbelle_sip_messageParser_uri_parameters_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser uri_parameters scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_uri_parametersTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_uri_parameters_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_uri_parameters_SCOPE
pbelle_sip_messageParser_uri_parametersPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_uri_parameters_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_uri_parametersStack->size(ctx->pbelle_sip_messageParser_uri_parametersStack) > ctx->pbelle_sip_messageParser_uri_parametersStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_uri_parameters_SCOPE)ctx->pbelle_sip_messageParser_uri_parametersStack->get(ctx->pbelle_sip_messageParser_uri_parametersStack, ctx->pbelle_sip_messageParser_uri_parametersStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_uri_parameters_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_uri_parameters_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_uri_parametersStack->push(ctx->pbelle_sip_messageParser_uri_parametersStack, newAttributes, (void (*)(void *))uri_parametersFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_uri_parametersStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_headers scope set 
 */
static pbelle_sip_messageParser_headers_SCOPE   pbelle_sip_messageParser_headersPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL headersFree(pbelle_sip_messageParser_headers_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL headersFree(pbelle_sip_messageParser_headers_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser headers scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_headersTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_headers_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_headers_SCOPE
pbelle_sip_messageParser_headersPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_headers_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_headersStack->size(ctx->pbelle_sip_messageParser_headersStack) > ctx->pbelle_sip_messageParser_headersStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_headers_SCOPE)ctx->pbelle_sip_messageParser_headersStack->get(ctx->pbelle_sip_messageParser_headersStack, ctx->pbelle_sip_messageParser_headersStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_headers_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_headers_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_headersStack->push(ctx->pbelle_sip_messageParser_headersStack, newAttributes, (void (*)(void *))headersFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_headersStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   belle_sip_messageParserTokenNames[39+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "CRLF",
        (pANTLR3_UINT8) "LWS",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DQUOTE",
        (pANTLR3_UINT8) "STAR",
        (pANTLR3_UINT8) "SEMI",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "SLASH",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "OCTET",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "HEX_CHAR",
        (pANTLR3_UINT8) "COMMON_CHAR",
        (pANTLR3_UINT8) "LAQUOT",
        (pANTLR3_UINT8) "RAQUOT",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "HTAB",
        (pANTLR3_UINT8) "SP",
        (pANTLR3_UINT8) "'@'",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'$'",
        (pANTLR3_UINT8) "'?'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'::'",
        (pANTLR3_UINT8) "'|'",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'`'",
        (pANTLR3_UINT8) "'\\\\'",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'",
        (pANTLR3_UINT8) "'_'",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'~'",
        (pANTLR3_UINT8) "'\\''"
       };

        
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_messageStack
 */
void
pbelle_sip_messageParser_messagePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(message)->free != NULL)
	{
        SCOPE_TOP(message)->free(SCOPE_TOP(message));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_messageStack_limit--;
    SCOPE_TOP(message) = (pbelle_sip_messageParser_message_SCOPE)(ctx->pbelle_sip_messageParser_messageStack->get(ctx->pbelle_sip_messageParser_messageStack, ctx->pbelle_sip_messageParser_messageStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_message_rawStack
 */
void
pbelle_sip_messageParser_message_rawPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(message_raw)->free != NULL)
	{
        SCOPE_TOP(message_raw)->free(SCOPE_TOP(message_raw));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_message_rawStack_limit--;
    SCOPE_TOP(message_raw) = (pbelle_sip_messageParser_message_raw_SCOPE)(ctx->pbelle_sip_messageParser_message_rawStack->get(ctx->pbelle_sip_messageParser_message_rawStack, ctx->pbelle_sip_messageParser_message_rawStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_requestStack
 */
void
pbelle_sip_messageParser_requestPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(request)->free != NULL)
	{
        SCOPE_TOP(request)->free(SCOPE_TOP(request));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_requestStack_limit--;
    SCOPE_TOP(request) = (pbelle_sip_messageParser_request_SCOPE)(ctx->pbelle_sip_messageParser_requestStack->get(ctx->pbelle_sip_messageParser_requestStack, ctx->pbelle_sip_messageParser_requestStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_responseStack
 */
void
pbelle_sip_messageParser_responsePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(response)->free != NULL)
	{
        SCOPE_TOP(response)->free(SCOPE_TOP(response));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_responseStack_limit--;
    SCOPE_TOP(response) = (pbelle_sip_messageParser_response_SCOPE)(ctx->pbelle_sip_messageParser_responseStack->get(ctx->pbelle_sip_messageParser_responseStack, ctx->pbelle_sip_messageParser_responseStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_generic_paramStack
 */
void
pbelle_sip_messageParser_generic_paramPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(generic_param)->free != NULL)
	{
        SCOPE_TOP(generic_param)->free(SCOPE_TOP(generic_param));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_generic_paramStack_limit--;
    SCOPE_TOP(generic_param) = (pbelle_sip_messageParser_generic_param_SCOPE)(ctx->pbelle_sip_messageParser_generic_paramStack->get(ctx->pbelle_sip_messageParser_generic_paramStack, ctx->pbelle_sip_messageParser_generic_paramStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_allowStack
 */
void
pbelle_sip_messageParser_header_allowPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_allow)->free != NULL)
	{
        SCOPE_TOP(header_allow)->free(SCOPE_TOP(header_allow));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_allowStack_limit--;
    SCOPE_TOP(header_allow) = (pbelle_sip_messageParser_header_allow_SCOPE)(ctx->pbelle_sip_messageParser_header_allowStack->get(ctx->pbelle_sip_messageParser_header_allowStack, ctx->pbelle_sip_messageParser_header_allowStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_authorizationStack
 */
void
pbelle_sip_messageParser_header_authorizationPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_authorization)->free != NULL)
	{
        SCOPE_TOP(header_authorization)->free(SCOPE_TOP(header_authorization));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_authorizationStack_limit--;
    SCOPE_TOP(header_authorization) = (pbelle_sip_messageParser_header_authorization_SCOPE)(ctx->pbelle_sip_messageParser_header_authorizationStack->get(ctx->pbelle_sip_messageParser_header_authorizationStack, ctx->pbelle_sip_messageParser_header_authorizationStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_call_idStack
 */
void
pbelle_sip_messageParser_header_call_idPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_call_id)->free != NULL)
	{
        SCOPE_TOP(header_call_id)->free(SCOPE_TOP(header_call_id));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_call_idStack_limit--;
    SCOPE_TOP(header_call_id) = (pbelle_sip_messageParser_header_call_id_SCOPE)(ctx->pbelle_sip_messageParser_header_call_idStack->get(ctx->pbelle_sip_messageParser_header_call_idStack, ctx->pbelle_sip_messageParser_header_call_idStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_contactStack
 */
void
pbelle_sip_messageParser_header_contactPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_contact)->free != NULL)
	{
        SCOPE_TOP(header_contact)->free(SCOPE_TOP(header_contact));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_contactStack_limit--;
    SCOPE_TOP(header_contact) = (pbelle_sip_messageParser_header_contact_SCOPE)(ctx->pbelle_sip_messageParser_header_contactStack->get(ctx->pbelle_sip_messageParser_header_contactStack, ctx->pbelle_sip_messageParser_header_contactStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_contact_paramStack
 */
void
pbelle_sip_messageParser_contact_paramPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(contact_param)->free != NULL)
	{
        SCOPE_TOP(contact_param)->free(SCOPE_TOP(contact_param));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_contact_paramStack_limit--;
    SCOPE_TOP(contact_param) = (pbelle_sip_messageParser_contact_param_SCOPE)(ctx->pbelle_sip_messageParser_contact_paramStack->get(ctx->pbelle_sip_messageParser_contact_paramStack, ctx->pbelle_sip_messageParser_contact_paramStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_content_lengthStack
 */
void
pbelle_sip_messageParser_header_content_lengthPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_content_length)->free != NULL)
	{
        SCOPE_TOP(header_content_length)->free(SCOPE_TOP(header_content_length));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_content_lengthStack_limit--;
    SCOPE_TOP(header_content_length) = (pbelle_sip_messageParser_header_content_length_SCOPE)(ctx->pbelle_sip_messageParser_header_content_lengthStack->get(ctx->pbelle_sip_messageParser_header_content_lengthStack, ctx->pbelle_sip_messageParser_header_content_lengthStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_content_typeStack
 */
void
pbelle_sip_messageParser_header_content_typePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_content_type)->free != NULL)
	{
        SCOPE_TOP(header_content_type)->free(SCOPE_TOP(header_content_type));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_content_typeStack_limit--;
    SCOPE_TOP(header_content_type) = (pbelle_sip_messageParser_header_content_type_SCOPE)(ctx->pbelle_sip_messageParser_header_content_typeStack->get(ctx->pbelle_sip_messageParser_header_content_typeStack, ctx->pbelle_sip_messageParser_header_content_typeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_cseqStack
 */
void
pbelle_sip_messageParser_header_cseqPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_cseq)->free != NULL)
	{
        SCOPE_TOP(header_cseq)->free(SCOPE_TOP(header_cseq));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_cseqStack_limit--;
    SCOPE_TOP(header_cseq) = (pbelle_sip_messageParser_header_cseq_SCOPE)(ctx->pbelle_sip_messageParser_header_cseqStack->get(ctx->pbelle_sip_messageParser_header_cseqStack, ctx->pbelle_sip_messageParser_header_cseqStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_dateStack
 */
void
pbelle_sip_messageParser_header_datePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_date)->free != NULL)
	{
        SCOPE_TOP(header_date)->free(SCOPE_TOP(header_date));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_dateStack_limit--;
    SCOPE_TOP(header_date) = (pbelle_sip_messageParser_header_date_SCOPE)(ctx->pbelle_sip_messageParser_header_dateStack->get(ctx->pbelle_sip_messageParser_header_dateStack, ctx->pbelle_sip_messageParser_header_dateStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_expiresStack
 */
void
pbelle_sip_messageParser_header_expiresPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_expires)->free != NULL)
	{
        SCOPE_TOP(header_expires)->free(SCOPE_TOP(header_expires));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_expiresStack_limit--;
    SCOPE_TOP(header_expires) = (pbelle_sip_messageParser_header_expires_SCOPE)(ctx->pbelle_sip_messageParser_header_expiresStack->get(ctx->pbelle_sip_messageParser_header_expiresStack, ctx->pbelle_sip_messageParser_header_expiresStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_fromStack
 */
void
pbelle_sip_messageParser_header_fromPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_from)->free != NULL)
	{
        SCOPE_TOP(header_from)->free(SCOPE_TOP(header_from));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_fromStack_limit--;
    SCOPE_TOP(header_from) = (pbelle_sip_messageParser_header_from_SCOPE)(ctx->pbelle_sip_messageParser_header_fromStack->get(ctx->pbelle_sip_messageParser_header_fromStack, ctx->pbelle_sip_messageParser_header_fromStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_max_forwardsStack
 */
void
pbelle_sip_messageParser_header_max_forwardsPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_max_forwards)->free != NULL)
	{
        SCOPE_TOP(header_max_forwards)->free(SCOPE_TOP(header_max_forwards));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit--;
    SCOPE_TOP(header_max_forwards) = (pbelle_sip_messageParser_header_max_forwards_SCOPE)(ctx->pbelle_sip_messageParser_header_max_forwardsStack->get(ctx->pbelle_sip_messageParser_header_max_forwardsStack, ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_proxy_authenticateStack
 */
void
pbelle_sip_messageParser_header_proxy_authenticatePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_proxy_authenticate)->free != NULL)
	{
        SCOPE_TOP(header_proxy_authenticate)->free(SCOPE_TOP(header_proxy_authenticate));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit--;
    SCOPE_TOP(header_proxy_authenticate) = (pbelle_sip_messageParser_header_proxy_authenticate_SCOPE)(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->get(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack, ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_qop_optsStack
 */
void
pbelle_sip_messageParser_qop_optsPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(qop_opts)->free != NULL)
	{
        SCOPE_TOP(qop_opts)->free(SCOPE_TOP(qop_opts));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_qop_optsStack_limit--;
    SCOPE_TOP(qop_opts) = (pbelle_sip_messageParser_qop_opts_SCOPE)(ctx->pbelle_sip_messageParser_qop_optsStack->get(ctx->pbelle_sip_messageParser_qop_optsStack, ctx->pbelle_sip_messageParser_qop_optsStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_proxy_authorizationStack
 */
void
pbelle_sip_messageParser_header_proxy_authorizationPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_proxy_authorization)->free != NULL)
	{
        SCOPE_TOP(header_proxy_authorization)->free(SCOPE_TOP(header_proxy_authorization));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit--;
    SCOPE_TOP(header_proxy_authorization) = (pbelle_sip_messageParser_header_proxy_authorization_SCOPE)(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->get(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack, ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_service_routeStack
 */
void
pbelle_sip_messageParser_header_service_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_service_route)->free != NULL)
	{
        SCOPE_TOP(header_service_route)->free(SCOPE_TOP(header_service_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_service_routeStack_limit--;
    SCOPE_TOP(header_service_route) = (pbelle_sip_messageParser_header_service_route_SCOPE)(ctx->pbelle_sip_messageParser_header_service_routeStack->get(ctx->pbelle_sip_messageParser_header_service_routeStack, ctx->pbelle_sip_messageParser_header_service_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_srv_routeStack
 */
void
pbelle_sip_messageParser_srv_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(srv_route)->free != NULL)
	{
        SCOPE_TOP(srv_route)->free(SCOPE_TOP(srv_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_srv_routeStack_limit--;
    SCOPE_TOP(srv_route) = (pbelle_sip_messageParser_srv_route_SCOPE)(ctx->pbelle_sip_messageParser_srv_routeStack->get(ctx->pbelle_sip_messageParser_srv_routeStack, ctx->pbelle_sip_messageParser_srv_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_record_routeStack
 */
void
pbelle_sip_messageParser_header_record_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_record_route)->free != NULL)
	{
        SCOPE_TOP(header_record_route)->free(SCOPE_TOP(header_record_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_record_routeStack_limit--;
    SCOPE_TOP(header_record_route) = (pbelle_sip_messageParser_header_record_route_SCOPE)(ctx->pbelle_sip_messageParser_header_record_routeStack->get(ctx->pbelle_sip_messageParser_header_record_routeStack, ctx->pbelle_sip_messageParser_header_record_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_rec_routeStack
 */
void
pbelle_sip_messageParser_rec_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(rec_route)->free != NULL)
	{
        SCOPE_TOP(rec_route)->free(SCOPE_TOP(rec_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_rec_routeStack_limit--;
    SCOPE_TOP(rec_route) = (pbelle_sip_messageParser_rec_route_SCOPE)(ctx->pbelle_sip_messageParser_rec_routeStack->get(ctx->pbelle_sip_messageParser_rec_routeStack, ctx->pbelle_sip_messageParser_rec_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_routeStack
 */
void
pbelle_sip_messageParser_header_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_route)->free != NULL)
	{
        SCOPE_TOP(header_route)->free(SCOPE_TOP(header_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_routeStack_limit--;
    SCOPE_TOP(header_route) = (pbelle_sip_messageParser_header_route_SCOPE)(ctx->pbelle_sip_messageParser_header_routeStack->get(ctx->pbelle_sip_messageParser_header_routeStack, ctx->pbelle_sip_messageParser_header_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_route_paramStack
 */
void
pbelle_sip_messageParser_route_paramPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(route_param)->free != NULL)
	{
        SCOPE_TOP(route_param)->free(SCOPE_TOP(route_param));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_route_paramStack_limit--;
    SCOPE_TOP(route_param) = (pbelle_sip_messageParser_route_param_SCOPE)(ctx->pbelle_sip_messageParser_route_paramStack->get(ctx->pbelle_sip_messageParser_route_paramStack, ctx->pbelle_sip_messageParser_route_paramStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_toStack
 */
void
pbelle_sip_messageParser_header_toPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_to)->free != NULL)
	{
        SCOPE_TOP(header_to)->free(SCOPE_TOP(header_to));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_toStack_limit--;
    SCOPE_TOP(header_to) = (pbelle_sip_messageParser_header_to_SCOPE)(ctx->pbelle_sip_messageParser_header_toStack->get(ctx->pbelle_sip_messageParser_header_toStack, ctx->pbelle_sip_messageParser_header_toStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_user_agentStack
 */
void
pbelle_sip_messageParser_header_user_agentPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_user_agent)->free != NULL)
	{
        SCOPE_TOP(header_user_agent)->free(SCOPE_TOP(header_user_agent));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_user_agentStack_limit--;
    SCOPE_TOP(header_user_agent) = (pbelle_sip_messageParser_header_user_agent_SCOPE)(ctx->pbelle_sip_messageParser_header_user_agentStack->get(ctx->pbelle_sip_messageParser_header_user_agentStack, ctx->pbelle_sip_messageParser_header_user_agentStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_viaStack
 */
void
pbelle_sip_messageParser_header_viaPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_via)->free != NULL)
	{
        SCOPE_TOP(header_via)->free(SCOPE_TOP(header_via));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_viaStack_limit--;
    SCOPE_TOP(header_via) = (pbelle_sip_messageParser_header_via_SCOPE)(ctx->pbelle_sip_messageParser_header_viaStack->get(ctx->pbelle_sip_messageParser_header_viaStack, ctx->pbelle_sip_messageParser_header_viaStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_via_parmStack
 */
void
pbelle_sip_messageParser_via_parmPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(via_parm)->free != NULL)
	{
        SCOPE_TOP(via_parm)->free(SCOPE_TOP(via_parm));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_via_parmStack_limit--;
    SCOPE_TOP(via_parm) = (pbelle_sip_messageParser_via_parm_SCOPE)(ctx->pbelle_sip_messageParser_via_parmStack->get(ctx->pbelle_sip_messageParser_via_parmStack, ctx->pbelle_sip_messageParser_via_parmStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_www_authenticateStack
 */
void
pbelle_sip_messageParser_header_www_authenticatePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_www_authenticate)->free != NULL)
	{
        SCOPE_TOP(header_www_authenticate)->free(SCOPE_TOP(header_www_authenticate));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit--;
    SCOPE_TOP(header_www_authenticate) = (pbelle_sip_messageParser_header_www_authenticate_SCOPE)(ctx->pbelle_sip_messageParser_header_www_authenticateStack->get(ctx->pbelle_sip_messageParser_header_www_authenticateStack, ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_subscription_stateStack
 */
void
pbelle_sip_messageParser_header_subscription_statePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_subscription_state)->free != NULL)
	{
        SCOPE_TOP(header_subscription_state)->free(SCOPE_TOP(header_subscription_state));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit--;
    SCOPE_TOP(header_subscription_state) = (pbelle_sip_messageParser_header_subscription_state_SCOPE)(ctx->pbelle_sip_messageParser_header_subscription_stateStack->get(ctx->pbelle_sip_messageParser_header_subscription_stateStack, ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_replacesStack
 */
void
pbelle_sip_messageParser_header_replacesPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_replaces)->free != NULL)
	{
        SCOPE_TOP(header_replaces)->free(SCOPE_TOP(header_replaces));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_replacesStack_limit--;
    SCOPE_TOP(header_replaces) = (pbelle_sip_messageParser_header_replaces_SCOPE)(ctx->pbelle_sip_messageParser_header_replacesStack->get(ctx->pbelle_sip_messageParser_header_replacesStack, ctx->pbelle_sip_messageParser_header_replacesStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_privacyStack
 */
void
pbelle_sip_messageParser_header_privacyPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_privacy)->free != NULL)
	{
        SCOPE_TOP(header_privacy)->free(SCOPE_TOP(header_privacy));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_privacyStack_limit--;
    SCOPE_TOP(header_privacy) = (pbelle_sip_messageParser_header_privacy_SCOPE)(ctx->pbelle_sip_messageParser_header_privacyStack->get(ctx->pbelle_sip_messageParser_header_privacyStack, ctx->pbelle_sip_messageParser_header_privacyStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_paramless_uriStack
 */
void
pbelle_sip_messageParser_paramless_uriPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(paramless_uri)->free != NULL)
	{
        SCOPE_TOP(paramless_uri)->free(SCOPE_TOP(paramless_uri));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_paramless_uriStack_limit--;
    SCOPE_TOP(paramless_uri) = (pbelle_sip_messageParser_paramless_uri_SCOPE)(ctx->pbelle_sip_messageParser_paramless_uriStack->get(ctx->pbelle_sip_messageParser_paramless_uriStack, ctx->pbelle_sip_messageParser_paramless_uriStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_uriStack
 */
void
pbelle_sip_messageParser_uriPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(uri)->free != NULL)
	{
        SCOPE_TOP(uri)->free(SCOPE_TOP(uri));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_uriStack_limit--;
    SCOPE_TOP(uri) = (pbelle_sip_messageParser_uri_SCOPE)(ctx->pbelle_sip_messageParser_uriStack->get(ctx->pbelle_sip_messageParser_uriStack, ctx->pbelle_sip_messageParser_uriStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_userinfoStack
 */
void
pbelle_sip_messageParser_userinfoPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(userinfo)->free != NULL)
	{
        SCOPE_TOP(userinfo)->free(SCOPE_TOP(userinfo));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_userinfoStack_limit--;
    SCOPE_TOP(userinfo) = (pbelle_sip_messageParser_userinfo_SCOPE)(ctx->pbelle_sip_messageParser_userinfoStack->get(ctx->pbelle_sip_messageParser_userinfoStack, ctx->pbelle_sip_messageParser_userinfoStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_hostportStack
 */
void
pbelle_sip_messageParser_hostportPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(hostport)->free != NULL)
	{
        SCOPE_TOP(hostport)->free(SCOPE_TOP(hostport));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_hostportStack_limit--;
    SCOPE_TOP(hostport) = (pbelle_sip_messageParser_hostport_SCOPE)(ctx->pbelle_sip_messageParser_hostportStack->get(ctx->pbelle_sip_messageParser_hostportStack, ctx->pbelle_sip_messageParser_hostportStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_hostStack
 */
void
pbelle_sip_messageParser_hostPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(host)->free != NULL)
	{
        SCOPE_TOP(host)->free(SCOPE_TOP(host));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_hostStack_limit--;
    SCOPE_TOP(host) = (pbelle_sip_messageParser_host_SCOPE)(ctx->pbelle_sip_messageParser_hostStack->get(ctx->pbelle_sip_messageParser_hostStack, ctx->pbelle_sip_messageParser_hostStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_uri_parametersStack
 */
void
pbelle_sip_messageParser_uri_parametersPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(uri_parameters)->free != NULL)
	{
        SCOPE_TOP(uri_parameters)->free(SCOPE_TOP(uri_parameters));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_uri_parametersStack_limit--;
    SCOPE_TOP(uri_parameters) = (pbelle_sip_messageParser_uri_parameters_SCOPE)(ctx->pbelle_sip_messageParser_uri_parametersStack->get(ctx->pbelle_sip_messageParser_uri_parametersStack, ctx->pbelle_sip_messageParser_uri_parametersStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_headersStack
 */
void
pbelle_sip_messageParser_headersPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(headers)->free != NULL)
	{
        SCOPE_TOP(headers)->free(SCOPE_TOP(headers));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_headersStack_limit--;
    SCOPE_TOP(headers) = (pbelle_sip_messageParser_headers_SCOPE)(ctx->pbelle_sip_messageParser_headersStack->get(ctx->pbelle_sip_messageParser_headersStack, ctx->pbelle_sip_messageParser_headersStack_limit - 1));
}


// Forward declare the locally static matching functions we have generated.
//
static belle_sip_message_t*	message    (pbelle_sip_messageParser ctx);
static belle_sip_message_t*	message_raw    (pbelle_sip_messageParser ctx, size_t* length);
static belle_sip_request_t*	request    (pbelle_sip_messageParser ctx);
static void	request_line    (pbelle_sip_messageParser ctx);
static void	sip_version    (pbelle_sip_messageParser ctx);
static void	message_header    (pbelle_sip_messageParser ctx, belle_sip_message_t* message);
static belle_sip_messageParser_method_return	method    (pbelle_sip_messageParser ctx);
static void	extension_method    (pbelle_sip_messageParser ctx);
static belle_sip_response_t*	response    (pbelle_sip_messageParser ctx);
static void	status_line    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_status_code_return	status_code    (pbelle_sip_messageParser ctx);
static void	extension_code    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_reason_phrase_return	reason_phrase    (pbelle_sip_messageParser ctx);
static belle_sip_param_pair_t*	generic_param    (pbelle_sip_messageParser ctx, belle_sip_parameters_t* object);
static belle_sip_messageParser_gen_value_return	gen_value    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_quoted_string_return	quoted_string    (pbelle_sip_messageParser ctx);
static belle_sip_header_allow_t*	header_allow    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_methods_return	methods    (pbelle_sip_messageParser ctx);
static void	authorization_token    (pbelle_sip_messageParser ctx);
static void	digest_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_authorization_t*	header_authorization    (pbelle_sip_messageParser ctx);
static void	credentials    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static void	digest_response    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static void	dig_resp    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static void	username_token    (pbelle_sip_messageParser ctx);
static char*	username    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_username_value_return	username_value    (pbelle_sip_messageParser ctx);
static void	uri_token    (pbelle_sip_messageParser ctx);
static void	digest_uri    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static const char*	message_qop    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_qop_value_return	qop_value    (pbelle_sip_messageParser ctx);
static char*	cnonce    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_cnonce_value_return	cnonce_value    (pbelle_sip_messageParser ctx);
static const char*	nonce_count    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_nc_value_return	nc_value    (pbelle_sip_messageParser ctx);
static char*	dresponse    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_request_digest_return	request_digest    (pbelle_sip_messageParser ctx);
static void	huit_lhex    (pbelle_sip_messageParser ctx);
static void	auth_param    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static belle_sip_messageParser_auth_param_value_return	auth_param_value    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_auth_param_name_return	auth_param_name    (pbelle_sip_messageParser ctx);
static void	other_response    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static belle_sip_messageParser_auth_scheme_return	auth_scheme    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_nonce_value_return	nonce_value    (pbelle_sip_messageParser ctx);
static void	call_id_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_call_id_t*	header_call_id    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_call_id_return	call_id    (pbelle_sip_messageParser ctx);
static void	contact_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_contact_t*	header_contact    (pbelle_sip_messageParser ctx);
static void	contact_param    (pbelle_sip_messageParser ctx);
static belle_sip_header_address_t*	header_address    (pbelle_sip_messageParser ctx);
static belle_sip_header_address_t*	header_address_base    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* obj);
static void	name_addr    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	addr_spec    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	paramless_addr_spec    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	display_name    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	contact_params    (pbelle_sip_messageParser ctx);
static void	contact_extension    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_delta_seconds_return	delta_seconds    (pbelle_sip_messageParser ctx);
static void	content_length_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_content_length_t*	header_content_length    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_content_length_return	content_length    (pbelle_sip_messageParser ctx);
static void	content_type_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_content_type_t*	header_content_type    (pbelle_sip_messageParser ctx);
static void	media_type    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_m_type_return	m_type    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_m_subtype_return	m_subtype    (pbelle_sip_messageParser ctx);
static void	cseq_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_cseq_t*	header_cseq    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_seq_number_return	seq_number    (pbelle_sip_messageParser ctx);
static void	date_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_date_t*	header_date    (pbelle_sip_messageParser ctx);
static void	date    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_sip_date_return	sip_date    (pbelle_sip_messageParser ctx);
static belle_sip_header_expires_t*	header_expires    (pbelle_sip_messageParser ctx);
static void	from_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_from_t*	header_from    (pbelle_sip_messageParser ctx);
static void	from_spec    (pbelle_sip_messageParser ctx);
static void	from_param    (pbelle_sip_messageParser ctx);
static belle_sip_header_max_forwards_t*	header_max_forwards    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_max_forwards_return	max_forwards    (pbelle_sip_messageParser ctx);
static belle_sip_header_proxy_authenticate_t*	header_proxy_authenticate    (pbelle_sip_messageParser ctx);
static void	challenge    (pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate);
static void	other_challenge    (pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate);
static void	digest_cln    (pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate);
static char*	realm    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_realm_value_return	realm_value    (pbelle_sip_messageParser ctx);
static char*	domain    (pbelle_sip_messageParser ctx);
static char*	nonce    (pbelle_sip_messageParser ctx);
static char*	opaque    (pbelle_sip_messageParser ctx);
static const char*	stale    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_stale_value_return	stale_value    (pbelle_sip_messageParser ctx);
static const char*	algorithm    (pbelle_sip_messageParser ctx);
static belle_sip_list_t*	qop_opts    (pbelle_sip_messageParser ctx);
static void	qop_opts_value    (pbelle_sip_messageParser ctx);
static belle_sip_header_proxy_authorization_t*	header_proxy_authorization    (pbelle_sip_messageParser ctx);
static void	service_route_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_service_route_t*	header_service_route    (pbelle_sip_messageParser ctx);
static void	srv_route    (pbelle_sip_messageParser ctx);
static void	sr_param    (pbelle_sip_messageParser ctx);
static void	record_route_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_record_route_t*	header_record_route    (pbelle_sip_messageParser ctx);
static void	rec_route    (pbelle_sip_messageParser ctx);
static void	rr_param    (pbelle_sip_messageParser ctx);
static void	comment    (pbelle_sip_messageParser ctx);
static void	route_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_route_t*	header_route    (pbelle_sip_messageParser ctx);
static void	route_param    (pbelle_sip_messageParser ctx);
static void	r_param    (pbelle_sip_messageParser ctx);
static void	to_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_to_t*	header_to    (pbelle_sip_messageParser ctx);
static void	to_spec    (pbelle_sip_messageParser ctx);
static void	to_param    (pbelle_sip_messageParser ctx);
static void	refer_to_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_refer_to_t*	header_refer_to    (pbelle_sip_messageParser ctx);
static void	referred_by_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_referred_by_t*	header_referred_by    (pbelle_sip_messageParser ctx);
static belle_sip_header_address_t*	refer_to_spec    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* address);
static belle_sip_header_user_agent_t*	header_user_agent    (pbelle_sip_messageParser ctx);
static void	server_val    (pbelle_sip_messageParser ctx);
static void	serval_item    (pbelle_sip_messageParser ctx);
static void	product    (pbelle_sip_messageParser ctx);
static void	product_version    (pbelle_sip_messageParser ctx);
static void	via_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_via_t*	header_via    (pbelle_sip_messageParser ctx);
static void	via_parm    (pbelle_sip_messageParser ctx);
static void	via_params    (pbelle_sip_messageParser ctx);
static void	via_received    (pbelle_sip_messageParser ctx, belle_sip_header_via_t* object);
static belle_sip_messageParser_via_address_return	via_address    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_sent_protocol_return	sent_protocol    (pbelle_sip_messageParser ctx);
static void	protocol_name    (pbelle_sip_messageParser ctx);
static void	protocol_version    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_transport_return	transport    (pbelle_sip_messageParser ctx);
static void	other_transport    (pbelle_sip_messageParser ctx);
static void	sent_by    (pbelle_sip_messageParser ctx);
static belle_sip_header_www_authenticate_t*	header_www_authenticate    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_state_value_return	state_value    (pbelle_sip_messageParser ctx);
static belle_sip_header_subscription_state_t*	header_subscription_state    (pbelle_sip_messageParser ctx);
static belle_sip_header_replaces_t*	header_replaces    (pbelle_sip_messageParser ctx);
static belle_sip_header_p_preferred_identity_t*	header_p_preferred_identity    (pbelle_sip_messageParser ctx);
static belle_sip_header_privacy_t*	header_privacy    (pbelle_sip_messageParser ctx);
static void	privacy_val    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_header_extension_return	header_extension    (pbelle_sip_messageParser ctx, ANTLR3_BOOLEAN check_for_known_header);
static belle_sip_messageParser_header_name_return	header_name    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_header_value_return	header_value    (pbelle_sip_messageParser ctx);
static void	message_body    (pbelle_sip_messageParser ctx);
static belle_sip_uri_t*	paramless_uri    (pbelle_sip_messageParser ctx);
static belle_sip_uri_t*	uri    (pbelle_sip_messageParser ctx);
static void	sip_token    (pbelle_sip_messageParser ctx);
static void	sips_token    (pbelle_sip_messageParser ctx);
static void	sip_schema    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static void	userinfo    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static belle_sip_messageParser_user_return	user    (pbelle_sip_messageParser ctx);
static void	user_unreserved    (pbelle_sip_messageParser ctx);
static void	password    (pbelle_sip_messageParser ctx);
static void	hostport    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static const char*	host    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_hostname_return	hostname    (pbelle_sip_messageParser ctx);
static void	domainlabel    (pbelle_sip_messageParser ctx);
static void	toplabel    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_ipv4address_return	ipv4address    (pbelle_sip_messageParser ctx);
static void	ipv6reference    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_ipv6address_return	ipv6address    (pbelle_sip_messageParser ctx);
static void	hexpart    (pbelle_sip_messageParser ctx);
static void	hexseq    (pbelle_sip_messageParser ctx);
static void	hex4    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_port_return	port    (pbelle_sip_messageParser ctx);
static void	uri_parameters    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static void	uri_parameter    (pbelle_sip_messageParser ctx);
static void	other_param    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_pname_return	pname    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_pvalue_return	pvalue    (pbelle_sip_messageParser ctx);
static void	paramchar    (pbelle_sip_messageParser ctx);
static void	param_unreserved    (pbelle_sip_messageParser ctx);
static void	headers    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static void	header    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_hname_return	hname    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_hvalue_return	hvalue    (pbelle_sip_messageParser ctx);
static void	hnv_unreserved    (pbelle_sip_messageParser ctx);
static void	escaped    (pbelle_sip_messageParser ctx);
static void	ttl    (pbelle_sip_messageParser ctx);
static void	three_digit    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_token_return	token    (pbelle_sip_messageParser ctx);
static void	reserved    (pbelle_sip_messageParser ctx);
static void	unreserved    (pbelle_sip_messageParser ctx);
static void	alphanum    (pbelle_sip_messageParser ctx);
static void	hexdigit    (pbelle_sip_messageParser ctx);
static void	alpha    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_word_return	word    (pbelle_sip_messageParser ctx);
static void	mark    (pbelle_sip_messageParser ctx);
static void	hcolon    (pbelle_sip_messageParser ctx);
static void	ldquot    (pbelle_sip_messageParser ctx);
static void	rdquot    (pbelle_sip_messageParser ctx);
static void	semi    (pbelle_sip_messageParser ctx);
static void	comma    (pbelle_sip_messageParser ctx);
static void	sp_laquot_sp    (pbelle_sip_messageParser ctx);
static void	sp_raquot_sp    (pbelle_sip_messageParser ctx);
static void	equal    (pbelle_sip_messageParser ctx);
static void	slash    (pbelle_sip_messageParser ctx);
static void	belle_sip_messageParserFree(pbelle_sip_messageParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new belle_sip_messageParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pbelle_sip_messageParser
belle_sip_messageParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return belle_sip_messageParserNewSSD(instream, NULL);
}

/** \brief Create a new belle_sip_messageParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pbelle_sip_messageParser
belle_sip_messageParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pbelle_sip_messageParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pbelle_sip_messageParser) ANTLR3_CALLOC(1, sizeof(belle_sip_messageParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in belle_sip_messageParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our belle_sip_messageParser interface
     */
    ctx->message	= message;
    ctx->message_raw	= message_raw;
    ctx->request	= request;
    ctx->request_line	= request_line;
    ctx->sip_version	= sip_version;
    ctx->message_header	= message_header;
    ctx->method	= method;
    ctx->extension_method	= extension_method;
    ctx->response	= response;
    ctx->status_line	= status_line;
    ctx->status_code	= status_code;
    ctx->extension_code	= extension_code;
    ctx->reason_phrase	= reason_phrase;
    ctx->generic_param	= generic_param;
    ctx->gen_value	= gen_value;
    ctx->quoted_string	= quoted_string;
    ctx->header_allow	= header_allow;
    ctx->methods	= methods;
    ctx->authorization_token	= authorization_token;
    ctx->digest_token	= digest_token;
    ctx->header_authorization	= header_authorization;
    ctx->credentials	= credentials;
    ctx->digest_response	= digest_response;
    ctx->dig_resp	= dig_resp;
    ctx->username_token	= username_token;
    ctx->username	= username;
    ctx->username_value	= username_value;
    ctx->uri_token	= uri_token;
    ctx->digest_uri	= digest_uri;
    ctx->message_qop	= message_qop;
    ctx->qop_value	= qop_value;
    ctx->cnonce	= cnonce;
    ctx->cnonce_value	= cnonce_value;
    ctx->nonce_count	= nonce_count;
    ctx->nc_value	= nc_value;
    ctx->dresponse	= dresponse;
    ctx->request_digest	= request_digest;
    ctx->huit_lhex	= huit_lhex;
    ctx->auth_param	= auth_param;
    ctx->auth_param_value	= auth_param_value;
    ctx->auth_param_name	= auth_param_name;
    ctx->other_response	= other_response;
    ctx->auth_scheme	= auth_scheme;
    ctx->nonce_value	= nonce_value;
    ctx->call_id_token	= call_id_token;
    ctx->header_call_id	= header_call_id;
    ctx->call_id	= call_id;
    ctx->contact_token	= contact_token;
    ctx->header_contact	= header_contact;
    ctx->contact_param	= contact_param;
    ctx->header_address	= header_address;
    ctx->header_address_base	= header_address_base;
    ctx->name_addr	= name_addr;
    ctx->addr_spec	= addr_spec;
    ctx->paramless_addr_spec	= paramless_addr_spec;
    ctx->display_name	= display_name;
    ctx->contact_params	= contact_params;
    ctx->contact_extension	= contact_extension;
    ctx->delta_seconds	= delta_seconds;
    ctx->content_length_token	= content_length_token;
    ctx->header_content_length	= header_content_length;
    ctx->content_length	= content_length;
    ctx->content_type_token	= content_type_token;
    ctx->header_content_type	= header_content_type;
    ctx->media_type	= media_type;
    ctx->m_type	= m_type;
    ctx->m_subtype	= m_subtype;
    ctx->cseq_token	= cseq_token;
    ctx->header_cseq	= header_cseq;
    ctx->seq_number	= seq_number;
    ctx->date_token	= date_token;
    ctx->header_date	= header_date;
    ctx->date	= date;
    ctx->sip_date	= sip_date;
    ctx->header_expires	= header_expires;
    ctx->from_token	= from_token;
    ctx->header_from	= header_from;
    ctx->from_spec	= from_spec;
    ctx->from_param	= from_param;
    ctx->header_max_forwards	= header_max_forwards;
    ctx->max_forwards	= max_forwards;
    ctx->header_proxy_authenticate	= header_proxy_authenticate;
    ctx->challenge	= challenge;
    ctx->other_challenge	= other_challenge;
    ctx->digest_cln	= digest_cln;
    ctx->realm	= realm;
    ctx->realm_value	= realm_value;
    ctx->domain	= domain;
    ctx->nonce	= nonce;
    ctx->opaque	= opaque;
    ctx->stale	= stale;
    ctx->stale_value	= stale_value;
    ctx->algorithm	= algorithm;
    ctx->qop_opts	= qop_opts;
    ctx->qop_opts_value	= qop_opts_value;
    ctx->header_proxy_authorization	= header_proxy_authorization;
    ctx->service_route_token	= service_route_token;
    ctx->header_service_route	= header_service_route;
    ctx->srv_route	= srv_route;
    ctx->sr_param	= sr_param;
    ctx->record_route_token	= record_route_token;
    ctx->header_record_route	= header_record_route;
    ctx->rec_route	= rec_route;
    ctx->rr_param	= rr_param;
    ctx->comment	= comment;
    ctx->route_token	= route_token;
    ctx->header_route	= header_route;
    ctx->route_param	= route_param;
    ctx->r_param	= r_param;
    ctx->to_token	= to_token;
    ctx->header_to	= header_to;
    ctx->to_spec	= to_spec;
    ctx->to_param	= to_param;
    ctx->refer_to_token	= refer_to_token;
    ctx->header_refer_to	= header_refer_to;
    ctx->referred_by_token	= referred_by_token;
    ctx->header_referred_by	= header_referred_by;
    ctx->refer_to_spec	= refer_to_spec;
    ctx->header_user_agent	= header_user_agent;
    ctx->server_val	= server_val;
    ctx->serval_item	= serval_item;
    ctx->product	= product;
    ctx->product_version	= product_version;
    ctx->via_token	= via_token;
    ctx->header_via	= header_via;
    ctx->via_parm	= via_parm;
    ctx->via_params	= via_params;
    ctx->via_received	= via_received;
    ctx->via_address	= via_address;
    ctx->sent_protocol	= sent_protocol;
    ctx->protocol_name	= protocol_name;
    ctx->protocol_version	= protocol_version;
    ctx->transport	= transport;
    ctx->other_transport	= other_transport;
    ctx->sent_by	= sent_by;
    ctx->header_www_authenticate	= header_www_authenticate;
    ctx->state_value	= state_value;
    ctx->header_subscription_state	= header_subscription_state;
    ctx->header_replaces	= header_replaces;
    ctx->header_p_preferred_identity	= header_p_preferred_identity;
    ctx->header_privacy	= header_privacy;
    ctx->privacy_val	= privacy_val;
    ctx->header_extension	= header_extension;
    ctx->header_name	= header_name;
    ctx->header_value	= header_value;
    ctx->message_body	= message_body;
    ctx->paramless_uri	= paramless_uri;
    ctx->uri	= uri;
    ctx->sip_token	= sip_token;
    ctx->sips_token	= sips_token;
    ctx->sip_schema	= sip_schema;
    ctx->userinfo	= userinfo;
    ctx->user	= user;
    ctx->user_unreserved	= user_unreserved;
    ctx->password	= password;
    ctx->hostport	= hostport;
    ctx->host	= host;
    ctx->hostname	= hostname;
    ctx->domainlabel	= domainlabel;
    ctx->toplabel	= toplabel;
    ctx->ipv4address	= ipv4address;
    ctx->ipv6reference	= ipv6reference;
    ctx->ipv6address	= ipv6address;
    ctx->hexpart	= hexpart;
    ctx->hexseq	= hexseq;
    ctx->hex4	= hex4;
    ctx->port	= port;
    ctx->uri_parameters	= uri_parameters;
    ctx->uri_parameter	= uri_parameter;
    ctx->other_param	= other_param;
    ctx->pname	= pname;
    ctx->pvalue	= pvalue;
    ctx->paramchar	= paramchar;
    ctx->param_unreserved	= param_unreserved;
    ctx->headers	= headers;
    ctx->header	= header;
    ctx->hname	= hname;
    ctx->hvalue	= hvalue;
    ctx->hnv_unreserved	= hnv_unreserved;
    ctx->escaped	= escaped;
    ctx->ttl	= ttl;
    ctx->three_digit	= three_digit;
    ctx->token	= token;
    ctx->reserved	= reserved;
    ctx->unreserved	= unreserved;
    ctx->alphanum	= alphanum;
    ctx->hexdigit	= hexdigit;
    ctx->alpha	= alpha;
    ctx->word	= word;
    ctx->mark	= mark;
    ctx->hcolon	= hcolon;
    ctx->ldquot	= ldquot;
    ctx->rdquot	= rdquot;
    ctx->semi	= semi;
    ctx->comma	= comma;
    ctx->sp_laquot_sp	= sp_laquot_sp;
    ctx->sp_raquot_sp	= sp_raquot_sp;
    ctx->equal	= equal;
    ctx->slash	= slash;
    ctx->free			= belle_sip_messageParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_messagePush     = pbelle_sip_messageParser_messagePush;
    ctx->pbelle_sip_messageParser_messageStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_messageStack_limit    = 0;
    ctx->pbelle_sip_messageParser_messageTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_message_rawPush     = pbelle_sip_messageParser_message_rawPush;
    ctx->pbelle_sip_messageParser_message_rawStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_message_rawStack_limit    = 0;
    ctx->pbelle_sip_messageParser_message_rawTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_requestPush     = pbelle_sip_messageParser_requestPush;
    ctx->pbelle_sip_messageParser_requestStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_requestStack_limit    = 0;
    ctx->pbelle_sip_messageParser_requestTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_responsePush     = pbelle_sip_messageParser_responsePush;
    ctx->pbelle_sip_messageParser_responseStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_responseStack_limit    = 0;
    ctx->pbelle_sip_messageParser_responseTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_generic_paramPush     = pbelle_sip_messageParser_generic_paramPush;
    ctx->pbelle_sip_messageParser_generic_paramStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_generic_paramStack_limit    = 0;
    ctx->pbelle_sip_messageParser_generic_paramTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_allowPush     = pbelle_sip_messageParser_header_allowPush;
    ctx->pbelle_sip_messageParser_header_allowStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_allowStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_allowTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_authorizationPush     = pbelle_sip_messageParser_header_authorizationPush;
    ctx->pbelle_sip_messageParser_header_authorizationStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_authorizationStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_authorizationTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_call_idPush     = pbelle_sip_messageParser_header_call_idPush;
    ctx->pbelle_sip_messageParser_header_call_idStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_call_idStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_call_idTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_contactPush     = pbelle_sip_messageParser_header_contactPush;
    ctx->pbelle_sip_messageParser_header_contactStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_contactStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_contactTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_contact_paramPush     = pbelle_sip_messageParser_contact_paramPush;
    ctx->pbelle_sip_messageParser_contact_paramStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_contact_paramStack_limit    = 0;
    ctx->pbelle_sip_messageParser_contact_paramTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_content_lengthPush     = pbelle_sip_messageParser_header_content_lengthPush;
    ctx->pbelle_sip_messageParser_header_content_lengthStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_content_lengthStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_content_lengthTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_content_typePush     = pbelle_sip_messageParser_header_content_typePush;
    ctx->pbelle_sip_messageParser_header_content_typeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_content_typeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_content_typeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_cseqPush     = pbelle_sip_messageParser_header_cseqPush;
    ctx->pbelle_sip_messageParser_header_cseqStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_cseqStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_cseqTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_datePush     = pbelle_sip_messageParser_header_datePush;
    ctx->pbelle_sip_messageParser_header_dateStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_dateStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_dateTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_expiresPush     = pbelle_sip_messageParser_header_expiresPush;
    ctx->pbelle_sip_messageParser_header_expiresStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_expiresStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_expiresTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_fromPush     = pbelle_sip_messageParser_header_fromPush;
    ctx->pbelle_sip_messageParser_header_fromStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_fromStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_fromTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_max_forwardsPush     = pbelle_sip_messageParser_header_max_forwardsPush;
    ctx->pbelle_sip_messageParser_header_max_forwardsStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_max_forwardsTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_proxy_authenticatePush     = pbelle_sip_messageParser_header_proxy_authenticatePush;
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_proxy_authenticateTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_qop_optsPush     = pbelle_sip_messageParser_qop_optsPush;
    ctx->pbelle_sip_messageParser_qop_optsStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_qop_optsStack_limit    = 0;
    ctx->pbelle_sip_messageParser_qop_optsTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_proxy_authorizationPush     = pbelle_sip_messageParser_header_proxy_authorizationPush;
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_proxy_authorizationTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_service_routePush     = pbelle_sip_messageParser_header_service_routePush;
    ctx->pbelle_sip_messageParser_header_service_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_service_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_service_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_srv_routePush     = pbelle_sip_messageParser_srv_routePush;
    ctx->pbelle_sip_messageParser_srv_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_srv_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_srv_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_record_routePush     = pbelle_sip_messageParser_header_record_routePush;
    ctx->pbelle_sip_messageParser_header_record_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_record_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_record_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_rec_routePush     = pbelle_sip_messageParser_rec_routePush;
    ctx->pbelle_sip_messageParser_rec_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_rec_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_rec_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_routePush     = pbelle_sip_messageParser_header_routePush;
    ctx->pbelle_sip_messageParser_header_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_route_paramPush     = pbelle_sip_messageParser_route_paramPush;
    ctx->pbelle_sip_messageParser_route_paramStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_route_paramStack_limit    = 0;
    ctx->pbelle_sip_messageParser_route_paramTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_toPush     = pbelle_sip_messageParser_header_toPush;
    ctx->pbelle_sip_messageParser_header_toStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_toStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_toTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_user_agentPush     = pbelle_sip_messageParser_header_user_agentPush;
    ctx->pbelle_sip_messageParser_header_user_agentStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_user_agentStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_user_agentTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_viaPush     = pbelle_sip_messageParser_header_viaPush;
    ctx->pbelle_sip_messageParser_header_viaStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_viaStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_viaTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_via_parmPush     = pbelle_sip_messageParser_via_parmPush;
    ctx->pbelle_sip_messageParser_via_parmStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_via_parmStack_limit    = 0;
    ctx->pbelle_sip_messageParser_via_parmTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_www_authenticatePush     = pbelle_sip_messageParser_header_www_authenticatePush;
    ctx->pbelle_sip_messageParser_header_www_authenticateStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_www_authenticateTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_subscription_statePush     = pbelle_sip_messageParser_header_subscription_statePush;
    ctx->pbelle_sip_messageParser_header_subscription_stateStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_subscription_stateTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_replacesPush     = pbelle_sip_messageParser_header_replacesPush;
    ctx->pbelle_sip_messageParser_header_replacesStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_replacesStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_replacesTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_privacyPush     = pbelle_sip_messageParser_header_privacyPush;
    ctx->pbelle_sip_messageParser_header_privacyStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_privacyStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_privacyTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_paramless_uriPush     = pbelle_sip_messageParser_paramless_uriPush;
    ctx->pbelle_sip_messageParser_paramless_uriStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_paramless_uriStack_limit    = 0;
    ctx->pbelle_sip_messageParser_paramless_uriTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uriPush     = pbelle_sip_messageParser_uriPush;
    ctx->pbelle_sip_messageParser_uriStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_uriStack_limit    = 0;
    ctx->pbelle_sip_messageParser_uriTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_userinfoPush     = pbelle_sip_messageParser_userinfoPush;
    ctx->pbelle_sip_messageParser_userinfoStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_userinfoStack_limit    = 0;
    ctx->pbelle_sip_messageParser_userinfoTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_hostportPush     = pbelle_sip_messageParser_hostportPush;
    ctx->pbelle_sip_messageParser_hostportStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_hostportStack_limit    = 0;
    ctx->pbelle_sip_messageParser_hostportTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_hostPush     = pbelle_sip_messageParser_hostPush;
    ctx->pbelle_sip_messageParser_hostStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_hostStack_limit    = 0;
    ctx->pbelle_sip_messageParser_hostTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uri_parametersPush     = pbelle_sip_messageParser_uri_parametersPush;
    ctx->pbelle_sip_messageParser_uri_parametersStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_uri_parametersStack_limit    = 0;
    ctx->pbelle_sip_messageParser_uri_parametersTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_headersPush     = pbelle_sip_messageParser_headersPush;
    ctx->pbelle_sip_messageParser_headersStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_headersStack_limit    = 0;
    ctx->pbelle_sip_messageParser_headersTop      = NULL;


        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = belle_sip_messageParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 belle_sip_messageParserFree(pbelle_sip_messageParser ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_messageStack->free(ctx->pbelle_sip_messageParser_messageStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_message_rawStack->free(ctx->pbelle_sip_messageParser_message_rawStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_requestStack->free(ctx->pbelle_sip_messageParser_requestStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_responseStack->free(ctx->pbelle_sip_messageParser_responseStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_generic_paramStack->free(ctx->pbelle_sip_messageParser_generic_paramStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_allowStack->free(ctx->pbelle_sip_messageParser_header_allowStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_authorizationStack->free(ctx->pbelle_sip_messageParser_header_authorizationStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_call_idStack->free(ctx->pbelle_sip_messageParser_header_call_idStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_contactStack->free(ctx->pbelle_sip_messageParser_header_contactStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_contact_paramStack->free(ctx->pbelle_sip_messageParser_contact_paramStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_content_lengthStack->free(ctx->pbelle_sip_messageParser_header_content_lengthStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_content_typeStack->free(ctx->pbelle_sip_messageParser_header_content_typeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_cseqStack->free(ctx->pbelle_sip_messageParser_header_cseqStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_dateStack->free(ctx->pbelle_sip_messageParser_header_dateStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_expiresStack->free(ctx->pbelle_sip_messageParser_header_expiresStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_fromStack->free(ctx->pbelle_sip_messageParser_header_fromStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_max_forwardsStack->free(ctx->pbelle_sip_messageParser_header_max_forwardsStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->free(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_qop_optsStack->free(ctx->pbelle_sip_messageParser_qop_optsStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->free(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_service_routeStack->free(ctx->pbelle_sip_messageParser_header_service_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_srv_routeStack->free(ctx->pbelle_sip_messageParser_srv_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_record_routeStack->free(ctx->pbelle_sip_messageParser_header_record_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_rec_routeStack->free(ctx->pbelle_sip_messageParser_rec_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_routeStack->free(ctx->pbelle_sip_messageParser_header_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_route_paramStack->free(ctx->pbelle_sip_messageParser_route_paramStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_toStack->free(ctx->pbelle_sip_messageParser_header_toStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_user_agentStack->free(ctx->pbelle_sip_messageParser_header_user_agentStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_viaStack->free(ctx->pbelle_sip_messageParser_header_viaStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_via_parmStack->free(ctx->pbelle_sip_messageParser_via_parmStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_www_authenticateStack->free(ctx->pbelle_sip_messageParser_header_www_authenticateStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_subscription_stateStack->free(ctx->pbelle_sip_messageParser_header_subscription_stateStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_replacesStack->free(ctx->pbelle_sip_messageParser_header_replacesStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_privacyStack->free(ctx->pbelle_sip_messageParser_header_privacyStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_paramless_uriStack->free(ctx->pbelle_sip_messageParser_paramless_uriStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uriStack->free(ctx->pbelle_sip_messageParser_uriStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_userinfoStack->free(ctx->pbelle_sip_messageParser_userinfoStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_hostportStack->free(ctx->pbelle_sip_messageParser_hostportStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_hostStack->free(ctx->pbelle_sip_messageParser_hostStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uri_parametersStack->free(ctx->pbelle_sip_messageParser_uri_parametersStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_headersStack->free(ctx->pbelle_sip_messageParser_headersStack);

    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return belle_sip_messageParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_raw_in_message63  */
static	ANTLR3_BITWORD FOLLOW_message_raw_in_message63_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_message_raw_in_message63	= { FOLLOW_message_raw_in_message63_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_request_in_message_raw92  */
static	ANTLR3_BITWORD FOLLOW_request_in_message_raw92_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_request_in_message_raw92	= { FOLLOW_request_in_message_raw92_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_response_in_message_raw103  */
static	ANTLR3_BITWORD FOLLOW_response_in_message_raw103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_response_in_message_raw103	= { FOLLOW_response_in_message_raw103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_request_line_in_request129  */
static	ANTLR3_BITWORD FOLLOW_request_line_in_request129_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_request_line_in_request129	= { FOLLOW_request_line_in_request129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_header_in_request132  */
static	ANTLR3_BITWORD FOLLOW_message_header_in_request132_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338150) };
static  ANTLR3_BITSET_LIST FOLLOW_message_header_in_request132	= { FOLLOW_message_header_in_request132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_request138  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_request138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_request138	= { FOLLOW_CRLF_in_request138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_request_line157  */
static	ANTLR3_BITWORD FOLLOW_method_in_request_line157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_request_line157	= { FOLLOW_method_in_request_line157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_request_line171  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_request_line171_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_request_line171	= { FOLLOW_LWS_in_request_line171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_in_request_line179  */
static	ANTLR3_BITWORD FOLLOW_uri_in_request_line179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_in_request_line179	= { FOLLOW_uri_in_request_line179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_request_line188  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_request_line188_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C0) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_request_line188	= { FOLLOW_LWS_in_request_line188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_version_in_request_line196  */
static	ANTLR3_BITWORD FOLLOW_sip_version_in_request_line196_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_version_in_request_line196	= { FOLLOW_sip_version_in_request_line196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_request_line204  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_request_line204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_request_line204	= { FOLLOW_CRLF_in_request_line204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_sip_version217  */
static	ANTLR3_BITWORD FOLLOW_word_in_sip_version217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_sip_version217	= { FOLLOW_word_in_sip_version217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_extension_in_message_header293  */
static	ANTLR3_BITWORD FOLLOW_header_extension_in_message_header293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_header_extension_in_message_header293	= { FOLLOW_header_extension_in_message_header293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_message_header317  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_message_header317_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_message_header317	= { FOLLOW_CRLF_in_message_header317_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_method_in_method364  */
static	ANTLR3_BITWORD FOLLOW_extension_method_in_method364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_method_in_method364	= { FOLLOW_extension_method_in_method364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_extension_method378  */
static	ANTLR3_BITWORD FOLLOW_token_in_extension_method378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_extension_method378	= { FOLLOW_token_in_extension_method378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_status_line_in_response412  */
static	ANTLR3_BITWORD FOLLOW_status_line_in_response412_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338142) };
static  ANTLR3_BITSET_LIST FOLLOW_status_line_in_response412	= { FOLLOW_status_line_in_response412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_header_in_response415  */
static	ANTLR3_BITWORD FOLLOW_message_header_in_response415_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338150) };
static  ANTLR3_BITSET_LIST FOLLOW_message_header_in_response415	= { FOLLOW_message_header_in_response415_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_response421  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_response421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_response421	= { FOLLOW_CRLF_in_response421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_version_in_status_line445  */
static	ANTLR3_BITWORD FOLLOW_sip_version_in_status_line445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_version_in_status_line445	= { FOLLOW_sip_version_in_status_line445_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_status_line452  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_status_line452_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_status_line452	= { FOLLOW_LWS_in_status_line452_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_status_code_in_status_line454  */
static	ANTLR3_BITWORD FOLLOW_status_code_in_status_line454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_status_code_in_status_line454	= { FOLLOW_status_code_in_status_line454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_status_line462  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_status_line462_bits[]	= { ANTLR3_UINT64_LIT(0x000007FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_status_line462	= { FOLLOW_LWS_in_status_line462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_reason_phrase_in_status_line464  */
static	ANTLR3_BITWORD FOLLOW_reason_phrase_in_status_line464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_reason_phrase_in_status_line464	= { FOLLOW_reason_phrase_in_status_line464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_status_line472  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_status_line472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_status_line472	= { FOLLOW_CRLF_in_status_line472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_code_in_status_code488  */
static	ANTLR3_BITWORD FOLLOW_extension_code_in_status_code488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_code_in_status_code488	= { FOLLOW_extension_code_in_status_code488_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_extension_code501  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_extension_code501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_extension_code501	= { FOLLOW_DIGIT_in_extension_code501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_extension_code503  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_extension_code503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_extension_code503	= { FOLLOW_DIGIT_in_extension_code503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_extension_code505  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_extension_code505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_extension_code505	= { FOLLOW_DIGIT_in_extension_code505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_reason_phrase518  */
static	ANTLR3_BITWORD FOLLOW_set_in_reason_phrase518_bits[]	= { ANTLR3_UINT64_LIT(0x000007FFFFFFFFE2) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_reason_phrase518	= { FOLLOW_set_in_reason_phrase518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_generic_param561  */
static	ANTLR3_BITWORD FOLLOW_token_in_generic_param561_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001022) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_generic_param561	= { FOLLOW_token_in_generic_param561_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_generic_param566  */
static	ANTLR3_BITWORD FOLLOW_equal_in_generic_param566_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_generic_param566	= { FOLLOW_equal_in_generic_param566_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gen_value_in_generic_param568  */
static	ANTLR3_BITWORD FOLLOW_gen_value_in_generic_param568_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gen_value_in_generic_param568	= { FOLLOW_gen_value_in_generic_param568_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_gen_value591  */
static	ANTLR3_BITWORD FOLLOW_token_in_gen_value591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_gen_value591	= { FOLLOW_token_in_gen_value591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_gen_value596  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_gen_value596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_gen_value596	= { FOLLOW_quoted_string_in_gen_value596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_quoted_string617  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_quoted_string617_bits[]	= { ANTLR3_UINT64_LIT(0x000007FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_quoted_string617	= { FOLLOW_DQUOTE_in_quoted_string617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_quoted_string626  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_quoted_string626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_quoted_string626	= { FOLLOW_DQUOTE_in_quoted_string626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_allow666  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_allow666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_allow666	= { FOLLOW_token_in_header_allow666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_allow670  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_allow670_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338160) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_allow670	= { FOLLOW_hcolon_in_header_allow670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_methods_in_header_allow672  */
static	ANTLR3_BITWORD FOLLOW_methods_in_header_allow672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_methods_in_header_allow672	= { FOLLOW_methods_in_header_allow672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_methods688  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_methods688_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338160) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_methods688	= { FOLLOW_LWS_in_methods688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_methods691  */
static	ANTLR3_BITWORD FOLLOW_method_in_methods691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_methods691	= { FOLLOW_method_in_methods691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_methods694  */
static	ANTLR3_BITWORD FOLLOW_comma_in_methods694_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338160) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_methods694	= { FOLLOW_comma_in_methods694_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_methods696  */
static	ANTLR3_BITWORD FOLLOW_method_in_methods696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_methods696	= { FOLLOW_method_in_methods696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_authorization_token706  */
static	ANTLR3_BITWORD FOLLOW_token_in_authorization_token706_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_authorization_token706	= { FOLLOW_token_in_authorization_token706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_digest_token714  */
static	ANTLR3_BITWORD FOLLOW_token_in_digest_token714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_digest_token714	= { FOLLOW_token_in_digest_token714_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authorization_token_in_header_authorization745  */
static	ANTLR3_BITWORD FOLLOW_authorization_token_in_header_authorization745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_authorization_token_in_header_authorization745	= { FOLLOW_authorization_token_in_header_authorization745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_authorization749  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_authorization749_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_authorization749	= { FOLLOW_hcolon_in_header_authorization749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_credentials_in_header_authorization751  */
static	ANTLR3_BITWORD FOLLOW_credentials_in_header_authorization751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_credentials_in_header_authorization751	= { FOLLOW_credentials_in_header_authorization751_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_token_in_credentials778  */
static	ANTLR3_BITWORD FOLLOW_digest_token_in_credentials778_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_token_in_credentials778	= { FOLLOW_digest_token_in_credentials778_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_credentials789  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_credentials789_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_credentials789	= { FOLLOW_LWS_in_credentials789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_response_in_credentials791  */
static	ANTLR3_BITWORD FOLLOW_digest_response_in_credentials791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_response_in_credentials791	= { FOLLOW_digest_response_in_credentials791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_response_in_credentials818  */
static	ANTLR3_BITWORD FOLLOW_other_response_in_credentials818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_response_in_credentials818	= { FOLLOW_other_response_in_credentials818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dig_resp_in_digest_response834  */
static	ANTLR3_BITWORD FOLLOW_dig_resp_in_digest_response834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_dig_resp_in_digest_response834	= { FOLLOW_dig_resp_in_digest_response834_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_digest_response838  */
static	ANTLR3_BITWORD FOLLOW_comma_in_digest_response838_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_digest_response838	= { FOLLOW_comma_in_digest_response838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dig_resp_in_digest_response840  */
static	ANTLR3_BITWORD FOLLOW_dig_resp_in_digest_response840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_dig_resp_in_digest_response840	= { FOLLOW_dig_resp_in_digest_response840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_username_in_dig_resp865  */
static	ANTLR3_BITWORD FOLLOW_username_in_dig_resp865_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_username_in_dig_resp865	= { FOLLOW_username_in_dig_resp865_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_realm_in_dig_resp872  */
static	ANTLR3_BITWORD FOLLOW_realm_in_dig_resp872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_realm_in_dig_resp872	= { FOLLOW_realm_in_dig_resp872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_in_dig_resp880  */
static	ANTLR3_BITWORD FOLLOW_nonce_in_dig_resp880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_in_dig_resp880	= { FOLLOW_nonce_in_dig_resp880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_uri_in_dig_resp887  */
static	ANTLR3_BITWORD FOLLOW_digest_uri_in_dig_resp887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_uri_in_dig_resp887	= { FOLLOW_digest_uri_in_dig_resp887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dresponse_in_dig_resp894  */
static	ANTLR3_BITWORD FOLLOW_dresponse_in_dig_resp894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dresponse_in_dig_resp894	= { FOLLOW_dresponse_in_dig_resp894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_algorithm_in_dig_resp903  */
static	ANTLR3_BITWORD FOLLOW_algorithm_in_dig_resp903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_algorithm_in_dig_resp903	= { FOLLOW_algorithm_in_dig_resp903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnonce_in_dig_resp913  */
static	ANTLR3_BITWORD FOLLOW_cnonce_in_dig_resp913_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cnonce_in_dig_resp913	= { FOLLOW_cnonce_in_dig_resp913_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_opaque_in_dig_resp920  */
static	ANTLR3_BITWORD FOLLOW_opaque_in_dig_resp920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_opaque_in_dig_resp920	= { FOLLOW_opaque_in_dig_resp920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_qop_in_dig_resp928  */
static	ANTLR3_BITWORD FOLLOW_message_qop_in_dig_resp928_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_message_qop_in_dig_resp928	= { FOLLOW_message_qop_in_dig_resp928_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_count_in_dig_resp935  */
static	ANTLR3_BITWORD FOLLOW_nonce_count_in_dig_resp935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_count_in_dig_resp935	= { FOLLOW_nonce_count_in_dig_resp935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_dig_resp943  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_dig_resp943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_dig_resp943	= { FOLLOW_auth_param_in_dig_resp943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_username_token956  */
static	ANTLR3_BITWORD FOLLOW_token_in_username_token956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_username_token956	= { FOLLOW_token_in_username_token956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_username_token_in_username980  */
static	ANTLR3_BITWORD FOLLOW_username_token_in_username980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_username_token_in_username980	= { FOLLOW_username_token_in_username980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_username984  */
static	ANTLR3_BITWORD FOLLOW_equal_in_username984_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_username984	= { FOLLOW_equal_in_username984_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_username_value_in_username986  */
static	ANTLR3_BITWORD FOLLOW_username_value_in_username986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_username_value_in_username986	= { FOLLOW_username_value_in_username986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_username_value1000  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_username_value1000_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_username_value1000	= { FOLLOW_quoted_string_in_username_value1000_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_uri_token1009  */
static	ANTLR3_BITWORD FOLLOW_token_in_uri_token1009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_uri_token1009	= { FOLLOW_token_in_uri_token1009_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_token_in_digest_uri1029  */
static	ANTLR3_BITWORD FOLLOW_uri_token_in_digest_uri1029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_token_in_digest_uri1029	= { FOLLOW_uri_token_in_digest_uri1029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_digest_uri1033  */
static	ANTLR3_BITWORD FOLLOW_equal_in_digest_uri1033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_digest_uri1033	= { FOLLOW_equal_in_digest_uri1033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_digest_uri1035  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_digest_uri1035_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_digest_uri1035	= { FOLLOW_DQUOTE_in_digest_uri1035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_in_digest_uri1037  */
static	ANTLR3_BITWORD FOLLOW_uri_in_digest_uri1037_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_in_digest_uri1037	= { FOLLOW_uri_in_digest_uri1037_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_digest_uri1039  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_digest_uri1039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_digest_uri1039	= { FOLLOW_DQUOTE_in_digest_uri1039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_message_qop1070  */
static	ANTLR3_BITWORD FOLLOW_token_in_message_qop1070_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_message_qop1070	= { FOLLOW_token_in_message_qop1070_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_message_qop1073  */
static	ANTLR3_BITWORD FOLLOW_equal_in_message_qop1073_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_message_qop1073	= { FOLLOW_equal_in_message_qop1073_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qop_value_in_message_qop1076  */
static	ANTLR3_BITWORD FOLLOW_qop_value_in_message_qop1076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qop_value_in_message_qop1076	= { FOLLOW_qop_value_in_message_qop1076_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_qop_value1088  */
static	ANTLR3_BITWORD FOLLOW_token_in_qop_value1088_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_qop_value1088	= { FOLLOW_token_in_qop_value1088_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_cnonce1117  */
static	ANTLR3_BITWORD FOLLOW_token_in_cnonce1117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_cnonce1117	= { FOLLOW_token_in_cnonce1117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_cnonce1121  */
static	ANTLR3_BITWORD FOLLOW_equal_in_cnonce1121_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_cnonce1121	= { FOLLOW_equal_in_cnonce1121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnonce_value_in_cnonce1123  */
static	ANTLR3_BITWORD FOLLOW_cnonce_value_in_cnonce1123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cnonce_value_in_cnonce1123	= { FOLLOW_cnonce_value_in_cnonce1123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_value_in_cnonce_value1141  */
static	ANTLR3_BITWORD FOLLOW_nonce_value_in_cnonce_value1141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_value_in_cnonce_value1141	= { FOLLOW_nonce_value_in_cnonce_value1141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_nonce_count1164  */
static	ANTLR3_BITWORD FOLLOW_token_in_nonce_count1164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_nonce_count1164	= { FOLLOW_token_in_nonce_count1164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_nonce_count1168  */
static	ANTLR3_BITWORD FOLLOW_equal_in_nonce_count1168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010040) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_nonce_count1168	= { FOLLOW_equal_in_nonce_count1168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nc_value_in_nonce_count1170  */
static	ANTLR3_BITWORD FOLLOW_nc_value_in_nonce_count1170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nc_value_in_nonce_count1170	= { FOLLOW_nc_value_in_nonce_count1170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_huit_lhex_in_nc_value1192  */
static	ANTLR3_BITWORD FOLLOW_huit_lhex_in_nc_value1192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_huit_lhex_in_nc_value1192	= { FOLLOW_huit_lhex_in_nc_value1192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_dresponse1217  */
static	ANTLR3_BITWORD FOLLOW_token_in_dresponse1217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_dresponse1217	= { FOLLOW_token_in_dresponse1217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_dresponse1221  */
static	ANTLR3_BITWORD FOLLOW_equal_in_dresponse1221_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_dresponse1221	= { FOLLOW_equal_in_dresponse1221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_request_digest_in_dresponse1223  */
static	ANTLR3_BITWORD FOLLOW_request_digest_in_dresponse1223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_request_digest_in_dresponse1223	= { FOLLOW_request_digest_in_dresponse1223_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_request_digest1238  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_request_digest1238_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_request_digest1238	= { FOLLOW_quoted_string_in_request_digest1238_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_huit_lhex1248  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_huit_lhex1248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010042) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_huit_lhex1248	= { FOLLOW_hexdigit_in_huit_lhex1248_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_name_in_auth_param1270  */
static	ANTLR3_BITWORD FOLLOW_auth_param_name_in_auth_param1270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_name_in_auth_param1270	= { FOLLOW_auth_param_name_in_auth_param1270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_auth_param1272  */
static	ANTLR3_BITWORD FOLLOW_equal_in_auth_param1272_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_auth_param1272	= { FOLLOW_equal_in_auth_param1272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_value_in_auth_param1295  */
static	ANTLR3_BITWORD FOLLOW_auth_param_value_in_auth_param1295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_value_in_auth_param1295	= { FOLLOW_auth_param_value_in_auth_param1295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_auth_param_value1315  */
static	ANTLR3_BITWORD FOLLOW_token_in_auth_param_value1315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_auth_param_value1315	= { FOLLOW_token_in_auth_param_value1315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_auth_param_value1319  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_auth_param_value1319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_auth_param_value1319	= { FOLLOW_quoted_string_in_auth_param_value1319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_auth_param_name1343  */
static	ANTLR3_BITWORD FOLLOW_token_in_auth_param_name1343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_auth_param_name1343	= { FOLLOW_token_in_auth_param_name1343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_scheme_in_other_response1359  */
static	ANTLR3_BITWORD FOLLOW_auth_scheme_in_other_response1359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_scheme_in_other_response1359	= { FOLLOW_auth_scheme_in_other_response1359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_other_response1368  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_other_response1368_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_other_response1368	= { FOLLOW_LWS_in_other_response1368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_other_response1370  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_other_response1370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_other_response1370	= { FOLLOW_auth_param_in_other_response1370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_other_response1395  */
static	ANTLR3_BITWORD FOLLOW_comma_in_other_response1395_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_other_response1395	= { FOLLOW_comma_in_other_response1395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_other_response1397  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_other_response1397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_other_response1397	= { FOLLOW_auth_param_in_other_response1397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_auth_scheme1418  */
static	ANTLR3_BITWORD FOLLOW_token_in_auth_scheme1418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_auth_scheme1418	= { FOLLOW_token_in_auth_scheme1418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_nonce_value1436  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_nonce_value1436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_nonce_value1436	= { FOLLOW_quoted_string_in_nonce_value1436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_call_id_token1448  */
static	ANTLR3_BITWORD FOLLOW_token_in_call_id_token1448_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_call_id_token1448	= { FOLLOW_token_in_call_id_token1448_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_id_token_in_header_call_id1478  */
static	ANTLR3_BITWORD FOLLOW_call_id_token_in_header_call_id1478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_call_id_token_in_header_call_id1478	= { FOLLOW_call_id_token_in_header_call_id1478_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_call_id1482  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_call_id1482_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_call_id1482	= { FOLLOW_hcolon_in_header_call_id1482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_id_in_header_call_id1484  */
static	ANTLR3_BITWORD FOLLOW_call_id_in_header_call_id1484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_call_id_in_header_call_id1484	= { FOLLOW_call_id_in_header_call_id1484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_call_id1506  */
static	ANTLR3_BITWORD FOLLOW_word_in_call_id1506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_call_id1506	= { FOLLOW_word_in_call_id1506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_24_in_call_id1510  */
static	ANTLR3_BITWORD FOLLOW_24_in_call_id1510_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C0) };
static  ANTLR3_BITSET_LIST FOLLOW_24_in_call_id1510	= { FOLLOW_24_in_call_id1510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_call_id1512  */
static	ANTLR3_BITWORD FOLLOW_word_in_call_id1512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_call_id1512	= { FOLLOW_word_in_call_id1512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_contact_token1528  */
static	ANTLR3_BITWORD FOLLOW_token_in_contact_token1528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_contact_token1528	= { FOLLOW_token_in_contact_token1528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_token_in_header_contact1561  */
static	ANTLR3_BITWORD FOLLOW_contact_token_in_header_contact1561_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_token_in_header_contact1561	= { FOLLOW_contact_token_in_header_contact1561_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_contact1569  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_contact1569_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_contact1569	= { FOLLOW_hcolon_in_header_contact1569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STAR_in_header_contact1591  */
static	ANTLR3_BITWORD FOLLOW_STAR_in_header_contact1591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STAR_in_header_contact1591	= { FOLLOW_STAR_in_header_contact1591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_param_in_header_contact1617  */
static	ANTLR3_BITWORD FOLLOW_contact_param_in_header_contact1617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_param_in_header_contact1617	= { FOLLOW_contact_param_in_header_contact1617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_header_contact1620  */
static	ANTLR3_BITWORD FOLLOW_comma_in_header_contact1620_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_header_contact1620	= { FOLLOW_comma_in_header_contact1620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_param_in_header_contact1622  */
static	ANTLR3_BITWORD FOLLOW_contact_param_in_header_contact1622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_param_in_header_contact1622	= { FOLLOW_contact_param_in_header_contact1622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_contact_param1675  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_contact_param1675_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_contact_param1675	= { FOLLOW_name_addr_in_contact_param1675_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_addr_spec_in_contact_param1685  */
static	ANTLR3_BITWORD FOLLOW_paramless_addr_spec_in_contact_param1685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_addr_spec_in_contact_param1685	= { FOLLOW_paramless_addr_spec_in_contact_param1685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_contact_param1690  */
static	ANTLR3_BITWORD FOLLOW_semi_in_contact_param1690_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_contact_param1690	= { FOLLOW_semi_in_contact_param1690_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_params_in_contact_param1692  */
static	ANTLR3_BITWORD FOLLOW_contact_params_in_contact_param1692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_params_in_contact_param1692	= { FOLLOW_contact_params_in_contact_param1692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_address_base_in_header_address1723  */
static	ANTLR3_BITWORD FOLLOW_header_address_base_in_header_address1723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_address_base_in_header_address1723	= { FOLLOW_header_address_base_in_header_address1723_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_header_address_base1757  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_header_address_base1757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_header_address_base1757	= { FOLLOW_name_addr_in_header_address_base1757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addr_spec_in_header_address_base1767  */
static	ANTLR3_BITWORD FOLLOW_addr_spec_in_header_address_base1767_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addr_spec_in_header_address_base1767	= { FOLLOW_addr_spec_in_header_address_base1767_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_display_name_in_name_addr1798  */
static	ANTLR3_BITWORD FOLLOW_display_name_in_name_addr1798_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_display_name_in_name_addr1798	= { FOLLOW_display_name_in_name_addr1798_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_laquot_sp_in_name_addr1804  */
static	ANTLR3_BITWORD FOLLOW_sp_laquot_sp_in_name_addr1804_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_laquot_sp_in_name_addr1804	= { FOLLOW_sp_laquot_sp_in_name_addr1804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addr_spec_in_name_addr1806  */
static	ANTLR3_BITWORD FOLLOW_addr_spec_in_name_addr1806_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080020) };
static  ANTLR3_BITSET_LIST FOLLOW_addr_spec_in_name_addr1806	= { FOLLOW_addr_spec_in_name_addr1806_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_raquot_sp_in_name_addr1809  */
static	ANTLR3_BITWORD FOLLOW_sp_raquot_sp_in_name_addr1809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_raquot_sp_in_name_addr1809	= { FOLLOW_sp_raquot_sp_in_name_addr1809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_in_addr_spec1826  */
static	ANTLR3_BITWORD FOLLOW_uri_in_addr_spec1826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_in_addr_spec1826	= { FOLLOW_uri_in_addr_spec1826_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_uri_in_paramless_addr_spec1846  */
static	ANTLR3_BITWORD FOLLOW_paramless_uri_in_paramless_addr_spec1846_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_uri_in_paramless_addr_spec1846	= { FOLLOW_paramless_uri_in_paramless_addr_spec1846_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_display_name1864  */
static	ANTLR3_BITWORD FOLLOW_token_in_display_name1864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_display_name1864	= { FOLLOW_token_in_display_name1864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_display_name1875  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_display_name1875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_display_name1875	= { FOLLOW_quoted_string_in_display_name1875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_extension_in_contact_params1901  */
static	ANTLR3_BITWORD FOLLOW_contact_extension_in_contact_params1901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_extension_in_contact_params1901	= { FOLLOW_contact_extension_in_contact_params1901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_contact_extension1915  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_contact_extension1915_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_contact_extension1915	= { FOLLOW_generic_param_in_contact_extension1915_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_delta_seconds1934  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_delta_seconds1934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_delta_seconds1934	= { FOLLOW_DIGIT_in_delta_seconds1934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_content_length_token1949  */
static	ANTLR3_BITWORD FOLLOW_token_in_content_length_token1949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_content_length_token1949	= { FOLLOW_token_in_content_length_token1949_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_content_length_token_in_header_content_length1977  */
static	ANTLR3_BITWORD FOLLOW_content_length_token_in_header_content_length1977_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_content_length_token_in_header_content_length1977	= { FOLLOW_content_length_token_in_header_content_length1977_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_content_length1986  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_content_length1986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_content_length1986	= { FOLLOW_hcolon_in_header_content_length1986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_content_length_in_header_content_length1993  */
static	ANTLR3_BITWORD FOLLOW_content_length_in_header_content_length1993_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_content_length_in_header_content_length1993	= { FOLLOW_content_length_in_header_content_length1993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_content_length2006  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_content_length2006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_content_length2006	= { FOLLOW_DIGIT_in_content_length2006_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_content_type_token2019  */
static	ANTLR3_BITWORD FOLLOW_token_in_content_type_token2019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_content_type_token2019	= { FOLLOW_token_in_content_type_token2019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_content_type_token_in_header_content_type2045  */
static	ANTLR3_BITWORD FOLLOW_content_type_token_in_header_content_type2045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_content_type_token_in_header_content_type2045	= { FOLLOW_content_type_token_in_header_content_type2045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_content_type2048  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_content_type2048_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_content_type2048	= { FOLLOW_hcolon_in_header_content_type2048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_media_type_in_header_content_type2050  */
static	ANTLR3_BITWORD FOLLOW_media_type_in_header_content_type2050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_media_type_in_header_content_type2050	= { FOLLOW_media_type_in_header_content_type2050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_m_type_in_media_type2074  */
static	ANTLR3_BITWORD FOLLOW_m_type_in_media_type2074_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000820) };
static  ANTLR3_BITSET_LIST FOLLOW_m_type_in_media_type2074	= { FOLLOW_m_type_in_media_type2074_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_slash_in_media_type2083  */
static	ANTLR3_BITWORD FOLLOW_slash_in_media_type2083_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_slash_in_media_type2083	= { FOLLOW_slash_in_media_type2083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_m_subtype_in_media_type2090  */
static	ANTLR3_BITWORD FOLLOW_m_subtype_in_media_type2090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_m_subtype_in_media_type2090	= { FOLLOW_m_subtype_in_media_type2090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_media_type2100  */
static	ANTLR3_BITWORD FOLLOW_semi_in_media_type2100_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_media_type2100	= { FOLLOW_semi_in_media_type2100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_media_type2103  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_media_type2103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_media_type2103	= { FOLLOW_generic_param_in_media_type2103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_m_type2126  */
static	ANTLR3_BITWORD FOLLOW_token_in_m_type2126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_m_type2126	= { FOLLOW_token_in_m_type2126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_m_subtype2142  */
static	ANTLR3_BITWORD FOLLOW_token_in_m_subtype2142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_m_subtype2142	= { FOLLOW_token_in_m_subtype2142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_cseq_token2155  */
static	ANTLR3_BITWORD FOLLOW_token_in_cseq_token2155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_cseq_token2155	= { FOLLOW_token_in_cseq_token2155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cseq_token_in_header_cseq2181  */
static	ANTLR3_BITWORD FOLLOW_cseq_token_in_header_cseq2181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_cseq_token_in_header_cseq2181	= { FOLLOW_cseq_token_in_header_cseq2181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_cseq2187  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_cseq2187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_cseq2187	= { FOLLOW_hcolon_in_header_cseq2187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_seq_number_in_header_cseq2194  */
static	ANTLR3_BITWORD FOLLOW_seq_number_in_header_cseq2194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_seq_number_in_header_cseq2194	= { FOLLOW_seq_number_in_header_cseq2194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_header_cseq2203  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_header_cseq2203_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338160) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_header_cseq2203	= { FOLLOW_LWS_in_header_cseq2203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_header_cseq2210  */
static	ANTLR3_BITWORD FOLLOW_method_in_header_cseq2210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_header_cseq2210	= { FOLLOW_method_in_header_cseq2210_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_seq_number2229  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_seq_number2229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_seq_number2229	= { FOLLOW_DIGIT_in_seq_number2229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_date_token2241  */
static	ANTLR3_BITWORD FOLLOW_token_in_date_token2241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_date_token2241	= { FOLLOW_token_in_date_token2241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_date_token_in_header_date2271  */
static	ANTLR3_BITWORD FOLLOW_date_token_in_header_date2271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_date_token_in_header_date2271	= { FOLLOW_date_token_in_header_date2271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_date2275  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_date2275_bits[]	= { ANTLR3_UINT64_LIT(0x000007FFFFFFFFE0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_date2275	= { FOLLOW_hcolon_in_header_date2275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_date_in_header_date2277  */
static	ANTLR3_BITWORD FOLLOW_sip_date_in_header_date2277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_date_in_header_date2277	= { FOLLOW_sip_date_in_header_date2277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_date_in_date2293  */
static	ANTLR3_BITWORD FOLLOW_sip_date_in_date2293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_date_in_date2293	= { FOLLOW_sip_date_in_date2293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_sip_date2302  */
static	ANTLR3_BITWORD FOLLOW_set_in_sip_date2302_bits[]	= { ANTLR3_UINT64_LIT(0x000007FFFFFFFFE2) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_sip_date2302	= { FOLLOW_set_in_sip_date2302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_expires2346  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_expires2346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_expires2346	= { FOLLOW_token_in_header_expires2346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_expires2350  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_expires2350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_expires2350	= { FOLLOW_hcolon_in_header_expires2350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_delta_seconds_in_header_expires2352  */
static	ANTLR3_BITWORD FOLLOW_delta_seconds_in_header_expires2352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_delta_seconds_in_header_expires2352	= { FOLLOW_delta_seconds_in_header_expires2352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_from_token2373  */
static	ANTLR3_BITWORD FOLLOW_token_in_from_token2373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_from_token2373	= { FOLLOW_token_in_from_token2373_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_token_in_header_from2409  */
static	ANTLR3_BITWORD FOLLOW_from_token_in_header_from2409_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_from_token_in_header_from2409	= { FOLLOW_from_token_in_header_from2409_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_from2412  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_from2412_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_from2412	= { FOLLOW_hcolon_in_header_from2412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_spec_in_header_from2414  */
static	ANTLR3_BITWORD FOLLOW_from_spec_in_header_from2414_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_from_spec_in_header_from2414	= { FOLLOW_from_spec_in_header_from2414_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_from_spec2439  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_from_spec2439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_from_spec2439	= { FOLLOW_name_addr_in_from_spec2439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_addr_spec_in_from_spec2444  */
static	ANTLR3_BITWORD FOLLOW_paramless_addr_spec_in_from_spec2444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_addr_spec_in_from_spec2444	= { FOLLOW_paramless_addr_spec_in_from_spec2444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_from_spec2466  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_from_spec2466_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_from_spec2466	= { FOLLOW_SEMI_in_from_spec2466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_param_in_from_spec2468  */
static	ANTLR3_BITWORD FOLLOW_from_param_in_from_spec2468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_from_param_in_from_spec2468	= { FOLLOW_from_param_in_from_spec2468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_from_param2485  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_from_param2485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_from_param2485	= { FOLLOW_generic_param_in_from_param2485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_max_forwards2546  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_max_forwards2546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_max_forwards2546	= { FOLLOW_token_in_header_max_forwards2546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_max_forwards2550  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_max_forwards2550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_max_forwards2550	= { FOLLOW_hcolon_in_header_max_forwards2550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_max_forwards_in_header_max_forwards2557  */
static	ANTLR3_BITWORD FOLLOW_max_forwards_in_header_max_forwards2557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_max_forwards_in_header_max_forwards2557	= { FOLLOW_max_forwards_in_header_max_forwards2557_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_max_forwards2571  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_max_forwards2571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_max_forwards2571	= { FOLLOW_DIGIT_in_max_forwards2571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_proxy_authenticate2605  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_proxy_authenticate2605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_proxy_authenticate2605	= { FOLLOW_token_in_header_proxy_authenticate2605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_proxy_authenticate2611  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_proxy_authenticate2611_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_proxy_authenticate2611	= { FOLLOW_hcolon_in_header_proxy_authenticate2611_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_challenge_in_header_proxy_authenticate2613  */
static	ANTLR3_BITWORD FOLLOW_challenge_in_header_proxy_authenticate2613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_challenge_in_header_proxy_authenticate2613	= { FOLLOW_challenge_in_header_proxy_authenticate2613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_challenge2648  */
static	ANTLR3_BITWORD FOLLOW_token_in_challenge2648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_challenge2648	= { FOLLOW_token_in_challenge2648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_challenge2659  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_challenge2659_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338560) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_challenge2659	= { FOLLOW_LWS_in_challenge2659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_cln_in_challenge2661  */
static	ANTLR3_BITWORD FOLLOW_digest_cln_in_challenge2661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_cln_in_challenge2661	= { FOLLOW_digest_cln_in_challenge2661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_challenge2665  */
static	ANTLR3_BITWORD FOLLOW_comma_in_challenge2665_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338560) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_challenge2665	= { FOLLOW_comma_in_challenge2665_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_cln_in_challenge2667  */
static	ANTLR3_BITWORD FOLLOW_digest_cln_in_challenge2667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_cln_in_challenge2667	= { FOLLOW_digest_cln_in_challenge2667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_challenge_in_challenge2698  */
static	ANTLR3_BITWORD FOLLOW_other_challenge_in_challenge2698_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_challenge_in_challenge2698	= { FOLLOW_other_challenge_in_challenge2698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_scheme_in_other_challenge2716  */
static	ANTLR3_BITWORD FOLLOW_auth_scheme_in_other_challenge2716_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_scheme_in_other_challenge2716	= { FOLLOW_auth_scheme_in_other_challenge2716_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_other_challenge2725  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_other_challenge2725_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_other_challenge2725	= { FOLLOW_LWS_in_other_challenge2725_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_other_challenge2727  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_other_challenge2727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_other_challenge2727	= { FOLLOW_auth_param_in_other_challenge2727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_other_challenge2754  */
static	ANTLR3_BITWORD FOLLOW_comma_in_other_challenge2754_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_other_challenge2754	= { FOLLOW_comma_in_other_challenge2754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_other_challenge2756  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_other_challenge2756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_other_challenge2756	= { FOLLOW_auth_param_in_other_challenge2756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_realm_in_digest_cln2783  */
static	ANTLR3_BITWORD FOLLOW_realm_in_digest_cln2783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_realm_in_digest_cln2783	= { FOLLOW_realm_in_digest_cln2783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_in_digest_cln2792  */
static	ANTLR3_BITWORD FOLLOW_nonce_in_digest_cln2792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_in_digest_cln2792	= { FOLLOW_nonce_in_digest_cln2792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_algorithm_in_digest_cln2800  */
static	ANTLR3_BITWORD FOLLOW_algorithm_in_digest_cln2800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_algorithm_in_digest_cln2800	= { FOLLOW_algorithm_in_digest_cln2800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_opaque_in_digest_cln2809  */
static	ANTLR3_BITWORD FOLLOW_opaque_in_digest_cln2809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_opaque_in_digest_cln2809	= { FOLLOW_opaque_in_digest_cln2809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qop_opts_in_digest_cln2818  */
static	ANTLR3_BITWORD FOLLOW_qop_opts_in_digest_cln2818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qop_opts_in_digest_cln2818	= { FOLLOW_qop_opts_in_digest_cln2818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_domain_in_digest_cln2825  */
static	ANTLR3_BITWORD FOLLOW_domain_in_digest_cln2825_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_domain_in_digest_cln2825	= { FOLLOW_domain_in_digest_cln2825_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stale_in_digest_cln2833  */
static	ANTLR3_BITWORD FOLLOW_stale_in_digest_cln2833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stale_in_digest_cln2833	= { FOLLOW_stale_in_digest_cln2833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_digest_cln2844  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_digest_cln2844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_digest_cln2844	= { FOLLOW_auth_param_in_digest_cln2844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_realm2878  */
static	ANTLR3_BITWORD FOLLOW_token_in_realm2878_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_realm2878	= { FOLLOW_token_in_realm2878_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_realm2882  */
static	ANTLR3_BITWORD FOLLOW_equal_in_realm2882_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_realm2882	= { FOLLOW_equal_in_realm2882_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_realm_value_in_realm2884  */
static	ANTLR3_BITWORD FOLLOW_realm_value_in_realm2884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_realm_value_in_realm2884	= { FOLLOW_realm_value_in_realm2884_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_realm_value2905  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_realm_value2905_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_realm_value2905	= { FOLLOW_quoted_string_in_realm_value2905_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_domain2937  */
static	ANTLR3_BITWORD FOLLOW_token_in_domain2937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_domain2937	= { FOLLOW_token_in_domain2937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_domain2941  */
static	ANTLR3_BITWORD FOLLOW_equal_in_domain2941_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_domain2941	= { FOLLOW_equal_in_domain2941_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_domain2943  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_domain2943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_domain2943	= { FOLLOW_quoted_string_in_domain2943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_nonce2978  */
static	ANTLR3_BITWORD FOLLOW_token_in_nonce2978_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_nonce2978	= { FOLLOW_token_in_nonce2978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_nonce2982  */
static	ANTLR3_BITWORD FOLLOW_equal_in_nonce2982_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_nonce2982	= { FOLLOW_equal_in_nonce2982_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_value_in_nonce2984  */
static	ANTLR3_BITWORD FOLLOW_nonce_value_in_nonce2984_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_value_in_nonce2984	= { FOLLOW_nonce_value_in_nonce2984_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_opaque3015  */
static	ANTLR3_BITWORD FOLLOW_token_in_opaque3015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_opaque3015	= { FOLLOW_token_in_opaque3015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_opaque3019  */
static	ANTLR3_BITWORD FOLLOW_equal_in_opaque3019_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303381C0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_opaque3019	= { FOLLOW_equal_in_opaque3019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_opaque3021  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_opaque3021_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_opaque3021	= { FOLLOW_quoted_string_in_opaque3021_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_stale3053  */
static	ANTLR3_BITWORD FOLLOW_token_in_stale3053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_stale3053	= { FOLLOW_token_in_stale3053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_stale3057  */
static	ANTLR3_BITWORD FOLLOW_equal_in_stale3057_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_stale3057	= { FOLLOW_equal_in_stale3057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stale_value_in_stale3059  */
static	ANTLR3_BITWORD FOLLOW_stale_value_in_stale3059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stale_value_in_stale3059	= { FOLLOW_stale_value_in_stale3059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_stale_value3069  */
static	ANTLR3_BITWORD FOLLOW_token_in_stale_value3069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_stale_value3069	= { FOLLOW_token_in_stale_value3069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_algorithm3097  */
static	ANTLR3_BITWORD FOLLOW_token_in_algorithm3097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_algorithm3097	= { FOLLOW_token_in_algorithm3097_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_algorithm3101  */
static	ANTLR3_BITWORD FOLLOW_equal_in_algorithm3101_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_algorithm3101	= { FOLLOW_equal_in_algorithm3101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_algorithm3107  */
static	ANTLR3_BITWORD FOLLOW_token_in_algorithm3107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_algorithm3107	= { FOLLOW_token_in_algorithm3107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_qop_opts3146  */
static	ANTLR3_BITWORD FOLLOW_token_in_qop_opts3146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_qop_opts3146	= { FOLLOW_token_in_qop_opts3146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_qop_opts3150  */
static	ANTLR3_BITWORD FOLLOW_equal_in_qop_opts3150_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000000A0) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_qop_opts3150	= { FOLLOW_equal_in_qop_opts3150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ldquot_in_qop_opts3154  */
static	ANTLR3_BITWORD FOLLOW_ldquot_in_qop_opts3154_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_ldquot_in_qop_opts3154	= { FOLLOW_ldquot_in_qop_opts3154_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qop_opts_value_in_qop_opts3158  */
static	ANTLR3_BITWORD FOLLOW_qop_opts_value_in_qop_opts3158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000480) };
static  ANTLR3_BITSET_LIST FOLLOW_qop_opts_value_in_qop_opts3158	= { FOLLOW_qop_opts_value_in_qop_opts3158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_qop_opts3164  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_qop_opts3164_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_qop_opts3164	= { FOLLOW_COMMA_in_qop_opts3164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qop_opts_value_in_qop_opts3166  */
static	ANTLR3_BITWORD FOLLOW_qop_opts_value_in_qop_opts3166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000480) };
static  ANTLR3_BITSET_LIST FOLLOW_qop_opts_value_in_qop_opts3166	= { FOLLOW_qop_opts_value_in_qop_opts3166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdquot_in_qop_opts3173  */
static	ANTLR3_BITWORD FOLLOW_rdquot_in_qop_opts3173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rdquot_in_qop_opts3173	= { FOLLOW_rdquot_in_qop_opts3173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_qop_opts_value3188  */
static	ANTLR3_BITWORD FOLLOW_token_in_qop_opts_value3188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_qop_opts_value3188	= { FOLLOW_token_in_qop_opts_value3188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_proxy_authorization3217  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_proxy_authorization3217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_proxy_authorization3217	= { FOLLOW_token_in_header_proxy_authorization3217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_proxy_authorization3221  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_proxy_authorization3221_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_proxy_authorization3221	= { FOLLOW_hcolon_in_header_proxy_authorization3221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_credentials_in_header_proxy_authorization3223  */
static	ANTLR3_BITWORD FOLLOW_credentials_in_header_proxy_authorization3223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_credentials_in_header_proxy_authorization3223	= { FOLLOW_credentials_in_header_proxy_authorization3223_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_service_route_token3244  */
static	ANTLR3_BITWORD FOLLOW_token_in_service_route_token3244_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_service_route_token3244	= { FOLLOW_token_in_service_route_token3244_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_service_route_token_in_header_service_route3272  */
static	ANTLR3_BITWORD FOLLOW_service_route_token_in_header_service_route3272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_service_route_token_in_header_service_route3272	= { FOLLOW_service_route_token_in_header_service_route3272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_service_route3276  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_service_route3276_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_service_route3276	= { FOLLOW_hcolon_in_header_service_route3276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_srv_route_in_header_service_route3278  */
static	ANTLR3_BITWORD FOLLOW_srv_route_in_header_service_route3278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_srv_route_in_header_service_route3278	= { FOLLOW_srv_route_in_header_service_route3278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_header_service_route3281  */
static	ANTLR3_BITWORD FOLLOW_comma_in_header_service_route3281_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_header_service_route3281	= { FOLLOW_comma_in_header_service_route3281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_srv_route_in_header_service_route3283  */
static	ANTLR3_BITWORD FOLLOW_srv_route_in_header_service_route3283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_srv_route_in_header_service_route3283	= { FOLLOW_srv_route_in_header_service_route3283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_srv_route3318  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_srv_route3318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_srv_route3318	= { FOLLOW_name_addr_in_srv_route3318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_srv_route3323  */
static	ANTLR3_BITWORD FOLLOW_semi_in_srv_route3323_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_srv_route3323	= { FOLLOW_semi_in_srv_route3323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sr_param_in_srv_route3325  */
static	ANTLR3_BITWORD FOLLOW_sr_param_in_srv_route3325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_sr_param_in_srv_route3325	= { FOLLOW_sr_param_in_srv_route3325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_sr_param3354  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_sr_param3354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_sr_param3354	= { FOLLOW_generic_param_in_sr_param3354_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_record_route_token3367  */
static	ANTLR3_BITWORD FOLLOW_token_in_record_route_token3367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_record_route_token3367	= { FOLLOW_token_in_record_route_token3367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_record_route_token_in_header_record_route3394  */
static	ANTLR3_BITWORD FOLLOW_record_route_token_in_header_record_route3394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_record_route_token_in_header_record_route3394	= { FOLLOW_record_route_token_in_header_record_route3394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_record_route3398  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_record_route3398_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_record_route3398	= { FOLLOW_hcolon_in_header_record_route3398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rec_route_in_header_record_route3400  */
static	ANTLR3_BITWORD FOLLOW_rec_route_in_header_record_route3400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_rec_route_in_header_record_route3400	= { FOLLOW_rec_route_in_header_record_route3400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_header_record_route3403  */
static	ANTLR3_BITWORD FOLLOW_comma_in_header_record_route3403_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_header_record_route3403	= { FOLLOW_comma_in_header_record_route3403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rec_route_in_header_record_route3405  */
static	ANTLR3_BITWORD FOLLOW_rec_route_in_header_record_route3405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_rec_route_in_header_record_route3405	= { FOLLOW_rec_route_in_header_record_route3405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_rec_route3439  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_rec_route3439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_rec_route3439	= { FOLLOW_name_addr_in_rec_route3439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_rec_route3444  */
static	ANTLR3_BITWORD FOLLOW_semi_in_rec_route3444_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_rec_route3444	= { FOLLOW_semi_in_rec_route3444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rr_param_in_rec_route3446  */
static	ANTLR3_BITWORD FOLLOW_rr_param_in_rec_route3446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_rr_param_in_rec_route3446	= { FOLLOW_rr_param_in_rec_route3446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_rr_param3473  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_rr_param3473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_rr_param3473	= { FOLLOW_generic_param_in_rr_param3473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_comment3483  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_comment3483_bits[]	= { ANTLR3_UINT64_LIT(0x000007FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_comment3483	= { FOLLOW_LPAREN_in_comment3483_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_comment3487  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_comment3487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_comment3487	= { FOLLOW_RPAREN_in_comment3487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_route_token3500  */
static	ANTLR3_BITWORD FOLLOW_token_in_route_token3500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_route_token3500	= { FOLLOW_token_in_route_token3500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_route_token_in_header_route3528  */
static	ANTLR3_BITWORD FOLLOW_route_token_in_header_route3528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_route_token_in_header_route3528	= { FOLLOW_route_token_in_header_route3528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_route3532  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_route3532_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_route3532	= { FOLLOW_hcolon_in_header_route3532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_route_param_in_header_route3534  */
static	ANTLR3_BITWORD FOLLOW_route_param_in_header_route3534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_route_param_in_header_route3534	= { FOLLOW_route_param_in_header_route3534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_header_route3537  */
static	ANTLR3_BITWORD FOLLOW_comma_in_header_route3537_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_header_route3537	= { FOLLOW_comma_in_header_route3537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_route_param_in_header_route3539  */
static	ANTLR3_BITWORD FOLLOW_route_param_in_header_route3539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_route_param_in_header_route3539	= { FOLLOW_route_param_in_header_route3539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_route_param3569  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_route_param3569_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_route_param3569	= { FOLLOW_name_addr_in_route_param3569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_route_param3574  */
static	ANTLR3_BITWORD FOLLOW_semi_in_route_param3574_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_route_param3574	= { FOLLOW_semi_in_route_param3574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_r_param_in_route_param3576  */
static	ANTLR3_BITWORD FOLLOW_r_param_in_route_param3576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_r_param_in_route_param3576	= { FOLLOW_r_param_in_route_param3576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_r_param3604  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_r_param3604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_r_param3604	= { FOLLOW_generic_param_in_r_param3604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_to_token3619  */
static	ANTLR3_BITWORD FOLLOW_token_in_to_token3619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_to_token3619	= { FOLLOW_token_in_to_token3619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_to_token_in_header_to3656  */
static	ANTLR3_BITWORD FOLLOW_to_token_in_header_to3656_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_to_token_in_header_to3656	= { FOLLOW_to_token_in_header_to3656_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_to3660  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_to3660_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_to3660	= { FOLLOW_hcolon_in_header_to3660_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_to_spec_in_header_to3662  */
static	ANTLR3_BITWORD FOLLOW_to_spec_in_header_to3662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_to_spec_in_header_to3662	= { FOLLOW_to_spec_in_header_to3662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_to_spec3686  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_to_spec3686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_to_spec3686	= { FOLLOW_name_addr_in_to_spec3686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_addr_spec_in_to_spec3691  */
static	ANTLR3_BITWORD FOLLOW_paramless_addr_spec_in_to_spec3691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_addr_spec_in_to_spec3691	= { FOLLOW_paramless_addr_spec_in_to_spec3691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_to_spec3713  */
static	ANTLR3_BITWORD FOLLOW_semi_in_to_spec3713_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_to_spec3713	= { FOLLOW_semi_in_to_spec3713_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_to_param_in_to_spec3715  */
static	ANTLR3_BITWORD FOLLOW_to_param_in_to_spec3715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_to_param_in_to_spec3715	= { FOLLOW_to_param_in_to_spec3715_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_to_param3733  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_to_param3733_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_to_param3733	= { FOLLOW_generic_param_in_to_param3733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_refer_to_token3745  */
static	ANTLR3_BITWORD FOLLOW_token_in_refer_to_token3745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_refer_to_token3745	= { FOLLOW_token_in_refer_to_token3745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_refer_to_token_in_header_refer_to3764  */
static	ANTLR3_BITWORD FOLLOW_refer_to_token_in_header_refer_to3764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_refer_to_token_in_header_refer_to3764	= { FOLLOW_refer_to_token_in_header_refer_to3764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_refer_to3775  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_refer_to3775_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_refer_to3775	= { FOLLOW_hcolon_in_header_refer_to3775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_refer_to_spec_in_header_refer_to3784  */
static	ANTLR3_BITWORD FOLLOW_refer_to_spec_in_header_refer_to3784_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_refer_to_spec_in_header_refer_to3784	= { FOLLOW_refer_to_spec_in_header_refer_to3784_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_referred_by_token3797  */
static	ANTLR3_BITWORD FOLLOW_token_in_referred_by_token3797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_referred_by_token3797	= { FOLLOW_token_in_referred_by_token3797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_referred_by_token_in_header_referred_by3816  */
static	ANTLR3_BITWORD FOLLOW_referred_by_token_in_header_referred_by3816_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_referred_by_token_in_header_referred_by3816	= { FOLLOW_referred_by_token_in_header_referred_by3816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_referred_by3827  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_referred_by3827_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_referred_by3827	= { FOLLOW_hcolon_in_header_referred_by3827_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_refer_to_spec_in_header_referred_by3836  */
static	ANTLR3_BITWORD FOLLOW_refer_to_spec_in_header_referred_by3836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_refer_to_spec_in_header_referred_by3836	= { FOLLOW_refer_to_spec_in_header_referred_by3836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_refer_to_spec3870  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_refer_to_spec3870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_refer_to_spec3870	= { FOLLOW_name_addr_in_refer_to_spec3870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_addr_spec_in_refer_to_spec3875  */
static	ANTLR3_BITWORD FOLLOW_paramless_addr_spec_in_refer_to_spec3875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_addr_spec_in_refer_to_spec3875	= { FOLLOW_paramless_addr_spec_in_refer_to_spec3875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_refer_to_spec3883  */
static	ANTLR3_BITWORD FOLLOW_semi_in_refer_to_spec3883_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_refer_to_spec3883	= { FOLLOW_semi_in_refer_to_spec3883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_refer_to_spec3885  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_refer_to_spec3885_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_refer_to_spec3885	= { FOLLOW_generic_param_in_refer_to_spec3885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_user_agent3936  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_user_agent3936_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_user_agent3936	= { FOLLOW_token_in_header_user_agent3936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_user_agent3940  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_user_agent3940_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_user_agent3940	= { FOLLOW_hcolon_in_header_user_agent3940_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_server_val_in_header_user_agent3942  */
static	ANTLR3_BITWORD FOLLOW_server_val_in_header_user_agent3942_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_server_val_in_header_user_agent3942	= { FOLLOW_server_val_in_header_user_agent3942_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_header_user_agent3945  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_header_user_agent3945_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C0) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_header_user_agent3945	= { FOLLOW_LWS_in_header_user_agent3945_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_server_val_in_header_user_agent3947  */
static	ANTLR3_BITWORD FOLLOW_server_val_in_header_user_agent3947_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_server_val_in_header_user_agent3947	= { FOLLOW_server_val_in_header_user_agent3947_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_server_val3967  */
static	ANTLR3_BITWORD FOLLOW_word_in_server_val3967_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_server_val3967	= { FOLLOW_word_in_server_val3967_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_product_in_serval_item3984  */
static	ANTLR3_BITWORD FOLLOW_product_in_serval_item3984_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_product_in_serval_item3984	= { FOLLOW_product_in_serval_item3984_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comment_in_serval_item3988  */
static	ANTLR3_BITWORD FOLLOW_comment_in_serval_item3988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comment_in_serval_item3988	= { FOLLOW_comment_in_serval_item3988_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_product4011  */
static	ANTLR3_BITWORD FOLLOW_token_in_product4011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_product4011	= { FOLLOW_token_in_product4011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_product4014  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_product4014_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_product4014	= { FOLLOW_SLASH_in_product4014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_product_version_in_product4016  */
static	ANTLR3_BITWORD FOLLOW_product_version_in_product4016_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_product_version_in_product4016	= { FOLLOW_product_version_in_product4016_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_product_version4031  */
static	ANTLR3_BITWORD FOLLOW_token_in_product_version4031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_product_version4031	= { FOLLOW_token_in_product_version4031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_via_token4043  */
static	ANTLR3_BITWORD FOLLOW_token_in_via_token4043_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_via_token4043	= { FOLLOW_token_in_via_token4043_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_token_in_header_via4080  */
static	ANTLR3_BITWORD FOLLOW_via_token_in_header_via4080_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_via_token_in_header_via4080	= { FOLLOW_via_token_in_header_via4080_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_via4083  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_via4083_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_via4083	= { FOLLOW_hcolon_in_header_via4083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_parm_in_header_via4085  */
static	ANTLR3_BITWORD FOLLOW_via_parm_in_header_via4085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_via_parm_in_header_via4085	= { FOLLOW_via_parm_in_header_via4085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_header_via4088  */
static	ANTLR3_BITWORD FOLLOW_comma_in_header_via4088_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_header_via4088	= { FOLLOW_comma_in_header_via4088_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_parm_in_header_via4090  */
static	ANTLR3_BITWORD FOLLOW_via_parm_in_header_via4090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000422) };
static  ANTLR3_BITSET_LIST FOLLOW_via_parm_in_header_via4090	= { FOLLOW_via_parm_in_header_via4090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sent_protocol_in_via_parm4125  */
static	ANTLR3_BITWORD FOLLOW_sent_protocol_in_via_parm4125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_sent_protocol_in_via_parm4125	= { FOLLOW_sent_protocol_in_via_parm4125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_via_parm4128  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_via_parm4128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040030040) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_via_parm4128	= { FOLLOW_LWS_in_via_parm4128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sent_by_in_via_parm4130  */
static	ANTLR3_BITWORD FOLLOW_sent_by_in_via_parm4130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_sent_by_in_via_parm4130	= { FOLLOW_sent_by_in_via_parm4130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_via_parm4134  */
static	ANTLR3_BITWORD FOLLOW_semi_in_via_parm4134_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_via_parm4134	= { FOLLOW_semi_in_via_parm4134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_params_in_via_parm4136  */
static	ANTLR3_BITWORD FOLLOW_via_params_in_via_parm4136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_via_params_in_via_parm4136	= { FOLLOW_via_params_in_via_parm4136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_received_in_via_params4168  */
static	ANTLR3_BITWORD FOLLOW_via_received_in_via_params4168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_via_received_in_via_params4168	= { FOLLOW_via_received_in_via_params4168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_via_params4173  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_via_params4173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_via_params4173	= { FOLLOW_generic_param_in_via_params4173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_via_received4191  */
static	ANTLR3_BITWORD FOLLOW_token_in_via_received4191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_via_received4191	= { FOLLOW_token_in_via_received4191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_via_received4193  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_via_received4193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100010040) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_via_received4193	= { FOLLOW_EQUAL_in_via_received4193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_address_in_via_received4195  */
static	ANTLR3_BITWORD FOLLOW_via_address_in_via_received4195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_via_address_in_via_received4195	= { FOLLOW_via_address_in_via_received4195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv4address_in_via_address4204  */
static	ANTLR3_BITWORD FOLLOW_ipv4address_in_via_address4204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv4address_in_via_address4204	= { FOLLOW_ipv4address_in_via_address4204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv6address_in_via_address4208  */
static	ANTLR3_BITWORD FOLLOW_ipv6address_in_via_address4208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv6address_in_via_address4208	= { FOLLOW_ipv6address_in_via_address4208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_protocol_name_in_sent_protocol4226  */
static	ANTLR3_BITWORD FOLLOW_protocol_name_in_sent_protocol4226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000820) };
static  ANTLR3_BITSET_LIST FOLLOW_protocol_name_in_sent_protocol4226	= { FOLLOW_protocol_name_in_sent_protocol4226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_slash_in_sent_protocol4228  */
static	ANTLR3_BITWORD FOLLOW_slash_in_sent_protocol4228_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_slash_in_sent_protocol4228	= { FOLLOW_slash_in_sent_protocol4228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_protocol_version_in_sent_protocol4230  */
static	ANTLR3_BITWORD FOLLOW_protocol_version_in_sent_protocol4230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000820) };
static  ANTLR3_BITSET_LIST FOLLOW_protocol_version_in_sent_protocol4230	= { FOLLOW_protocol_version_in_sent_protocol4230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_slash_in_sent_protocol4256  */
static	ANTLR3_BITWORD FOLLOW_slash_in_sent_protocol4256_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_slash_in_sent_protocol4256	= { FOLLOW_slash_in_sent_protocol4256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_transport_in_sent_protocol4258  */
static	ANTLR3_BITWORD FOLLOW_transport_in_sent_protocol4258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_transport_in_sent_protocol4258	= { FOLLOW_transport_in_sent_protocol4258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_protocol_name4278  */
static	ANTLR3_BITWORD FOLLOW_token_in_protocol_name4278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_protocol_name4278	= { FOLLOW_token_in_protocol_name4278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_protocol_version4290  */
static	ANTLR3_BITWORD FOLLOW_token_in_protocol_version4290_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_protocol_version4290	= { FOLLOW_token_in_protocol_version4290_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_transport_in_transport4310  */
static	ANTLR3_BITWORD FOLLOW_other_transport_in_transport4310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_transport_in_transport4310	= { FOLLOW_other_transport_in_transport4310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_other_transport4318  */
static	ANTLR3_BITWORD FOLLOW_token_in_other_transport4318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_other_transport4318	= { FOLLOW_token_in_other_transport4318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_host_in_sent_by4340  */
static	ANTLR3_BITWORD FOLLOW_host_in_sent_by4340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002002) };
static  ANTLR3_BITSET_LIST FOLLOW_host_in_sent_by4340	= { FOLLOW_host_in_sent_by4340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_sent_by4350  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_sent_by4350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_sent_by4350	= { FOLLOW_COLON_in_sent_by4350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_in_sent_by4352  */
static	ANTLR3_BITWORD FOLLOW_port_in_sent_by4352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_port_in_sent_by4352	= { FOLLOW_port_in_sent_by4352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_www_authenticate4391  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_www_authenticate4391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_www_authenticate4391	= { FOLLOW_token_in_header_www_authenticate4391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_www_authenticate4395  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_www_authenticate4395_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_www_authenticate4395	= { FOLLOW_hcolon_in_header_www_authenticate4395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_challenge_in_header_www_authenticate4397  */
static	ANTLR3_BITWORD FOLLOW_challenge_in_header_www_authenticate4397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_challenge_in_header_www_authenticate4397	= { FOLLOW_challenge_in_header_www_authenticate4397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_state_value4410  */
static	ANTLR3_BITWORD FOLLOW_token_in_state_value4410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_state_value4410	= { FOLLOW_token_in_state_value4410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_subscription_state4438  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_subscription_state4438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_subscription_state4438	= { FOLLOW_token_in_header_subscription_state4438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_subscription_state4444  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_subscription_state4444_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_subscription_state4444	= { FOLLOW_hcolon_in_header_subscription_state4444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_state_value_in_header_subscription_state4446  */
static	ANTLR3_BITWORD FOLLOW_state_value_in_header_subscription_state4446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_state_value_in_header_subscription_state4446	= { FOLLOW_state_value_in_header_subscription_state4446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_header_subscription_state4453  */
static	ANTLR3_BITWORD FOLLOW_semi_in_header_subscription_state4453_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_header_subscription_state4453	= { FOLLOW_semi_in_header_subscription_state4453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_header_subscription_state4456  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_header_subscription_state4456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_header_subscription_state4456	= { FOLLOW_generic_param_in_header_subscription_state4456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_replaces4500  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_replaces4500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_replaces4500	= { FOLLOW_token_in_header_replaces4500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_replaces4506  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_replaces4506_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_replaces4506	= { FOLLOW_hcolon_in_header_replaces4506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_id_in_header_replaces4508  */
static	ANTLR3_BITWORD FOLLOW_call_id_in_header_replaces4508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_call_id_in_header_replaces4508	= { FOLLOW_call_id_in_header_replaces4508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_header_replaces4516  */
static	ANTLR3_BITWORD FOLLOW_semi_in_header_replaces4516_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_header_replaces4516	= { FOLLOW_semi_in_header_replaces4516_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_header_replaces4519  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_header_replaces4519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_header_replaces4519	= { FOLLOW_generic_param_in_header_replaces4519_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_p_preferred_identity4558  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_p_preferred_identity4558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_p_preferred_identity4558	= { FOLLOW_token_in_header_p_preferred_identity4558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_p_preferred_identity4564  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_p_preferred_identity4564_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C303781E0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_p_preferred_identity4564	= { FOLLOW_hcolon_in_header_p_preferred_identity4564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_address_base_in_header_p_preferred_identity4566  */
static	ANTLR3_BITWORD FOLLOW_header_address_base_in_header_p_preferred_identity4566_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_address_base_in_header_p_preferred_identity4566	= { FOLLOW_header_address_base_in_header_p_preferred_identity4566_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_privacy4603  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_privacy4603_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_privacy4603	= { FOLLOW_token_in_header_privacy4603_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_privacy4607  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_privacy4607_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_privacy4607	= { FOLLOW_hcolon_in_header_privacy4607_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_privacy_val_in_header_privacy4609  */
static	ANTLR3_BITWORD FOLLOW_privacy_val_in_header_privacy4609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_privacy_val_in_header_privacy4609	= { FOLLOW_privacy_val_in_header_privacy4609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_header_privacy4612  */
static	ANTLR3_BITWORD FOLLOW_semi_in_header_privacy4612_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338140) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_header_privacy4612	= { FOLLOW_semi_in_header_privacy4612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_privacy_val_in_header_privacy4614  */
static	ANTLR3_BITWORD FOLLOW_privacy_val_in_header_privacy4614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_privacy_val_in_header_privacy4614	= { FOLLOW_privacy_val_in_header_privacy4614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_privacy_val4629  */
static	ANTLR3_BITWORD FOLLOW_token_in_privacy_val4629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_privacy_val4629	= { FOLLOW_token_in_privacy_val4629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_name_in_header_extension4651  */
static	ANTLR3_BITWORD FOLLOW_header_name_in_header_extension4651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_header_name_in_header_extension4651	= { FOLLOW_header_name_in_header_extension4651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_extension4660  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_extension4660_bits[]	= { ANTLR3_UINT64_LIT(0x000007FFFFFFFFE0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_extension4660	= { FOLLOW_hcolon_in_header_extension4660_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_value_in_header_extension4669  */
static	ANTLR3_BITWORD FOLLOW_header_value_in_header_extension4669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_value_in_header_extension4669	= { FOLLOW_header_value_in_header_extension4669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_name4689  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_name4689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_name4689	= { FOLLOW_token_in_header_name4689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_header_value4706  */
static	ANTLR3_BITWORD FOLLOW_set_in_header_value4706_bits[]	= { ANTLR3_UINT64_LIT(0x000007FFFFFFFFE2) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_header_value4706	= { FOLLOW_set_in_header_value4706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OCTET_in_message_body4736  */
static	ANTLR3_BITWORD FOLLOW_OCTET_in_message_body4736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004002) };
static  ANTLR3_BITSET_LIST FOLLOW_OCTET_in_message_body4736	= { FOLLOW_OCTET_in_message_body4736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_schema_in_paramless_uri4767  */
static	ANTLR3_BITWORD FOLLOW_sip_schema_in_paramless_uri4767_bits[]	= { ANTLR3_UINT64_LIT(0x000007847E339F40) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_schema_in_paramless_uri4767	= { FOLLOW_sip_schema_in_paramless_uri4767_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userinfo_in_paramless_uri4772  */
static	ANTLR3_BITWORD FOLLOW_userinfo_in_paramless_uri4772_bits[]	= { ANTLR3_UINT64_LIT(0x000007847E339F40) };
static  ANTLR3_BITSET_LIST FOLLOW_userinfo_in_paramless_uri4772	= { FOLLOW_userinfo_in_paramless_uri4772_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostport_in_paramless_uri4775  */
static	ANTLR3_BITWORD FOLLOW_hostport_in_paramless_uri4775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hostport_in_paramless_uri4775	= { FOLLOW_hostport_in_paramless_uri4775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostport_in_paramless_uri4781  */
static	ANTLR3_BITWORD FOLLOW_hostport_in_paramless_uri4781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hostport_in_paramless_uri4781	= { FOLLOW_hostport_in_paramless_uri4781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_headers_in_paramless_uri4790  */
static	ANTLR3_BITWORD FOLLOW_headers_in_paramless_uri4790_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_headers_in_paramless_uri4790	= { FOLLOW_headers_in_paramless_uri4790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_schema_in_uri4831  */
static	ANTLR3_BITWORD FOLLOW_sip_schema_in_uri4831_bits[]	= { ANTLR3_UINT64_LIT(0x000007847E339F40) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_schema_in_uri4831	= { FOLLOW_sip_schema_in_uri4831_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userinfo_in_uri4836  */
static	ANTLR3_BITWORD FOLLOW_userinfo_in_uri4836_bits[]	= { ANTLR3_UINT64_LIT(0x000007847E339F40) };
static  ANTLR3_BITSET_LIST FOLLOW_userinfo_in_uri4836	= { FOLLOW_userinfo_in_uri4836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostport_in_uri4839  */
static	ANTLR3_BITWORD FOLLOW_hostport_in_uri4839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000222) };
static  ANTLR3_BITSET_LIST FOLLOW_hostport_in_uri4839	= { FOLLOW_hostport_in_uri4839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostport_in_uri4845  */
static	ANTLR3_BITWORD FOLLOW_hostport_in_uri4845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000222) };
static  ANTLR3_BITSET_LIST FOLLOW_hostport_in_uri4845	= { FOLLOW_hostport_in_uri4845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_parameters_in_uri4854  */
static	ANTLR3_BITWORD FOLLOW_uri_parameters_in_uri4854_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_parameters_in_uri4854	= { FOLLOW_uri_parameters_in_uri4854_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_headers_in_uri4862  */
static	ANTLR3_BITWORD FOLLOW_headers_in_uri4862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_headers_in_uri4862	= { FOLLOW_headers_in_uri4862_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_sip_token4883  */
static	ANTLR3_BITWORD FOLLOW_token_in_sip_token4883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_sip_token4883	= { FOLLOW_token_in_sip_token4883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_sips_token4892  */
static	ANTLR3_BITWORD FOLLOW_token_in_sips_token4892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_sips_token4892	= { FOLLOW_token_in_sips_token4892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sips_token_in_sip_schema4903  */
static	ANTLR3_BITWORD FOLLOW_sips_token_in_sip_schema4903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_sips_token_in_sip_schema4903	= { FOLLOW_sips_token_in_sip_schema4903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_token_in_sip_schema4921  */
static	ANTLR3_BITWORD FOLLOW_sip_token_in_sip_schema4921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_token_in_sip_schema4921	= { FOLLOW_sip_token_in_sip_schema4921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_sip_schema4924  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_sip_schema4924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_sip_schema4924	= { FOLLOW_COLON_in_sip_schema4924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_user_in_userinfo4950  */
static	ANTLR3_BITWORD FOLLOW_user_in_userinfo4950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001002000) };
static  ANTLR3_BITSET_LIST FOLLOW_user_in_userinfo4950	= { FOLLOW_user_in_userinfo4950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_userinfo4954  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_userinfo4954_bits[]	= { ANTLR3_UINT64_LIT(0x0000078037339540) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_userinfo4954	= { FOLLOW_COLON_in_userinfo4954_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_password_in_userinfo4956  */
static	ANTLR3_BITWORD FOLLOW_password_in_userinfo4956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_password_in_userinfo4956	= { FOLLOW_password_in_userinfo4956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_24_in_userinfo4961  */
static	ANTLR3_BITWORD FOLLOW_24_in_userinfo4961_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_24_in_userinfo4961	= { FOLLOW_24_in_userinfo4961_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_user4984  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_user4984_bits[]	= { ANTLR3_UINT64_LIT(0x000007843E339F42) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_user4984	= { FOLLOW_unreserved_in_user4984_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_user4989  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_user4989_bits[]	= { ANTLR3_UINT64_LIT(0x000007843E339F42) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_user4989	= { FOLLOW_escaped_in_user4989_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_user_unreserved_in_user4993  */
static	ANTLR3_BITWORD FOLLOW_user_unreserved_in_user4993_bits[]	= { ANTLR3_UINT64_LIT(0x000007843E339F42) };
static  ANTLR3_BITSET_LIST FOLLOW_user_unreserved_in_user4993	= { FOLLOW_user_unreserved_in_user4993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_user_unreserved0  */
static	ANTLR3_BITWORD FOLLOW_set_in_user_unreserved0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_user_unreserved0	= { FOLLOW_set_in_user_unreserved0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_password5052  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_password5052_bits[]	= { ANTLR3_UINT64_LIT(0x0000078036339542) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_password5052	= { FOLLOW_unreserved_in_password5052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_password5056  */
static	ANTLR3_BITWORD FOLLOW_25_in_password5056_bits[]	= { ANTLR3_UINT64_LIT(0x0000078036339542) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_password5056	= { FOLLOW_25_in_password5056_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_password5060  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_password5060_bits[]	= { ANTLR3_UINT64_LIT(0x0000078036339542) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_password5060	= { FOLLOW_EQUAL_in_password5060_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_password5064  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_password5064_bits[]	= { ANTLR3_UINT64_LIT(0x0000078036339542) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_password5064	= { FOLLOW_PLUS_in_password5064_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_password5068  */
static	ANTLR3_BITWORD FOLLOW_26_in_password5068_bits[]	= { ANTLR3_UINT64_LIT(0x0000078036339542) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_password5068	= { FOLLOW_26_in_password5068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_password5072  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_password5072_bits[]	= { ANTLR3_UINT64_LIT(0x0000078036339542) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_password5072	= { FOLLOW_COMMA_in_password5072_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_host_in_hostport5103  */
static	ANTLR3_BITWORD FOLLOW_host_in_hostport5103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002002) };
static  ANTLR3_BITSET_LIST FOLLOW_host_in_hostport5103	= { FOLLOW_host_in_hostport5103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hostport5107  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hostport5107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hostport5107	= { FOLLOW_COLON_in_hostport5107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_in_hostport5109  */
static	ANTLR3_BITWORD FOLLOW_port_in_hostport5109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_port_in_hostport5109	= { FOLLOW_port_in_hostport5109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostname_in_host5150  */
static	ANTLR3_BITWORD FOLLOW_hostname_in_host5150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hostname_in_host5150	= { FOLLOW_hostname_in_host5150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv4address_in_host5176  */
static	ANTLR3_BITWORD FOLLOW_ipv4address_in_host5176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv4address_in_host5176	= { FOLLOW_ipv4address_in_host5176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv6reference_in_host5202  */
static	ANTLR3_BITWORD FOLLOW_ipv6reference_in_host5202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv6reference_in_host5202	= { FOLLOW_ipv6reference_in_host5202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_domainlabel_in_hostname5224  */
static	ANTLR3_BITWORD FOLLOW_domainlabel_in_hostname5224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_domainlabel_in_hostname5224	= { FOLLOW_domainlabel_in_hostname5224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_hostname5226  */
static	ANTLR3_BITWORD FOLLOW_28_in_hostname5226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030040) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_hostname5226	= { FOLLOW_28_in_hostname5226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_toplabel_in_hostname5231  */
static	ANTLR3_BITWORD FOLLOW_toplabel_in_hostname5231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_toplabel_in_hostname5231	= { FOLLOW_toplabel_in_hostname5231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_hostname5233  */
static	ANTLR3_BITWORD FOLLOW_28_in_hostname5233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_hostname5233	= { FOLLOW_28_in_hostname5233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_domainlabel5250  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_domainlabel5250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_domainlabel5250	= { FOLLOW_alphanum_in_domainlabel5250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_domainlabel5255  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_domainlabel5255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020030040) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_domainlabel5255	= { FOLLOW_alphanum_in_domainlabel5255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_domainlabel5259  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_domainlabel5259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020030040) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_domainlabel5259	= { FOLLOW_alphanum_in_domainlabel5259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_domainlabel5263  */
static	ANTLR3_BITWORD FOLLOW_29_in_domainlabel5263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020030040) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_domainlabel5263	= { FOLLOW_29_in_domainlabel5263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_domainlabel5268  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_domainlabel5268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_domainlabel5268	= { FOLLOW_alphanum_in_domainlabel5268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_toplabel5286  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_toplabel5286_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_toplabel5286	= { FOLLOW_alpha_in_toplabel5286_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_toplabel5291  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_toplabel5291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020030040) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_toplabel5291	= { FOLLOW_alpha_in_toplabel5291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_toplabel5295  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_toplabel5295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020030040) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_toplabel5295	= { FOLLOW_alphanum_in_toplabel5295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_toplabel5299  */
static	ANTLR3_BITWORD FOLLOW_29_in_toplabel5299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020030040) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_toplabel5299	= { FOLLOW_29_in_toplabel5299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_toplabel5304  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_toplabel5304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_toplabel5304	= { FOLLOW_alphanum_in_toplabel5304_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ipv4address5318  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ipv4address5318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ipv4address5318	= { FOLLOW_three_digit_in_ipv4address5318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_ipv4address5320  */
static	ANTLR3_BITWORD FOLLOW_28_in_ipv4address5320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_ipv4address5320	= { FOLLOW_28_in_ipv4address5320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ipv4address5322  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ipv4address5322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ipv4address5322	= { FOLLOW_three_digit_in_ipv4address5322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_ipv4address5324  */
static	ANTLR3_BITWORD FOLLOW_28_in_ipv4address5324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_ipv4address5324	= { FOLLOW_28_in_ipv4address5324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ipv4address5326  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ipv4address5326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ipv4address5326	= { FOLLOW_three_digit_in_ipv4address5326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_ipv4address5328  */
static	ANTLR3_BITWORD FOLLOW_28_in_ipv4address5328_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_ipv4address5328	= { FOLLOW_28_in_ipv4address5328_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ipv4address5330  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ipv4address5330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ipv4address5330	= { FOLLOW_three_digit_in_ipv4address5330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_ipv6reference5340  */
static	ANTLR3_BITWORD FOLLOW_30_in_ipv6reference5340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100010040) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_ipv6reference5340	= { FOLLOW_30_in_ipv6reference5340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv6address_in_ipv6reference5342  */
static	ANTLR3_BITWORD FOLLOW_ipv6address_in_ipv6reference5342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv6address_in_ipv6reference5342	= { FOLLOW_ipv6address_in_ipv6reference5342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_ipv6reference5344  */
static	ANTLR3_BITWORD FOLLOW_31_in_ipv6reference5344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_ipv6reference5344	= { FOLLOW_31_in_ipv6reference5344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexpart_in_ipv6address5356  */
static	ANTLR3_BITWORD FOLLOW_hexpart_in_ipv6address5356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexpart_in_ipv6address5356	= { FOLLOW_hexpart_in_ipv6address5356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_ipv6address5360  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_ipv6address5360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_ipv6address5360	= { FOLLOW_COLON_in_ipv6address5360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv4address_in_ipv6address5362  */
static	ANTLR3_BITWORD FOLLOW_ipv4address_in_ipv6address5362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv4address_in_ipv6address5362	= { FOLLOW_ipv4address_in_ipv6address5362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart5381  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart5381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart5381	= { FOLLOW_hexseq_in_hexpart5381_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart5385  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart5385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart5385	= { FOLLOW_hexseq_in_hexpart5385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_hexpart5387  */
static	ANTLR3_BITWORD FOLLOW_32_in_hexpart5387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010042) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_hexpart5387	= { FOLLOW_32_in_hexpart5387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart5391  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart5391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart5391	= { FOLLOW_hexseq_in_hexpart5391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_hexpart5398  */
static	ANTLR3_BITWORD FOLLOW_32_in_hexpart5398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010042) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_hexpart5398	= { FOLLOW_32_in_hexpart5398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart5402  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart5402_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart5402	= { FOLLOW_hexseq_in_hexpart5402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hex4_in_hexseq5421  */
static	ANTLR3_BITWORD FOLLOW_hex4_in_hexseq5421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002002) };
static  ANTLR3_BITSET_LIST FOLLOW_hex4_in_hexseq5421	= { FOLLOW_hex4_in_hexseq5421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexseq5425  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexseq5425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010040) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexseq5425	= { FOLLOW_COLON_in_hexseq5425_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hex4_in_hexseq5427  */
static	ANTLR3_BITWORD FOLLOW_hex4_in_hexseq5427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002002) };
static  ANTLR3_BITSET_LIST FOLLOW_hex4_in_hexseq5427	= { FOLLOW_hex4_in_hexseq5427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_hex45447  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_hex45447_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010042) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_hex45447	= { FOLLOW_hexdigit_in_hex45447_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_port5460  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_port5460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_port5460	= { FOLLOW_DIGIT_in_port5460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_uri_parameters5492  */
static	ANTLR3_BITWORD FOLLOW_semi_in_uri_parameters5492_bits[]	= { ANTLR3_UINT64_LIT(0x00000784F633AB62) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_uri_parameters5492	= { FOLLOW_semi_in_uri_parameters5492_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_parameter_in_uri_parameters5494  */
static	ANTLR3_BITWORD FOLLOW_uri_parameter_in_uri_parameters5494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000222) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_parameter_in_uri_parameters5494	= { FOLLOW_uri_parameter_in_uri_parameters5494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_param_in_uri_parameter5511  */
static	ANTLR3_BITWORD FOLLOW_other_param_in_uri_parameter5511_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_param_in_uri_parameter5511	= { FOLLOW_other_param_in_uri_parameter5511_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pname_in_other_param5527  */
static	ANTLR3_BITWORD FOLLOW_pname_in_other_param5527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pname_in_other_param5527	= { FOLLOW_pname_in_other_param5527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pname_in_other_param5539  */
static	ANTLR3_BITWORD FOLLOW_pname_in_other_param5539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_pname_in_other_param5539	= { FOLLOW_pname_in_other_param5539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_other_param5541  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_other_param5541_bits[]	= { ANTLR3_UINT64_LIT(0x00000784F633A940) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_other_param5541	= { FOLLOW_EQUAL_in_other_param5541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pvalue_in_other_param5543  */
static	ANTLR3_BITWORD FOLLOW_pvalue_in_other_param5543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pvalue_in_other_param5543	= { FOLLOW_pvalue_in_other_param5543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramchar_in_pname5575  */
static	ANTLR3_BITWORD FOLLOW_paramchar_in_pname5575_bits[]	= { ANTLR3_UINT64_LIT(0x00000784F633A942) };
static  ANTLR3_BITSET_LIST FOLLOW_paramchar_in_pname5575	= { FOLLOW_paramchar_in_pname5575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramchar_in_pvalue5598  */
static	ANTLR3_BITWORD FOLLOW_paramchar_in_pvalue5598_bits[]	= { ANTLR3_UINT64_LIT(0x00000784F633A942) };
static  ANTLR3_BITSET_LIST FOLLOW_paramchar_in_pvalue5598	= { FOLLOW_paramchar_in_pvalue5598_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_unreserved_in_paramchar5618  */
static	ANTLR3_BITWORD FOLLOW_param_unreserved_in_paramchar5618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_param_unreserved_in_paramchar5618	= { FOLLOW_param_unreserved_in_paramchar5618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_paramchar5622  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_paramchar5622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_paramchar5622	= { FOLLOW_unreserved_in_paramchar5622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_paramchar5626  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_paramchar5626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_paramchar5626	= { FOLLOW_escaped_in_paramchar5626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_param_unreserved0  */
static	ANTLR3_BITWORD FOLLOW_set_in_param_unreserved0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_param_unreserved0	= { FOLLOW_set_in_param_unreserved0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_headers5703  */
static	ANTLR3_BITWORD FOLLOW_27_in_headers5703_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A140) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_headers5703	= { FOLLOW_27_in_headers5703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_in_headers5705  */
static	ANTLR3_BITWORD FOLLOW_header_in_headers5705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_in_headers5705	= { FOLLOW_header_in_headers5705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_headers5709  */
static	ANTLR3_BITWORD FOLLOW_25_in_headers5709_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A140) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_headers5709	= { FOLLOW_25_in_headers5709_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_in_headers5711  */
static	ANTLR3_BITWORD FOLLOW_header_in_headers5711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_in_headers5711	= { FOLLOW_header_in_headers5711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hname_in_header5732  */
static	ANTLR3_BITWORD FOLLOW_hname_in_header5732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_hname_in_header5732	= { FOLLOW_hname_in_header5732_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_header5734  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_header5734_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A142) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_header5734	= { FOLLOW_EQUAL_in_header5734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hvalue_in_header5736  */
static	ANTLR3_BITWORD FOLLOW_hvalue_in_header5736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hvalue_in_header5736	= { FOLLOW_hvalue_in_header5736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hnv_unreserved_in_hname5759  */
static	ANTLR3_BITWORD FOLLOW_hnv_unreserved_in_hname5759_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A142) };
static  ANTLR3_BITSET_LIST FOLLOW_hnv_unreserved_in_hname5759	= { FOLLOW_hnv_unreserved_in_hname5759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_hname5763  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_hname5763_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A142) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_hname5763	= { FOLLOW_unreserved_in_hname5763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_hname5767  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_hname5767_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A142) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_hname5767	= { FOLLOW_escaped_in_hname5767_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hnv_unreserved_in_hvalue5789  */
static	ANTLR3_BITWORD FOLLOW_hnv_unreserved_in_hvalue5789_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A142) };
static  ANTLR3_BITSET_LIST FOLLOW_hnv_unreserved_in_hvalue5789	= { FOLLOW_hnv_unreserved_in_hvalue5789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_hvalue5793  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_hvalue5793_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A142) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_hvalue5793	= { FOLLOW_unreserved_in_hvalue5793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_hvalue5797  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_hvalue5797_bits[]	= { ANTLR3_UINT64_LIT(0x00000786FC33A142) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_hvalue5797	= { FOLLOW_escaped_in_hvalue5797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_hnv_unreserved0  */
static	ANTLR3_BITWORD FOLLOW_set_in_hnv_unreserved0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_hnv_unreserved0	= { FOLLOW_set_in_hnv_unreserved0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_escaped5848  */
static	ANTLR3_BITWORD FOLLOW_34_in_escaped5848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010040) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_escaped5848	= { FOLLOW_34_in_escaped5848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_escaped5850  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_escaped5850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010040) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_escaped5850	= { FOLLOW_hexdigit_in_escaped5850_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_escaped5852  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_escaped5852_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_escaped5852	= { FOLLOW_hexdigit_in_escaped5852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ttl5859  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ttl5859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ttl5859	= { FOLLOW_three_digit_in_ttl5859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit5865  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit5865_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit5865	= { FOLLOW_DIGIT_in_three_digit5865_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit5870  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit5870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit5870	= { FOLLOW_DIGIT_in_three_digit5870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit5872  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit5872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit5872	= { FOLLOW_DIGIT_in_three_digit5872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit5878  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit5878_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit5878	= { FOLLOW_DIGIT_in_three_digit5878_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit5880  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit5880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit5880	= { FOLLOW_DIGIT_in_three_digit5880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit5882  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit5882_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit5882	= { FOLLOW_DIGIT_in_three_digit5882_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_token5903  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_token5903_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338142) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_token5903	= { FOLLOW_alphanum_in_token5903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mark_in_token5907  */
static	ANTLR3_BITWORD FOLLOW_mark_in_token5907_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338142) };
static  ANTLR3_BITSET_LIST FOLLOW_mark_in_token5907	= { FOLLOW_mark_in_token5907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_token5911  */
static	ANTLR3_BITWORD FOLLOW_34_in_token5911_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338142) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_token5911	= { FOLLOW_34_in_token5911_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_token5915  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_token5915_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338142) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_token5915	= { FOLLOW_PLUS_in_token5915_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_token5919  */
static	ANTLR3_BITWORD FOLLOW_35_in_token5919_bits[]	= { ANTLR3_UINT64_LIT(0x0000078C30338142) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_token5919	= { FOLLOW_35_in_token5919_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_reserved0  */
static	ANTLR3_BITWORD FOLLOW_set_in_reserved0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_reserved0	= { FOLLOW_set_in_reserved0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_unreserved6026  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_unreserved6026_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_unreserved6026	= { FOLLOW_alphanum_in_unreserved6026_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mark_in_unreserved6029  */
static	ANTLR3_BITWORD FOLLOW_mark_in_unreserved6029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_mark_in_unreserved6029	= { FOLLOW_mark_in_unreserved6029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_alphanum6041  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_alphanum6041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_alphanum6041	= { FOLLOW_alpha_in_alphanum6041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_alphanum6045  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_alphanum6045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_alphanum6045	= { FOLLOW_DIGIT_in_alphanum6045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_hexdigit0  */
static	ANTLR3_BITWORD FOLLOW_set_in_hexdigit0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_hexdigit0	= { FOLLOW_set_in_hexdigit0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_alpha0  */
static	ANTLR3_BITWORD FOLLOW_set_in_alpha0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_alpha0	= { FOLLOW_set_in_alpha0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_word6113  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_word6113_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_word6113	= { FOLLOW_alphanum_in_word6113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mark_in_word6117  */
static	ANTLR3_BITWORD FOLLOW_mark_in_word6117_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_mark_in_word6117	= { FOLLOW_mark_in_word6117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_word6123  */
static	ANTLR3_BITWORD FOLLOW_34_in_word6123_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_word6123	= { FOLLOW_34_in_word6123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_word6151  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_word6151_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_word6151	= { FOLLOW_PLUS_in_word6151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_word6155  */
static	ANTLR3_BITWORD FOLLOW_35_in_word6155_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_word6155	= { FOLLOW_35_in_word6155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LAQUOT_in_word6180  */
static	ANTLR3_BITWORD FOLLOW_LAQUOT_in_word6180_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_LAQUOT_in_word6180	= { FOLLOW_LAQUOT_in_word6180_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RAQUOT_in_word6184  */
static	ANTLR3_BITWORD FOLLOW_RAQUOT_in_word6184_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_RAQUOT_in_word6184	= { FOLLOW_RAQUOT_in_word6184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_word6209  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_word6209_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_word6209	= { FOLLOW_COLON_in_word6209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_word6213  */
static	ANTLR3_BITWORD FOLLOW_36_in_word6213_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_word6213	= { FOLLOW_36_in_word6213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_word6217  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_word6217_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_word6217	= { FOLLOW_DQUOTE_in_word6217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_word6221  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_word6221_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_word6221	= { FOLLOW_SLASH_in_word6221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_word6225  */
static	ANTLR3_BITWORD FOLLOW_30_in_word6225_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_word6225	= { FOLLOW_30_in_word6225_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_word6229  */
static	ANTLR3_BITWORD FOLLOW_31_in_word6229_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_word6229	= { FOLLOW_31_in_word6229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_word6233  */
static	ANTLR3_BITWORD FOLLOW_27_in_word6233_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_word6233	= { FOLLOW_27_in_word6233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_word6237  */
static	ANTLR3_BITWORD FOLLOW_37_in_word6237_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_word6237	= { FOLLOW_37_in_word6237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_word6241  */
static	ANTLR3_BITWORD FOLLOW_38_in_word6241_bits[]	= { ANTLR3_UINT64_LIT(0x000007FCF83FA9C2) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_word6241	= { FOLLOW_38_in_word6241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_mark0  */
static	ANTLR3_BITWORD FOLLOW_set_in_mark0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_mark0	= { FOLLOW_set_in_mark0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_hcolon6378  */
static	ANTLR3_BITWORD FOLLOW_set_in_hcolon6378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000402020) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_hcolon6378	= { FOLLOW_set_in_hcolon6378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hcolon6389  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hcolon6389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hcolon6389	= { FOLLOW_COLON_in_hcolon6389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_hcolon6392  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_hcolon6392_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_hcolon6392	= { FOLLOW_LWS_in_hcolon6392_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_ldquot6428  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_ldquot6428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_ldquot6428	= { FOLLOW_LWS_in_ldquot6428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_ldquot6431  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_ldquot6431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_ldquot6431	= { FOLLOW_DQUOTE_in_ldquot6431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_rdquot6439  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_rdquot6439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_rdquot6439	= { FOLLOW_DQUOTE_in_rdquot6439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_rdquot6441  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_rdquot6441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_rdquot6441	= { FOLLOW_LWS_in_rdquot6441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_semi6503  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_semi6503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_semi6503	= { FOLLOW_LWS_in_semi6503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_semi6506  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_semi6506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_semi6506	= { FOLLOW_SEMI_in_semi6506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_semi6508  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_semi6508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_semi6508	= { FOLLOW_LWS_in_semi6508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_comma6528  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_comma6528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_comma6528	= { FOLLOW_LWS_in_comma6528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_comma6531  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_comma6531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_comma6531	= { FOLLOW_COMMA_in_comma6531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_comma6533  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_comma6533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_comma6533	= { FOLLOW_LWS_in_comma6533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_sp_laquot_sp6553  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_sp_laquot_sp6553_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_sp_laquot_sp6553	= { FOLLOW_LWS_in_sp_laquot_sp6553_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LAQUOT_in_sp_laquot_sp6556  */
static	ANTLR3_BITWORD FOLLOW_LAQUOT_in_sp_laquot_sp6556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_LAQUOT_in_sp_laquot_sp6556	= { FOLLOW_LAQUOT_in_sp_laquot_sp6556_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_sp_laquot_sp6558  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_sp_laquot_sp6558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_sp_laquot_sp6558	= { FOLLOW_LWS_in_sp_laquot_sp6558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_sp_raquot_sp6567  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_sp_raquot_sp6567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_sp_raquot_sp6567	= { FOLLOW_LWS_in_sp_raquot_sp6567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RAQUOT_in_sp_raquot_sp6570  */
static	ANTLR3_BITWORD FOLLOW_RAQUOT_in_sp_raquot_sp6570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_RAQUOT_in_sp_raquot_sp6570	= { FOLLOW_RAQUOT_in_sp_raquot_sp6570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_sp_raquot_sp6572  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_sp_raquot_sp6572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_sp_raquot_sp6572	= { FOLLOW_LWS_in_sp_raquot_sp6572_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_equal6626  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_equal6626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_equal6626	= { FOLLOW_LWS_in_equal6626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_equal6629  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_equal6629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_equal6629	= { FOLLOW_EQUAL_in_equal6629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_equal6631  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_equal6631_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_equal6631	= { FOLLOW_LWS_in_equal6631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_slash6650  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_slash6650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_slash6650	= { FOLLOW_LWS_in_slash6650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_slash6653  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_slash6653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_slash6653	= { FOLLOW_SLASH_in_slash6653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LWS_in_slash6655  */
static	ANTLR3_BITWORD FOLLOW_LWS_in_slash6655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LWS_in_slash6655	= { FOLLOW_LWS_in_slash6655_bits, 1	};
     


/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    65:1: message_raw[size_t* length] returns [belle_sip_message_t* ret] : ( request | response );
 */
static const ANTLR3_INT32 dfa1_eot[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_eof[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_min[13] =
    {
	6, 5, 5, 5, 5, 5, 5, -1, 6, 6, -1, 6, 5
    };
static const ANTLR3_INT32 dfa1_max[13] =
    {
	42, 42, 42, 42, 42, 42, 42, -1, 42, 42, -1, 42, 42
    };
static const ANTLR3_INT32 dfa1_accept[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, 2, -1, -1, 1, -1, -1
    };
static const ANTLR3_INT32 dfa1_special[13] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa1_T_empty	    NULL

static const ANTLR3_INT32 dfa1_T0[] =
    {
	8, 2, 7, 3, -1, -1, 7, -1, 7, -1, 5, 1, 1, 7, 7, 3, 3, -1, -1, -1, -1, 
	-1, 7, 3, 3, 7, 7, -1, -1, 4, 6, 7, 7, 7, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa1_T1[] =
    {
	7, 10, -1, 10, -1, -1, -1, -1, 10, -1, 10, 10, 10, -1, -1, 10, 10, -1, 
	-1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, 10, 10, 
	10, 10
    };static const ANTLR3_INT32 dfa1_T2[] =
    {
	12, -1, 10, -1, -1, -1, -1, 10, -1, 10, 10, 10, -1, -1, 10, 10, -1, -1, 
	-1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, 10, 10, 10, 
	10
    };static const ANTLR3_INT32 dfa1_T3[] =
    {
	2, 7, 3, -1, -1, 7, -1, 7, -1, 5, 1, 1, 7, 7, 3, 3, -1, -1, -1, -1, -1, 
	7, 3, 3, 7, 7, -1, -1, 4, 6, 7, 7, 7, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa1_T4[] =
    {
	11, -1, 10, -1, -1, -1, -1, 10, -1, 10, 10, 10, -1, -1, 10, 10, -1, -1, 
	-1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, 10, 10, 10, 
	10
    };static const ANTLR3_INT32 dfa1_T5[] =
    {
	9, -1, 10, -1, -1, -1, -1, -1, -1, 10, 10, 10, -1, -1, 10, 10, -1, -1, 
	-1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, 10, 10, 10, 
	10
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa1_transitions[] =
{
    dfa1_T3, dfa1_T0, dfa1_T0, dfa1_T0, dfa1_T0, dfa1_T0, dfa1_T0, dfa1_T_empty, 
    dfa1_T5, dfa1_T4, dfa1_T_empty, dfa1_T2, dfa1_T1	
};


/* Declare tracking structure for Cyclic DFA 1
 */
static
ANTLR3_CYCLIC_DFA cdfa1
    =	{
	    1,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"65:1: message_raw[size_t* length] returns [belle_sip_message_t* ret] : ( request | response );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa1_eot,	    /* EOT table			    */
	    dfa1_eof,	    /* EOF table			    */
	    dfa1_min,	    /* Minimum tokens for each state    */
	    dfa1_max,	    /* Maximum tokens for each state    */
	    dfa1_accept,	/* Accept table			    */
	    dfa1_special,	/* Special transition states	    */
	    dfa1_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 1
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    281:1: credentials[belle_sip_header_authorization_t* header_authorization_base] : ( ( digest_token LWS digest_response[header_authorization_base] ) | other_response[header_authorization_base] );
 */
static const ANTLR3_INT32 dfa11_eot[332] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa11_eof[332] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa11_min[332] =
    {
	6, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 12, 5, 6, 0, 0, 0, 0, 0, 0, 0, 
	4, -1, -1, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa11_max[332] =
    {
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 12, 42, 42, 0, 
	0, 0, 0, 0, 0, 0, 42, -1, -1, 0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42
    };
static const ANTLR3_INT32 dfa11_accept[332] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa11_special[332] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 
	2, 3, 1, 7, 8, 6, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa11_T_empty	    NULL

static const ANTLR3_INT32 dfa11_T0[] =
    {
	34, 34, 93, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 244, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T1[] =
    {
	34, 48, 75, 42, 77, 49, 40, 79, 108, 76, 34, 79, 74, 74, 34, 34, 77, 77, 
	34, 34, 51, 79, 79, 50, 73, 77, 80, 80, 34, 34, 78, 34, 34, 34, 34, 77, 
	77, 77, 77
    };static const ANTLR3_INT32 dfa11_T2[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T3[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T4[] =
    {
	34, 34, 287, 42, 288, 40, 40, 40, 40, 285, 34, 290, 286, 286, 34, 34, 288, 
	288, 34, 34, 51, 187, 290, 290, 288, 288, 279, 279, 34, 279, 289, 34, 34, 
	34, 34, 288, 288, 288, 288
    };static const ANTLR3_INT32 dfa11_T5[] =
    {
	34, 34, 89, 27, 34, 34, 34, 34, 34, 34, 34, 34, 88, 88, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 90, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T6[] =
    {
	34, 34, 242, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T7[] =
    {
	34, 34, 150, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T8[] =
    {
	34, 48, 171, 42, 172, 71, 34, 158, 34, 158, 34, 158, 170, 170, 34, 34, 
	172, 172, 34, 34, 34, 158, 158, 102, 169, 172, 158, 158, 34, 34, 167, 34, 
	34, 34, 34, 172, 172, 172, 172
    };static const ANTLR3_INT32 dfa11_T9[] =
    {
	34, 34, 229, 27, 230, 40, 40, 40, 40, 227, 34, 232, 228, 228, 34, 34, 230, 
	230, 34, 34, 51, 40, 232, 232, 230, 230, 223, 223, 34, 223, 231, 34, 34, 
	34, 34, 230, 230, 230, 230
    };static const ANTLR3_INT32 dfa11_T10[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 325, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T11[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 314, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T12[] =
    {
	34, 48, 209, 42, 34, 71, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 102, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T13[] =
    {
	14, 9, -1, 10, -1, -1, -1, 15, -1, -1, 12, 8, 8, -1, -1, 10, 10, -1, -1, 
	-1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 11, 13, -1, -1, -1, 10, 10, 10, 
	10
    };static const ANTLR3_INT32 dfa11_T14[] =
    {
	34, 34, 137, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 140, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T15[] =
    {
	34, 34, 83, 27, 84, 40, 40, 40, 40, 81, 34, 86, 82, 82, 34, 34, 84, 84, 
	34, 34, 51, 40, 86, 86, 84, 84, 87, 87, 34, 87, 85, 34, 34, 34, 34, 84, 
	84, 84, 84
    };static const ANTLR3_INT32 dfa11_T16[] =
    {
	34, 48, 195, 42, 34, 71, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 102, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T17[] =
    {
	34, 48, 135, 42, 34, 71, 34, 34, 34, 133, 34, 34, 134, 134, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 102, 132, 136, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T18[] =
    {
	34, 34, 236, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 237, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T19[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 263, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T20[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 208, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T21[] =
    {
	34, 48, 93, 42, 38, 49, 40, 40, 40, 47, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 50, 94, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T22[] =
    {
	34, 48, 110, 42, 116, 71, 70, 80, 113, 80, 34, 114, 109, 109, 34, 34, 116, 
	116, 34, 34, 51, 112, 115, 102, 111, 116, 80, 80, 34, 34, 107, 34, 34, 
	34, 34, 116, 116, 116, 116
    };static const ANTLR3_INT32 dfa11_T23[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 309, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T24[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 271, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T25[] =
    {
	34, 34, 171, 27, 172, 34, 34, 158, 34, 158, 34, 158, 170, 170, 34, 34, 
	172, 172, 34, 34, 34, 158, 158, 34, 169, 172, 158, 158, 34, 34, 167, 34, 
	34, 34, 34, 172, 172, 172, 172
    };static const ANTLR3_INT32 dfa11_T26[] =
    {
	34, 34, 275, 42, 276, 34, 70, 34, 67, 279, 34, 277, 274, 274, 34, 34, 276, 
	276, 34, 34, 51, 178, 278, 279, 276, 276, 279, 279, 34, 279, 280, 34, 34, 
	34, 34, 276, 276, 276, 276
    };static const ANTLR3_INT32 dfa11_T27[] =
    {
	34, 34, 191, 42, 192, 34, 34, 34, 34, 180, 34, 180, 190, 190, 34, 34, 192, 
	192, 34, 34, 34, 193, 180, 180, 192, 192, 180, 180, 34, 180, 177, 34, 34, 
	34, 34, 192, 192, 192, 192
    };static const ANTLR3_INT32 dfa11_T28[] =
    {
	34, 34, 197, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 198, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T29[] =
    {
	34, 48, 300, 42, 38, 49, 40, 40, 40, 47, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 50, 94, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T30[] =
    {
	34, 34, 239, 27, 34, 34, 34, 34, 34, 200, 34, 34, 239, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 202, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T31[] =
    {
	34, 34, 146, 27, 34, 34, 34, 34, 34, 97, 34, 34, 146, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 99, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T32[] =
    {
	34, 34, 219, 27, 220, 34, 70, 34, 254, 223, 34, 221, 218, 218, 34, 34, 
	220, 220, 34, 34, 51, 66, 222, 223, 220, 220, 223, 223, 34, 223, 224, 34, 
	34, 34, 34, 220, 220, 220, 220
    };static const ANTLR3_INT32 dfa11_T33[] =
    {
	34, 34, 120, 27, 121, 34, 70, 34, 122, 87, 34, 123, 119, 119, 34, 34, 121, 
	121, 34, 34, 51, 66, 124, 87, 121, 121, 87, 87, 34, 87, 125, 34, 34, 34, 
	34, 121, 121, 121, 121
    };static const ANTLR3_INT32 dfa11_T34[] =
    {
	34, 34, 330, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T35[] =
    {
	34, 34, 326, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T36[] =
    {
	34, 34, 184, 42, 185, 40, 40, 40, 40, 182, 34, 188, 183, 183, 34, 34, 185, 
	185, 34, 34, 51, 187, 188, 188, 185, 185, 180, 180, 34, 180, 186, 34, 34, 
	34, 34, 185, 185, 185, 185
    };static const ANTLR3_INT32 dfa11_T37[] =
    {
	34, 34, 95, 27, 65, 34, 70, 34, 67, 34, 34, 68, 63, 63, 34, 34, 65, 65, 
	34, 34, 51, 66, 69, 34, 65, 65, 34, 34, 34, 34, 34, 34, 34, 34, 34, 65, 
	65, 65, 65
    };static const ANTLR3_INT32 dfa11_T38[] =
    {
	34, 34, 93, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 53, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T39[] =
    {
	34, 48, 44, 42, 38, 49, 40, 40, 40, 47, 34, 40, 43, 43, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 50, 46, 45, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T40[] =
    {
	34, 34, 93, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 144, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T41[] =
    {
	34, 34, 318, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 309, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T42[] =
    {
	34, 34, 301, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 271, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T43[] =
    {
	34, 34, 100, 27, 34, 34, 34, 34, 34, 101, 34, 34, 100, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T44[] =
    {
	34, 34, 203, 27, 34, 34, 34, 34, 34, 204, 34, 34, 203, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T45[] =
    {
	34, 48, 34, 42, 34, 71, 34, 34, 34, 133, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 102, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T46[] =
    {
	34, 34, 327, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 325, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T47[] =
    {
	34, 34, 321, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 314, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T48[] =
    {
	34, 34, 316, 27, 34, 34, 34, 34, 34, 34, 34, 34, 316, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T49[] =
    {
	34, 34, 291, 27, 34, 34, 34, 34, 34, 34, 34, 34, 291, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T50[] =
    {
	34, 34, 257, 27, 34, 34, 34, 34, 34, 34, 34, 34, 257, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T51[] =
    {
	34, 34, 251, 27, 34, 34, 34, 34, 34, 34, 34, 34, 251, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T52[] =
    {
	34, 34, 189, 27, 34, 34, 34, 34, 34, 34, 34, 34, 189, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T53[] =
    {
	34, 34, 214, 27, 34, 34, 34, 34, 34, 34, 34, 34, 214, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T54[] =
    {
	34, 34, 297, 27, 34, 34, 34, 34, 34, 264, 34, 34, 297, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T55[] =
    {
	34, 34, 248, 27, 34, 34, 34, 34, 34, 210, 34, 34, 248, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T56[] =
    {
	34, 48, 34, 42, 34, 71, 34, 34, 34, 147, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 102, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T57[] =
    {
	34, 34, 239, 27, 34, 34, 34, 34, 34, 200, 34, 34, 239, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 202, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T58[] =
    {
	34, 34, 146, 27, 34, 34, 34, 34, 34, 97, 34, 34, 146, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 99, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T59[] =
    {
	34, 34, 324, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 325, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T60[] =
    {
	34, 34, 313, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 314, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T61[] =
    {
	34, 34, 229, 27, 230, 40, 40, 40, 258, 227, 34, 232, 228, 228, 34, 34, 
	230, 230, 34, 34, 51, 40, 232, 232, 230, 230, 223, 223, 34, 223, 231, 34, 
	34, 34, 34, 230, 230, 230, 230
    };static const ANTLR3_INT32 dfa11_T62[] =
    {
	34, 34, 83, 27, 84, 40, 40, 40, 126, 81, 34, 86, 82, 82, 34, 34, 84, 84, 
	34, 34, 51, 40, 86, 86, 84, 84, 87, 87, 34, 87, 85, 34, 34, 34, 34, 84, 
	84, 84, 84
    };static const ANTLR3_INT32 dfa11_T63[] =
    {
	34, 34, 58, 27, 38, 40, 40, 40, 40, 56, 34, 40, 57, 57, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 38, 38, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T64[] =
    {
	34, 48, 161, 42, 166, 71, 70, 158, 67, 158, 34, 164, 160, 160, 34, 34, 
	166, 166, 34, 34, 51, 163, 165, 102, 162, 166, 158, 158, 34, 34, 167, 34, 
	34, 34, 34, 166, 166, 166, 166
    };static const ANTLR3_INT32 dfa11_T65[] =
    {
	34, 34, 267, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 263, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T66[] =
    {
	34, 34, 213, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 208, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T67[] =
    {
	34, 34, 299, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 263, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T68[] =
    {
	34, 34, 250, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 208, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T69[] =
    {
	34, 34, 308, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 309, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T70[] =
    {
	34, 34, 270, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 271, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T71[] =
    {
	34, 48, 317, 42, 34, 71, 34, 34, 34, 133, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 102, 198, 139, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T72[] =
    {
	34, 34, 168, 27, 34, 34, 34, 34, 34, 34, 34, 34, 168, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T73[] =
    {
	34, 48, 64, 42, 65, 71, 70, 34, 67, 34, 34, 68, 63, 63, 34, 34, 65, 65, 
	34, 34, 51, 66, 69, 102, 65, 65, 34, 34, 34, 34, 34, 34, 34, 34, 34, 65, 
	65, 65, 65
    };static const ANTLR3_INT32 dfa11_T74[] =
    {
	34, 34, 296, 27, 34, 34, 34, 34, 34, 34, 34, 34, 297, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T75[] =
    {
	34, 34, 265, 27, 34, 34, 34, 34, 34, 34, 34, 34, 266, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T76[] =
    {
	34, 34, 247, 27, 34, 34, 34, 34, 34, 34, 34, 34, 248, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T77[] =
    {
	34, 34, 211, 27, 34, 34, 34, 34, 34, 34, 34, 34, 212, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T78[] =
    {
	34, 34, 282, 42, 283, 34, 34, 34, 34, 279, 34, 279, 281, 281, 34, 34, 283, 
	283, 34, 34, 34, 193, 279, 279, 283, 283, 279, 279, 34, 279, 280, 34, 34, 
	34, 34, 283, 283, 283, 283
    };static const ANTLR3_INT32 dfa11_T79[] =
    {
	34, 48, 105, 42, 106, 71, 34, 80, 118, 80, 34, 80, 104, 104, 34, 34, 106, 
	106, 34, 34, 34, 80, 80, 102, 103, 106, 80, 80, 34, 34, 107, 34, 34, 34, 
	34, 106, 106, 106, 106
    };static const ANTLR3_INT32 dfa11_T80[] =
    {
	34, 34, 175, 42, 176, 34, 70, 34, 67, 180, 34, 173, 174, 174, 34, 34, 176, 
	176, 34, 34, 51, 178, 179, 180, 176, 176, 180, 180, 34, 180, 177, 34, 34, 
	34, 34, 176, 176, 176, 176
    };static const ANTLR3_INT32 dfa11_T81[] =
    {
	34, 34, 93, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 94, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T82[] =
    {
	34, 48, 154, 42, 159, 49, 40, 157, 40, 152, 34, 157, 153, 153, 34, 34, 
	159, 159, 34, 34, 51, 157, 157, 50, 155, 159, 158, 158, 34, 34, 156, 34, 
	34, 34, 34, 159, 159, 159, 159
    };static const ANTLR3_INT32 dfa11_T83[] =
    {
	34, 34, 262, 27, 34, 34, 34, 34, 34, 200, 34, 34, 239, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 202, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T84[] =
    {
	34, 34, 207, 27, 34, 34, 34, 34, 34, 97, 34, 34, 146, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 99, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T85[] =
    {
	7, 2, -1, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, -1, -1, 3, 3, -1, -1, -1, 
	-1, -1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa11_T86[] =
    {
	34, 34, 266, 27, 34, 34, 34, 34, 34, 241, 34, 34, 266, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T87[] =
    {
	34, 34, 212, 27, 34, 34, 34, 34, 34, 149, 34, 34, 212, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T88[] =
    {
	34, 34, 196, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 140, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T89[] =
    {
	34, 34, 297, 27, 34, 34, 34, 34, 34, 264, 34, 34, 297, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T90[] =
    {
	34, 34, 248, 27, 34, 34, 34, 34, 34, 210, 34, 34, 248, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T91[] =
    {
	-1
    };static const ANTLR3_INT32 dfa11_T92[] =
    {
	34, 34, 234, 27, 235, 34, 34, 34, 255, 223, 34, 223, 233, 233, 34, 34, 
	235, 235, 34, 34, 34, 34, 223, 223, 235, 235, 223, 223, 34, 223, 224, 34, 
	34, 34, 34, 235, 235, 235, 235
    };static const ANTLR3_INT32 dfa11_T93[] =
    {
	34, 34, 130, 27, 131, 34, 34, 34, 128, 87, 34, 87, 129, 129, 34, 34, 131, 
	131, 34, 34, 34, 34, 87, 87, 131, 131, 87, 87, 34, 87, 125, 34, 34, 34, 
	34, 131, 131, 131, 131
    };static const ANTLR3_INT32 dfa11_T94[] =
    {
	34, 34, 266, 27, 34, 34, 34, 34, 34, 241, 34, 34, 266, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T95[] =
    {
	34, 34, 212, 27, 34, 34, 34, 34, 34, 149, 34, 34, 212, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T96[] =
    {
	34, 34, 260, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 237, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T97[] =
    {
	34, 34, 306, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 293, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T98[] =
    {
	34, 48, 62, 42, 38, 49, 40, 40, 40, 47, 34, 40, 36, 36, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 50, 38, 38, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T99[] =
    {
	34, 34, 161, 27, 166, 34, 70, 158, 67, 158, 34, 164, 160, 160, 34, 34, 
	166, 166, 34, 34, 51, 163, 165, 34, 162, 166, 158, 158, 34, 34, 167, 34, 
	34, 34, 34, 166, 166, 166, 166
    };static const ANTLR3_INT32 dfa11_T100[] =
    {
	34, 34, 197, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 293, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T101[] =
    {
	34, 34, 197, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 140, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T102[] =
    {
	34, 34, 60, 27, 34, 34, 34, 34, 34, 97, 34, 34, 60, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 99, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T103[] =
    {
	34, 34, 141, 27, 34, 34, 34, 34, 34, 200, 34, 34, 141, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 202, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T104[] =
    {
	34, 34, 197, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 237, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T105[] =
    {
	34, 34, 194, 27, 34, 34, 34, 34, 34, 34, 34, 34, 88, 88, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T106[] =
    {
	34, 72, 105, 42, 106, 71, 34, 80, 34, 80, 34, 80, 104, 104, 34, 34, 106, 
	106, 34, 34, 34, 80, 80, 102, 103, 106, 80, 80, 34, 34, 107, 34, 34, 34, 
	34, 106, 106, 106, 106
    };static const ANTLR3_INT32 dfa11_T107[] =
    {
	34, 34, 37, 27, 38, 40, 40, 40, 40, 34, 34, 40, 36, 36, 34, 34, 38, 38, 
	34, 34, 34, 40, 40, 40, 38, 38, 41, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T108[] =
    {
	34, 34, 203, 27, 34, 34, 34, 34, 34, 241, 34, 34, 203, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T109[] =
    {
	34, 34, 100, 27, 34, 34, 34, 34, 34, 149, 34, 34, 100, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T110[] =
    {
	34, 34, 311, 27, 34, 34, 34, 34, 34, 241, 34, 34, 266, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T111[] =
    {
	34, 34, 273, 27, 34, 34, 34, 34, 34, 149, 34, 34, 212, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T112[] =
    {
	34, 34, 234, 27, 235, 34, 34, 34, 34, 223, 34, 223, 233, 233, 34, 34, 235, 
	235, 34, 34, 34, 34, 223, 223, 235, 235, 223, 223, 34, 223, 224, 34, 34, 
	34, 34, 235, 235, 235, 235
    };static const ANTLR3_INT32 dfa11_T113[] =
    {
	34, 34, 304, 27, 34, 34, 34, 34, 34, 34, 34, 34, 304, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T114[] =
    {
	34, 34, 256, 27, 34, 34, 34, 34, 34, 34, 34, 34, 256, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T115[] =
    {
	34, 34, 59, 27, 34, 34, 34, 34, 34, 34, 34, 34, 59, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T116[] =
    {
	34, 34, 181, 27, 34, 34, 34, 34, 34, 34, 34, 34, 181, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T117[] =
    {
	34, 34, 216, 27, 34, 34, 34, 34, 34, 34, 34, 34, 216, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T118[] =
    {
	34, 34, 217, 27, 34, 34, 34, 34, 34, 34, 34, 34, 217, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T119[] =
    {
	34, 34, 34, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T120[] =
    {
	34, 34, 130, 27, 131, 34, 34, 34, 34, 87, 34, 87, 129, 129, 34, 34, 131, 
	131, 34, 34, 34, 34, 87, 87, 131, 131, 87, 87, 34, 87, 125, 34, 34, 34, 
	34, 131, 131, 131, 131
    };static const ANTLR3_INT32 dfa11_T121[] =
    {
	34, 34, 305, 27, 34, 34, 34, 34, 34, 34, 34, 34, 305, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T122[] =
    {
	34, 34, 259, 27, 34, 34, 34, 34, 34, 34, 34, 34, 259, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T123[] =
    {
	34, 34, 127, 27, 34, 34, 34, 34, 34, 34, 34, 34, 127, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T124[] =
    {
	34, 34, 151, 27, 34, 34, 34, 34, 34, 34, 34, 34, 151, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T125[] =
    {
	34, 34, 215, 27, 34, 34, 34, 34, 34, 34, 34, 34, 215, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T126[] =
    {
	34, 34, 226, 27, 34, 34, 34, 34, 34, 34, 34, 34, 226, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T127[] =
    {
	34, 34, 29, 27, 30, 34, 34, 34, 34, 34, 34, 32, 28, 28, 34, 34, 30, 30, 
	34, 34, 34, 34, 34, 34, 30, 30, 34, 34, 34, 34, 31, 33, 34, 34, 34, 30, 
	30, 30, 30
    };static const ANTLR3_INT32 dfa11_T128[] =
    {
	9, -1, 10, -1, -1, -1, -1, -1, -1, 12, 8, 8, -1, -1, 10, 10, -1, -1, -1, 
	-1, -1, -1, 10, 10, -1, -1, -1, -1, 11, 13, -1, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa11_T129[] =
    {
	34, 34, 320, 27, 34, 34, 34, 34, 34, 264, 34, 34, 297, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T130[] =
    {
	34, 34, 303, 27, 34, 34, 34, 34, 34, 210, 34, 34, 248, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T131[] =
    {
	34, 34, 206, 27, 38, 40, 40, 40, 40, 56, 34, 40, 36, 36, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 38, 38, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T132[] =
    {
	34, 34, 319, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T133[] =
    {
	34, 34, 302, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T134[] =
    {
	34, 34, 328, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T135[] =
    {
	34, 34, 322, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T136[] =
    {
	34, 34, 269, 27, 38, 40, 40, 40, 40, 56, 34, 40, 36, 36, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 38, 38, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T137[] =
    {
	34, 34, 243, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 244, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T138[] =
    {
	34, 34, 143, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 144, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T139[] =
    {
	34, 34, 92, 27, 38, 40, 40, 40, 40, 56, 34, 40, 36, 36, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 38, 38, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T140[] =
    {
	34, 34, 52, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 53, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T141[] =
    {
	34, 34, 141, 27, 34, 34, 34, 34, 34, 34, 34, 34, 141, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 142, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T142[] =
    {
	34, 34, 60, 27, 34, 34, 34, 34, 34, 34, 34, 34, 60, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 61, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T143[] =
    {
	34, 34, 298, 27, 34, 34, 34, 34, 34, 241, 34, 34, 266, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T144[] =
    {
	34, 34, 249, 27, 34, 34, 34, 34, 34, 149, 34, 34, 212, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T145[] =
    {
	34, 34, 315, 27, 34, 34, 34, 34, 34, 34, 34, 34, 315, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T146[] =
    {
	34, 34, 284, 27, 34, 34, 34, 34, 34, 34, 34, 34, 284, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T147[] =
    {
	34, 34, 253, 27, 34, 34, 34, 34, 34, 34, 34, 34, 253, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T148[] =
    {
	34, 34, 252, 27, 34, 34, 34, 34, 34, 34, 34, 34, 252, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T149[] =
    {
	34, 34, 96, 27, 34, 34, 34, 34, 34, 34, 34, 34, 96, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T150[] =
    {
	34, 34, 225, 27, 34, 34, 34, 34, 34, 34, 34, 34, 225, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T151[] =
    {
	34, 34, 294, 27, 34, 34, 34, 34, 34, 200, 34, 34, 239, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 202, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T152[] =
    {
	34, 34, 245, 27, 34, 34, 34, 34, 34, 97, 34, 34, 146, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 99, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T153[] =
    {
	34, 48, 197, 42, 34, 71, 34, 34, 34, 133, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 102, 198, 139, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T154[] =
    {
	34, 34, 199, 27, 34, 34, 34, 34, 34, 34, 34, 34, 88, 88, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T155[] =
    {
	34, 34, 310, 27, 34, 34, 34, 34, 34, 264, 34, 34, 297, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 263, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T156[] =
    {
	34, 34, 272, 27, 34, 34, 34, 34, 34, 210, 34, 34, 248, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 208, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T157[] =
    {
	34, 34, 195, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T158[] =
    {
	34, 34, 209, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T159[] =
    {
	34, 34, 240, 27, 34, 34, 34, 34, 34, 264, 34, 34, 240, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T160[] =
    {
	34, 34, 148, 27, 34, 34, 34, 34, 34, 210, 34, 34, 148, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T161[] =
    {
	34, 48, 323, 42, 34, 71, 34, 34, 34, 133, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 102, 198, 139, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T162[] =
    {
	34, 48, 105, 42, 106, 71, 34, 80, 34, 80, 34, 80, 104, 104, 34, 34, 106, 
	106, 34, 34, 34, 80, 80, 102, 103, 106, 80, 80, 34, 34, 107, 34, 34, 34, 
	34, 106, 106, 106, 106
    };static const ANTLR3_INT32 dfa11_T163[] =
    {
	34, 34, 34, 27, 34, 71, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T164[] =
    {
	34, 34, 117, 27, 34, 34, 34, 34, 34, 34, 34, 34, 117, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T165[] =
    {
	34, 34, 261, 27, 34, 34, 34, 34, 34, 34, 34, 34, 88, 88, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T166[] =
    {
	34, 34, 295, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T167[] =
    {
	34, 34, 246, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T168[] =
    {
	34, 34, 307, 27, 34, 34, 34, 34, 34, 34, 34, 34, 88, 88, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T169[] =
    {
	2, -1, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, -1, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa11_T170[] =
    {
	34, 48, 194, 42, 34, 71, 34, 34, 34, 133, 34, 34, 88, 88, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 102, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T171[] =
    {
	34, 34, 268, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 244, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T172[] =
    {
	34, 34, 205, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 144, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T173[] =
    {
	15
    };static const ANTLR3_INT32 dfa11_T174[] =
    {
	34, 34, 91, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 53, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T175[] =
    {
	34, 34, 135, 27, 34, 34, 34, 34, 34, 34, 34, 34, 134, 134, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 136, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T176[] =
    {
	34, 34, 29, 27, 30, 34, 34, 34, 34, 35, 34, 32, 28, 28, 34, 34, 30, 30, 
	34, 34, 34, 34, 34, 34, 30, 30, 34, 34, 34, 34, 31, 33, 34, 34, 34, 30, 
	30, 30, 30
    };static const ANTLR3_INT32 dfa11_T177[] =
    {
	34, 48, 312, 42, 38, 49, 40, 40, 40, 47, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 50, 94, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T178[] =
    {
	34, 34, 219, 27, 220, 34, 70, 34, 67, 223, 34, 221, 218, 218, 34, 34, 220, 
	220, 34, 34, 51, 66, 222, 223, 220, 220, 223, 223, 34, 223, 224, 34, 34, 
	34, 34, 220, 220, 220, 220
    };static const ANTLR3_INT32 dfa11_T179[] =
    {
	34, 34, 44, 27, 38, 40, 40, 40, 40, 56, 34, 40, 43, 43, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 38, 45, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T180[] =
    {
	16, 18, 24, 20, -1, -1, -1, -1, -1, -1, 22, 17, 19, -1, -1, 20, 20, -1, 
	-1, -1, -1, -1, -1, 20, 20, -1, -1, -1, -1, 21, 23, -1, -1, -1, 20, 20, 
	20, 20
    };static const ANTLR3_INT32 dfa11_T181[] =
    {
	34, 34, 240, 27, 34, 34, 34, 34, 34, 204, 34, 34, 240, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T182[] =
    {
	34, 34, 148, 27, 34, 34, 34, 34, 34, 101, 34, 34, 148, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T183[] =
    {
	34, 34, 197, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T184[] =
    {
	34, 34, 62, 27, 38, 40, 40, 40, 40, 56, 34, 40, 36, 36, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 38, 38, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T185[] =
    {
	34, 34, 93, 27, 38, 40, 40, 40, 40, 56, 34, 40, 54, 54, 34, 34, 38, 38, 
	34, 34, 51, 40, 40, 40, 38, 55, 34, 34, 34, 34, 39, 34, 34, 34, 34, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa11_T186[] =
    {
	18, 24, 20, -1, -1, -1, -1, -1, -1, 22, 17, 19, -1, -1, 20, 20, -1, -1, 
	-1, -1, -1, -1, 20, 20, -1, -1, -1, -1, 21, 23, -1, -1, -1, 20, 20, 20, 
	20
    };static const ANTLR3_INT32 dfa11_T187[] =
    {
	34, 34, 238, 27, 34, 34, 34, 34, 34, 34, 34, 34, 239, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T188[] =
    {
	34, 34, 145, 27, 34, 34, 34, 34, 34, 34, 34, 34, 146, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T189[] =
    {
	34, 34, 64, 27, 65, 34, 70, 34, 67, 34, 34, 68, 63, 63, 34, 34, 65, 65, 
	34, 34, 51, 66, 69, 34, 65, 65, 34, 34, 34, 34, 34, 34, 34, 34, 34, 65, 
	65, 65, 65
    };static const ANTLR3_INT32 dfa11_T190[] =
    {
	34, 34, 292, 27, 34, 34, 34, 34, 34, 34, 34, 34, 138, 138, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 293, 139, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34
    };static const ANTLR3_INT32 dfa11_T191[] =
    {
	34, 34, 154, 27, 159, 40, 40, 157, 40, 152, 34, 157, 153, 153, 34, 34, 
	159, 159, 34, 34, 51, 157, 157, 40, 155, 159, 158, 158, 34, 34, 156, 34, 
	34, 34, 34, 159, 159, 159, 159
    };static const ANTLR3_INT32 dfa11_T192[] =
    {
	34, 72, 75, 42, 77, 49, 40, 79, 40, 76, 34, 79, 74, 74, 34, 34, 77, 77, 
	34, 34, 51, 79, 79, 50, 73, 77, 80, 80, 34, 34, 78, 34, 34, 34, 34, 77, 
	77, 77, 77
    };static const ANTLR3_INT32 dfa11_T193[] =
    {
	34, 34, 331, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 201, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };static const ANTLR3_INT32 dfa11_T194[] =
    {
	34, 34, 329, 27, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 98, 34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa11_transitions[] =
{
    dfa11_T169, dfa11_T85, dfa11_T85, dfa11_T85, dfa11_T85, dfa11_T85, dfa11_T85, 
    dfa11_T128, dfa11_T13, dfa11_T13, dfa11_T13, dfa11_T13, dfa11_T13, dfa11_T13, 
    dfa11_T173, dfa11_T180, dfa11_T186, dfa11_T91, dfa11_T91, dfa11_T91, 
    dfa11_T91, dfa11_T91, dfa11_T91, dfa11_T91, dfa11_T127, dfa11_T_empty, 
    dfa11_T_empty, dfa11_T91, dfa11_T176, dfa11_T176, dfa11_T176, dfa11_T176, 
    dfa11_T176, dfa11_T176, dfa11_T119, dfa11_T107, dfa11_T39, dfa11_T140, 
    dfa11_T63, dfa11_T115, dfa11_T63, dfa11_T142, dfa11_T91, dfa11_T39, 
    dfa11_T39, dfa11_T179, dfa11_T98, dfa11_T189, dfa11_T163, dfa11_T192, 
    dfa11_T15, dfa11_T5, dfa11_T174, dfa11_T139, dfa11_T81, dfa11_T185, 
    dfa11_T37, dfa11_T63, dfa11_T63, dfa11_T149, dfa11_T102, dfa11_T43, 
    dfa11_T81, dfa11_T37, dfa11_T73, dfa11_T37, dfa11_T37, dfa11_T37, dfa11_T37, 
    dfa11_T37, dfa11_T37, dfa11_T106, dfa11_T162, dfa11_T1, dfa11_T1, dfa11_T1, 
    dfa11_T22, dfa11_T1, dfa11_T164, dfa11_T1, dfa11_T79, dfa11_T33, dfa11_T62, 
    dfa11_T62, dfa11_T62, dfa11_T123, dfa11_T62, dfa11_T93, dfa11_T17, dfa11_T14, 
    dfa11_T141, dfa11_T38, dfa11_T138, dfa11_T81, dfa11_T184, dfa11_T37, 
    dfa11_T63, dfa11_T188, dfa11_T56, dfa11_T182, dfa11_T109, dfa11_T7, 
    dfa11_T120, dfa11_T79, dfa11_T79, dfa11_T79, dfa11_T79, dfa11_T124, 
    dfa11_T191, dfa11_T22, dfa11_T22, dfa11_T22, dfa11_T22, dfa11_T99, dfa11_T22, 
    dfa11_T22, dfa11_T22, dfa11_T72, dfa11_T25, dfa11_T33, dfa11_T33, dfa11_T33, 
    dfa11_T80, dfa11_T33, dfa11_T33, dfa11_T116, dfa11_T36, dfa11_T52, dfa11_T27, 
    dfa11_T93, dfa11_T93, dfa11_T93, dfa11_T170, dfa11_T157, dfa11_T17, 
    dfa11_T17, dfa11_T175, dfa11_T88, dfa11_T28, dfa11_T183, dfa11_T154, 
    dfa11_T103, dfa11_T44, dfa11_T172, dfa11_T131, dfa11_T84, dfa11_T31, 
    dfa11_T158, dfa11_T160, dfa11_T77, dfa11_T66, dfa11_T53, dfa11_T64, 
    dfa11_T82, dfa11_T82, dfa11_T82, dfa11_T125, dfa11_T82, dfa11_T8, dfa11_T82, 
    dfa11_T64, dfa11_T64, dfa11_T64, dfa11_T64, dfa11_T64, dfa11_T64, dfa11_T64, 
    dfa11_T117, dfa11_T1, dfa11_T8, dfa11_T8, dfa11_T8, dfa11_T8, dfa11_T80, 
    dfa11_T80, dfa11_T80, dfa11_T80, dfa11_T118, dfa11_T178, dfa11_T80, 
    dfa11_T27, dfa11_T150, dfa11_T80, dfa11_T36, dfa11_T36, dfa11_T36, dfa11_T126, 
    dfa11_T9, dfa11_T36, dfa11_T62, dfa11_T27, dfa11_T27, dfa11_T27, dfa11_T112, 
    dfa11_T28, dfa11_T16, dfa11_T101, dfa11_T28, dfa11_T105, dfa11_T18, 
    dfa11_T187, dfa11_T45, dfa11_T181, dfa11_T108, dfa11_T6, dfa11_T40, 
    dfa11_T137, dfa11_T152, dfa11_T167, dfa11_T12, dfa11_T76, dfa11_T144, 
    dfa11_T95, dfa11_T68, dfa11_T79, dfa11_T51, dfa11_T148, dfa11_T147, 
    dfa11_T32, dfa11_T32, dfa11_T32, dfa11_T32, dfa11_T32, dfa11_T92, dfa11_T114, 
    dfa11_T93, dfa11_T50, dfa11_T32, dfa11_T61, dfa11_T61, dfa11_T61, dfa11_T122, 
    dfa11_T61, dfa11_T92, dfa11_T92, dfa11_T92, dfa11_T96, dfa11_T165, dfa11_T83, 
    dfa11_T30, dfa11_T159, dfa11_T75, dfa11_T65, dfa11_T171, dfa11_T136, 
    dfa11_T58, dfa11_T70, dfa11_T156, dfa11_T55, dfa11_T111, dfa11_T20, 
    dfa11_T82, dfa11_T8, dfa11_T27, dfa11_T26, dfa11_T78, dfa11_T146, dfa11_T36, 
    dfa11_T4, dfa11_T49, dfa11_T104, dfa11_T190, dfa11_T151, dfa11_T166, 
    dfa11_T74, dfa11_T143, dfa11_T94, dfa11_T67, dfa11_T0, dfa11_T29, dfa11_T42, 
    dfa11_T133, dfa11_T130, dfa11_T87, dfa11_T26, dfa11_T26, dfa11_T26, 
    dfa11_T26, dfa11_T26, dfa11_T78, dfa11_T113, dfa11_T78, dfa11_T78, dfa11_T78, 
    dfa11_T92, dfa11_T26, dfa11_T4, dfa11_T4, dfa11_T4, dfa11_T121, dfa11_T4, 
    dfa11_T61, dfa11_T97, dfa11_T168, dfa11_T57, dfa11_T69, dfa11_T155, 
    dfa11_T54, dfa11_T110, dfa11_T19, dfa11_T177, dfa11_T24, dfa11_T60, 
    dfa11_T90, dfa11_T145, dfa11_T48, dfa11_T100, dfa11_T71, dfa11_T41, 
    dfa11_T132, dfa11_T129, dfa11_T86, dfa11_T21, dfa11_T47, dfa11_T135, 
    dfa11_T78, dfa11_T4, dfa11_T161, dfa11_T23, dfa11_T59, dfa11_T89, dfa11_T11, 
    dfa11_T35, dfa11_T153, dfa11_T46, dfa11_T134, dfa11_T194, dfa11_T10, 
    dfa11_T34, dfa11_T3, dfa11_T193, dfa11_T2	
};

static ANTLR3_INT32 dfa11_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA11_42;

    	    ANTLR3_MARKER index11_42;


    		LA11_42 = LA(1);

    	 
    	    index11_42 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_42);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA11_20;

    	    ANTLR3_MARKER index11_20;


    		LA11_20 = LA(1);

    	 
    	    index11_20 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_20);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA11_18;

    	    ANTLR3_MARKER index11_18;


    		LA11_18 = LA(1);

    	 
    	    index11_18 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_18);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA11_19;

    	    ANTLR3_MARKER index11_19;


    		LA11_19 = LA(1);

    	 
    	    index11_19 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_19);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA11_17;

    	    ANTLR3_MARKER index11_17;


    		LA11_17 = LA(1);

    	 
    	    index11_17 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_17);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA11_27;

    	    ANTLR3_MARKER index11_27;


    		LA11_27 = LA(1);

    	 
    	    index11_27 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_27);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA11_23;

    	    ANTLR3_MARKER index11_23;


    		LA11_23 = LA(1);

    	 
    	    index11_23 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_23);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA11_21;

    	    ANTLR3_MARKER index11_21;


    		LA11_21 = LA(1);

    	 
    	    index11_21 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_21);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 8:
        
    	{
    	    ANTLR3_UINT32 LA11_22;

    	    ANTLR3_MARKER index11_22;


    		LA11_22 = LA(1);

    	 
    	    index11_22 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 26;
    	    }

    	 
    		SEEK(index11_22);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"281:1: credentials[belle_sip_header_authorization_t* header_authorization_base] : ( ( digest_token LWS digest_response[header_authorization_base] ) | other_response[header_authorization_base] );";
    EXCEPTION->decisionNum  = 11;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 11
 */
static
ANTLR3_CYCLIC_DFA cdfa11
    =	{
	    11,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"281:1: credentials[belle_sip_header_authorization_t* header_authorization_base] : ( ( digest_token LWS digest_response[header_authorization_base] ) | other_response[header_authorization_base] );",	
	    (CDFA_SPECIAL_FUNC) dfa11_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa11_eot,	    /* EOT table			    */
	    dfa11_eof,	    /* EOF table			    */
	    dfa11_min,	    /* Minimum tokens for each state    */
	    dfa11_max,	    /* Maximum tokens for each state    */
	    dfa11_accept,	/* Accept table			    */
	    dfa11_special,	/* Special transition states	    */
	    dfa11_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 11
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    287:1: dig_resp[belle_sip_header_authorization_t* header_authorization_base] : ( username | realm | nonce | digest_uri[header_authorization_base] | dresponse | algorithm | cnonce | opaque | message_qop | nonce_count | auth_param[header_authorization_base] );
 */
static const ANTLR3_INT32 dfa13_eot[334] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa13_eof[334] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa13_min[334] =
    {
	6, 5, 5, 5, 5, 5, 5, 12, 5, 6, 4, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 
	0, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4
    };
static const ANTLR3_INT32 dfa13_max[334] =
    {
	42, 42, 42, 42, 42, 42, 42, 12, 42, 42, 42, 0, 0, 0, 0, 0, 0, 0, 42, 42, 
	42, 42, 42, 42, 0, 42, -1, -1, -1, -1, 42, -1, -1, -1, -1, -1, -1, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, -1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42
    };
static const ANTLR3_INT32 dfa13_accept[334] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 6, 9, 10, 11, -1, 1, 2, 3, 5, 7, 8, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa13_special[334] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 0, 6, 4, 5, 3, -1, -1, 
	-1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa13_T_empty	    NULL

static const ANTLR3_INT32 dfa13_T0[] =
    {
	25, 25, 238, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 239, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T1[] =
    {
	25, 25, 139, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 142, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T2[] =
    {
	25, 49, 44, 46, 39, 50, 41, 41, 41, 48, 25, 41, 43, 43, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 51, 47, 45, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T3[] =
    {
	25, 25, 221, 24, 222, 25, 72, 25, 256, 225, 25, 223, 220, 220, 25, 25, 
	222, 222, 25, 25, 52, 68, 224, 225, 222, 222, 225, 225, 25, 225, 226, 25, 
	25, 25, 25, 222, 222, 222, 222
    };static const ANTLR3_INT32 dfa13_T4[] =
    {
	25, 25, 122, 24, 123, 25, 72, 25, 124, 89, 25, 125, 121, 121, 25, 25, 123, 
	123, 25, 25, 52, 68, 126, 89, 123, 123, 89, 89, 25, 89, 127, 25, 25, 25, 
	25, 123, 123, 123, 123
    };static const ANTLR3_INT32 dfa13_T5[] =
    {
	25, 25, 294, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 295, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T6[] =
    {
	25, 49, 173, 46, 174, 73, 25, 162, 25, 162, 25, 162, 172, 172, 25, 25, 
	174, 174, 25, 25, 25, 162, 162, 104, 171, 174, 162, 162, 25, 25, 159, 25, 
	25, 25, 25, 174, 174, 174, 174
    };static const ANTLR3_INT32 dfa13_T7[] =
    {
	25, 25, 93, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 56, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T8[] =
    {
	25, 25, 299, 24, 25, 25, 25, 25, 25, 266, 25, 25, 299, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T9[] =
    {
	25, 25, 250, 24, 25, 25, 25, 25, 25, 212, 25, 25, 250, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T10[] =
    {
	25, 25, 296, 24, 25, 25, 25, 25, 25, 202, 25, 25, 241, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 204, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T11[] =
    {
	25, 25, 247, 24, 25, 25, 25, 25, 25, 99, 25, 25, 148, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 101, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T12[] =
    {
	25, 25, 199, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T13[] =
    {
	25, 25, 298, 24, 25, 25, 25, 25, 25, 25, 25, 25, 299, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T14[] =
    {
	25, 25, 267, 24, 25, 25, 25, 25, 25, 25, 25, 25, 268, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T15[] =
    {
	25, 25, 249, 24, 25, 25, 25, 25, 25, 25, 25, 25, 250, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T16[] =
    {
	25, 25, 213, 24, 25, 25, 25, 25, 25, 25, 25, 25, 214, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T17[] =
    {
	25, 49, 107, 46, 108, 73, 25, 81, 25, 81, 25, 81, 106, 106, 25, 25, 108, 
	108, 25, 25, 25, 81, 81, 104, 105, 108, 81, 81, 25, 25, 109, 25, 25, 25, 
	25, 108, 108, 108, 108
    };static const ANTLR3_INT32 dfa13_T18[] =
    {
	25, 25, 284, 46, 285, 25, 25, 25, 25, 282, 25, 282, 283, 283, 25, 25, 285, 
	285, 25, 25, 25, 195, 282, 282, 285, 285, 282, 282, 25, 282, 280, 25, 25, 
	25, 25, 285, 285, 285, 285
    };static const ANTLR3_INT32 dfa13_T19[] =
    {
	25, 25, 196, 24, 25, 25, 25, 25, 25, 25, 25, 25, 90, 90, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T20[] =
    {
	25, 25, 201, 24, 25, 25, 25, 25, 25, 25, 25, 25, 90, 90, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T21[] =
    {
	25, 25, 300, 24, 25, 25, 25, 25, 25, 243, 25, 25, 268, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T22[] =
    {
	25, 25, 251, 24, 25, 25, 25, 25, 25, 151, 25, 25, 214, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T23[] =
    {
	25, 25, 263, 24, 25, 25, 25, 25, 25, 25, 25, 25, 90, 90, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T24[] =
    {
	25, 49, 76, 46, 82, 50, 41, 79, 118, 74, 25, 79, 75, 75, 25, 25, 82, 82, 
	25, 25, 52, 79, 79, 51, 77, 82, 81, 81, 25, 25, 78, 25, 25, 25, 25, 82, 
	82, 82, 82
    };static const ANTLR3_INT32 dfa13_T25[] =
    {
	25, 25, 309, 24, 25, 25, 25, 25, 25, 25, 25, 25, 90, 90, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T26[] =
    {
	25, 25, 278, 46, 279, 25, 72, 25, 69, 282, 25, 276, 277, 277, 25, 25, 279, 
	279, 25, 25, 52, 180, 281, 282, 279, 279, 282, 282, 25, 282, 280, 25, 25, 
	25, 25, 279, 279, 279, 279
    };static const ANTLR3_INT32 dfa13_T27[] =
    {
	25, 25, 173, 24, 174, 25, 25, 162, 25, 162, 25, 162, 172, 172, 25, 25, 
	174, 174, 25, 25, 25, 162, 162, 25, 171, 174, 162, 162, 25, 25, 159, 25, 
	25, 25, 25, 174, 174, 174, 174
    };static const ANTLR3_INT32 dfa13_T28[] =
    {
	25, 25, 207, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 146, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T29[] =
    {
	25, 25, 205, 24, 25, 25, 25, 25, 25, 243, 25, 25, 205, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T30[] =
    {
	25, 25, 102, 24, 25, 25, 25, 25, 25, 151, 25, 25, 102, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T31[] =
    {
	25, 25, 312, 24, 25, 25, 25, 25, 25, 266, 25, 25, 299, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T32[] =
    {
	25, 25, 274, 24, 25, 25, 25, 25, 25, 212, 25, 25, 250, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T33[] =
    {
	25, 25, 270, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 246, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T34[] =
    {
	25, 25, 66, 24, 67, 25, 72, 25, 69, 25, 25, 70, 65, 65, 25, 25, 67, 67, 
	25, 25, 52, 68, 71, 25, 67, 67, 25, 25, 25, 25, 25, 25, 25, 25, 25, 67, 
	67, 67, 67
    };static const ANTLR3_INT32 dfa13_T35[] =
    {
	25, 49, 112, 46, 114, 73, 72, 81, 115, 81, 25, 116, 111, 111, 25, 25, 114, 
	114, 25, 25, 52, 113, 117, 104, 110, 114, 81, 81, 25, 25, 109, 25, 25, 
	25, 25, 114, 114, 114, 114
    };static const ANTLR3_INT32 dfa13_T36[] =
    {
	25, 49, 25, 46, 25, 73, 25, 25, 25, 149, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 104, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T37[] =
    {
	25, 49, 25, 46, 25, 73, 25, 25, 25, 135, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 104, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T38[] =
    {
	25, 25, 242, 24, 25, 25, 25, 25, 25, 266, 25, 25, 242, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T39[] =
    {
	25, 25, 150, 24, 25, 25, 25, 25, 25, 212, 25, 25, 150, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T40[] =
    {
	25, 25, 19, 24, 20, 25, 25, 25, 25, 30, 25, 22, 18, 18, 25, 25, 20, 20, 
	25, 25, 25, 25, 25, 25, 20, 20, 25, 25, 25, 25, 21, 23, 25, 25, 25, 20, 
	20, 20, 20
    };static const ANTLR3_INT32 dfa13_T41[] =
    {
	25, 49, 95, 46, 39, 50, 41, 41, 41, 48, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 51, 94, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T42[] =
    {
	25, 25, 299, 24, 25, 25, 25, 25, 25, 266, 25, 25, 299, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T43[] =
    {
	25, 25, 250, 24, 25, 25, 25, 25, 25, 212, 25, 25, 250, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T44[] =
    {
	-1
    };static const ANTLR3_INT32 dfa13_T45[] =
    {
	25, 25, 143, 24, 25, 25, 25, 25, 25, 25, 25, 25, 143, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 144, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T46[] =
    {
	12, 10, 13, -1, -1, -1, -1, -1, -1, 15, 11, 17, -1, -1, 13, 13, -1, -1, 
	-1, -1, -1, -1, 13, 13, -1, -1, -1, -1, 14, 16, -1, -1, -1, 13, 13, 13, 
	13
    };static const ANTLR3_INT32 dfa13_T47[] =
    {
	25, 25, 61, 24, 25, 25, 25, 25, 25, 25, 25, 25, 61, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 62, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T48[] =
    {
	25, 25, 165, 24, 166, 41, 41, 169, 41, 167, 25, 169, 164, 164, 25, 25, 
	166, 166, 25, 25, 52, 169, 169, 41, 163, 166, 162, 162, 25, 25, 168, 25, 
	25, 25, 25, 166, 166, 166, 166
    };static const ANTLR3_INT32 dfa13_T49[] =
    {
	25, 25, 85, 24, 86, 41, 41, 41, 41, 83, 25, 88, 84, 84, 25, 25, 86, 86, 
	25, 25, 52, 41, 88, 88, 86, 86, 89, 89, 25, 89, 87, 25, 25, 25, 25, 86, 
	86, 86, 86
    };static const ANTLR3_INT32 dfa13_T50[] =
    {
	25, 25, 177, 46, 178, 25, 72, 25, 69, 182, 25, 175, 176, 176, 25, 25, 178, 
	178, 25, 25, 52, 180, 181, 182, 178, 178, 182, 182, 25, 182, 179, 25, 25, 
	25, 25, 178, 178, 178, 178
    };static const ANTLR3_INT32 dfa13_T51[] =
    {
	25, 49, 165, 46, 166, 50, 41, 169, 41, 167, 25, 169, 164, 164, 25, 25, 
	166, 166, 25, 25, 52, 169, 169, 51, 163, 166, 162, 162, 25, 25, 168, 25, 
	25, 25, 25, 166, 166, 166, 166
    };static const ANTLR3_INT32 dfa13_T52[] =
    {
	25, 25, 241, 24, 25, 25, 25, 25, 25, 202, 25, 25, 241, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 204, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T53[] =
    {
	25, 49, 137, 46, 25, 73, 25, 25, 25, 135, 25, 25, 136, 136, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 104, 134, 138, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T54[] =
    {
	25, 25, 97, 24, 67, 25, 72, 25, 69, 25, 25, 70, 65, 65, 25, 25, 67, 67, 
	25, 25, 52, 68, 71, 25, 67, 67, 25, 25, 25, 25, 25, 25, 25, 25, 25, 67, 
	67, 67, 67
    };static const ANTLR3_INT32 dfa13_T55[] =
    {
	25, 25, 148, 24, 25, 25, 25, 25, 25, 99, 25, 25, 148, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 101, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T56[] =
    {
	25, 25, 59, 24, 39, 41, 41, 41, 41, 57, 25, 41, 58, 58, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 39, 39, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T57[] =
    {
	25, 49, 156, 46, 157, 73, 72, 162, 69, 162, 25, 160, 155, 155, 25, 25, 
	157, 157, 25, 25, 52, 158, 161, 104, 154, 157, 162, 162, 25, 25, 159, 25, 
	25, 25, 25, 157, 157, 157, 157
    };static const ANTLR3_INT32 dfa13_T58[] =
    {
	25, 25, 268, 24, 25, 25, 25, 25, 25, 243, 25, 25, 268, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T59[] =
    {
	25, 25, 214, 24, 25, 25, 25, 25, 25, 151, 25, 25, 214, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T60[] =
    {
	25, 25, 289, 46, 290, 41, 41, 41, 41, 287, 25, 292, 288, 288, 25, 25, 290, 
	290, 25, 25, 52, 189, 292, 292, 290, 290, 282, 282, 25, 282, 291, 25, 25, 
	25, 25, 290, 290, 290, 290
    };static const ANTLR3_INT32 dfa13_T61[] =
    {
	25, 25, 193, 46, 194, 25, 25, 25, 25, 182, 25, 182, 192, 192, 25, 25, 194, 
	194, 25, 25, 25, 195, 182, 182, 194, 194, 182, 182, 25, 182, 179, 25, 25, 
	25, 25, 194, 194, 194, 194
    };static const ANTLR3_INT32 dfa13_T62[] =
    {
	25, 25, 137, 24, 25, 25, 25, 25, 25, 25, 25, 25, 136, 136, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 138, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T63[] =
    {
	25, 25, 307, 24, 25, 25, 25, 25, 25, 25, 25, 25, 307, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T64[] =
    {
	25, 25, 261, 24, 25, 25, 25, 25, 25, 25, 25, 25, 261, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T65[] =
    {
	25, 25, 129, 24, 25, 25, 25, 25, 25, 25, 25, 25, 129, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T66[] =
    {
	25, 25, 153, 24, 25, 25, 25, 25, 25, 25, 25, 25, 153, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T67[] =
    {
	25, 25, 218, 24, 25, 25, 25, 25, 25, 25, 25, 25, 218, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T68[] =
    {
	25, 25, 228, 24, 25, 25, 25, 25, 25, 25, 25, 25, 228, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T69[] =
    {
	25, 25, 95, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 146, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T70[] =
    {
	25, 25, 95, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 246, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T71[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T72[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T73[] =
    {
	25, 25, 332, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T74[] =
    {
	25, 25, 328, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T75[] =
    {
	25, 25, 186, 46, 187, 41, 41, 41, 41, 184, 25, 190, 185, 185, 25, 25, 187, 
	187, 25, 25, 52, 189, 190, 190, 187, 187, 182, 182, 25, 182, 188, 25, 25, 
	25, 25, 187, 187, 187, 187
    };static const ANTLR3_INT32 dfa13_T76[] =
    {
	25, 25, 197, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T77[] =
    {
	25, 25, 211, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T78[] =
    {
	25, 25, 102, 24, 25, 25, 25, 25, 25, 103, 25, 25, 102, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T79[] =
    {
	25, 25, 205, 24, 25, 25, 25, 25, 25, 206, 25, 25, 205, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T80[] =
    {
	25, 25, 236, 24, 237, 25, 25, 25, 257, 225, 25, 225, 235, 235, 25, 25, 
	237, 237, 25, 25, 25, 25, 225, 225, 237, 237, 225, 225, 25, 225, 226, 25, 
	25, 25, 25, 237, 237, 237, 237
    };static const ANTLR3_INT32 dfa13_T81[] =
    {
	25, 49, 107, 46, 108, 73, 25, 81, 120, 81, 25, 81, 106, 106, 25, 25, 108, 
	108, 25, 25, 25, 81, 81, 104, 105, 108, 81, 81, 25, 25, 109, 25, 25, 25, 
	25, 108, 108, 108, 108
    };static const ANTLR3_INT32 dfa13_T82[] =
    {
	25, 25, 132, 24, 133, 25, 25, 25, 130, 89, 25, 89, 131, 131, 25, 25, 133, 
	133, 25, 25, 25, 25, 89, 89, 133, 133, 89, 89, 25, 89, 127, 25, 25, 25, 
	25, 133, 133, 133, 133
    };static const ANTLR3_INT32 dfa13_T83[] =
    {
	9, 12, 10, 13, -1, -1, -1, -1, -1, -1, 15, 11, 17, -1, -1, 13, 13, -1, 
	-1, -1, -1, -1, -1, 13, 13, -1, -1, -1, -1, 14, 16, -1, -1, -1, 13, 13, 
	13, 13
    };static const ANTLR3_INT32 dfa13_T84[] =
    {
	25, 25, 268, 24, 25, 25, 25, 25, 25, 243, 25, 25, 268, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T85[] =
    {
	25, 25, 214, 24, 25, 25, 25, 25, 25, 151, 25, 25, 214, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T86[] =
    {
	25, 25, 241, 24, 25, 25, 25, 25, 25, 202, 25, 25, 241, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 204, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T87[] =
    {
	25, 25, 148, 24, 25, 25, 25, 25, 25, 99, 25, 25, 148, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 101, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T88[] =
    {
	25, 25, 199, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 200, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T89[] =
    {
	25, 25, 301, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 265, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T90[] =
    {
	25, 25, 252, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 210, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T91[] =
    {
	25, 25, 320, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 311, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T92[] =
    {
	25, 25, 303, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 273, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T93[] =
    {
	25, 25, 329, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 327, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T94[] =
    {
	25, 25, 323, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 316, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T95[] =
    {
	25, 25, 231, 24, 232, 41, 41, 41, 260, 229, 25, 234, 230, 230, 25, 25, 
	232, 232, 25, 25, 52, 41, 234, 234, 232, 232, 225, 225, 25, 225, 233, 25, 
	25, 25, 25, 232, 232, 232, 232
    };static const ANTLR3_INT32 dfa13_T96[] =
    {
	25, 25, 85, 24, 86, 41, 41, 41, 128, 83, 25, 88, 84, 84, 25, 25, 86, 86, 
	25, 25, 52, 41, 88, 88, 86, 86, 89, 89, 25, 89, 87, 25, 25, 25, 25, 86, 
	86, 86, 86
    };static const ANTLR3_INT32 dfa13_T97[] =
    {
	25, 25, 242, 24, 25, 25, 25, 25, 25, 206, 25, 25, 242, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T98[] =
    {
	25, 25, 64, 24, 39, 41, 41, 41, 41, 57, 25, 41, 37, 37, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 39, 39, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T99[] =
    {
	25, 25, 150, 24, 25, 25, 25, 25, 25, 103, 25, 25, 150, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T100[] =
    {
	25, 49, 325, 46, 25, 73, 25, 25, 25, 135, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 104, 200, 141, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T101[] =
    {
	25, 25, 244, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T102[] =
    {
	25, 25, 152, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T103[] =
    {
	25, 80, 76, 46, 82, 50, 41, 79, 41, 74, 25, 79, 75, 75, 25, 25, 82, 82, 
	25, 25, 52, 79, 79, 51, 77, 82, 81, 81, 25, 25, 78, 25, 25, 25, 25, 82, 
	82, 82, 82
    };static const ANTLR3_INT32 dfa13_T104[] =
    {
	25, 25, 95, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 56, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T105[] =
    {
	2, -1, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, -1, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa13_T106[] =
    {
	25, 25, 61, 24, 25, 25, 25, 25, 25, 99, 25, 25, 61, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 101, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T107[] =
    {
	25, 25, 143, 24, 25, 25, 25, 25, 25, 202, 25, 25, 143, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 204, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T108[] =
    {
	25, 25, 19, 24, 20, 25, 25, 25, 25, 25, 25, 22, 18, 18, 25, 25, 20, 20, 
	25, 25, 25, 25, 25, 25, 20, 20, 25, 25, 25, 25, 21, 23, 25, 25, 25, 20, 
	20, 20, 20
    };static const ANTLR3_INT32 dfa13_T109[] =
    {
	25, 25, 240, 24, 25, 25, 25, 25, 25, 25, 25, 25, 241, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T110[] =
    {
	25, 25, 147, 24, 25, 25, 25, 25, 25, 25, 25, 25, 148, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T111[] =
    {
	7, 2, -1, 3, -1, -1, -1, 8, -1, -1, 5, 1, 1, -1, -1, 3, 3, -1, -1, -1, 
	-1, -1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa13_T112[] =
    {
	25, 25, 91, 24, 25, 25, 25, 25, 25, 25, 25, 25, 90, 90, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 92, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T113[] =
    {
	25, 25, 199, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 295, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T114[] =
    {
	25, 25, 306, 24, 25, 25, 25, 25, 25, 25, 25, 25, 306, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T115[] =
    {
	25, 25, 258, 24, 25, 25, 25, 25, 25, 25, 25, 25, 258, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T116[] =
    {
	25, 25, 60, 24, 25, 25, 25, 25, 25, 25, 25, 25, 60, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T117[] =
    {
	25, 25, 183, 24, 25, 25, 25, 25, 25, 25, 25, 25, 183, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T118[] =
    {
	25, 25, 217, 24, 25, 25, 25, 25, 25, 25, 25, 25, 217, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T119[] =
    {
	25, 25, 219, 24, 25, 25, 25, 25, 25, 25, 25, 25, 219, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T120[] =
    {
	25, 25, 199, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 239, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T121[] =
    {
	25, 25, 199, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 142, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T122[] =
    {
	25, 25, 221, 24, 222, 25, 72, 25, 69, 225, 25, 223, 220, 220, 25, 25, 222, 
	222, 25, 25, 52, 68, 224, 225, 222, 222, 225, 225, 25, 225, 226, 25, 25, 
	25, 25, 222, 222, 222, 222
    };static const ANTLR3_INT32 dfa13_T123[] =
    {
	25, 25, 170, 24, 25, 25, 25, 25, 25, 25, 25, 25, 170, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T124[] =
    {
	25, 25, 38, 24, 39, 41, 41, 41, 41, 25, 25, 41, 37, 37, 25, 25, 39, 39, 
	25, 25, 25, 41, 41, 41, 39, 39, 42, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T125[] =
    {
	25, 25, 264, 24, 25, 25, 25, 25, 25, 202, 25, 25, 241, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 204, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T126[] =
    {
	25, 25, 209, 24, 25, 25, 25, 25, 25, 99, 25, 25, 148, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 101, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T127[] =
    {
	25, 49, 66, 46, 67, 73, 72, 25, 69, 25, 25, 70, 65, 65, 25, 25, 67, 67, 
	25, 25, 52, 68, 71, 104, 67, 67, 25, 25, 25, 25, 25, 25, 25, 25, 25, 67, 
	67, 67, 67
    };static const ANTLR3_INT32 dfa13_T128[] =
    {
	25, 25, 208, 24, 39, 41, 41, 41, 41, 57, 25, 41, 37, 37, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 39, 39, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T129[] =
    {
	25, 25, 96, 24, 39, 41, 41, 41, 41, 57, 25, 41, 37, 37, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 39, 39, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T130[] =
    {
	25, 25, 322, 24, 25, 25, 25, 25, 25, 266, 25, 25, 299, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T131[] =
    {
	25, 25, 305, 24, 25, 25, 25, 25, 25, 212, 25, 25, 250, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T132[] =
    {
	25, 49, 302, 46, 39, 50, 41, 41, 41, 48, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 51, 94, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T133[] =
    {
	25, 25, 95, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 94, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T134[] =
    {
	25, 49, 314, 46, 39, 50, 41, 41, 41, 48, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 51, 94, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T135[] =
    {
	25, 25, 271, 24, 39, 41, 41, 41, 41, 57, 25, 41, 37, 37, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 39, 39, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T136[] =
    {
	25, 25, 313, 24, 25, 25, 25, 25, 25, 243, 25, 25, 268, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 265, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T137[] =
    {
	25, 25, 275, 24, 25, 25, 25, 25, 25, 151, 25, 25, 214, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 210, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T138[] =
    {
	25, 80, 107, 46, 108, 73, 25, 81, 25, 81, 25, 81, 106, 106, 25, 25, 108, 
	108, 25, 25, 25, 81, 81, 104, 105, 108, 81, 81, 25, 25, 109, 25, 25, 25, 
	25, 108, 108, 108, 108
    };static const ANTLR3_INT32 dfa13_T139[] =
    {
	25, 25, 330, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T140[] =
    {
	25, 25, 324, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T141[] =
    {
	25, 49, 64, 46, 39, 50, 41, 41, 41, 48, 25, 41, 37, 37, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 51, 39, 39, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T142[] =
    {
	25, 25, 321, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T143[] =
    {
	25, 25, 304, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T144[] =
    {
	25, 25, 297, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T145[] =
    {
	25, 25, 248, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T146[] =
    {
	25, 25, 156, 24, 157, 25, 72, 162, 69, 162, 25, 160, 155, 155, 25, 25, 
	157, 157, 25, 25, 52, 158, 161, 25, 154, 157, 162, 162, 25, 25, 159, 25, 
	25, 25, 25, 157, 157, 157, 157
    };static const ANTLR3_INT32 dfa13_T147[] =
    {
	25, 25, 333, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 203, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T148[] =
    {
	25, 25, 331, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 100, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T149[] =
    {
	25, 49, 197, 46, 25, 73, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 104, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T150[] =
    {
	25, 25, 317, 24, 25, 25, 25, 25, 25, 25, 25, 25, 317, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T151[] =
    {
	25, 25, 286, 24, 25, 25, 25, 25, 25, 25, 25, 25, 286, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T152[] =
    {
	25, 25, 255, 24, 25, 25, 25, 25, 25, 25, 25, 25, 255, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T153[] =
    {
	25, 25, 253, 24, 25, 25, 25, 25, 25, 25, 25, 25, 253, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T154[] =
    {
	25, 25, 98, 24, 25, 25, 25, 25, 25, 25, 25, 25, 98, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T155[] =
    {
	25, 25, 227, 24, 25, 25, 25, 25, 25, 25, 25, 25, 227, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T156[] =
    {
	25, 49, 211, 46, 25, 73, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 104, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T157[] =
    {
	25, 25, 198, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 142, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T158[] =
    {
	25, 25, 119, 24, 25, 25, 25, 25, 25, 25, 25, 25, 119, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T159[] =
    {
	25, 25, 25, 24, 25, 73, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T160[] =
    {
	25, 25, 145, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 146, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T161[] =
    {
	25, 25, 44, 24, 39, 41, 41, 41, 41, 57, 25, 41, 43, 43, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 39, 45, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T162[] =
    {
	25, 25, 245, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 246, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T163[] =
    {
	25, 49, 199, 46, 25, 73, 25, 25, 25, 135, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 104, 200, 141, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T164[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T165[] =
    {
	25, 49, 319, 46, 25, 73, 25, 25, 25, 135, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 104, 200, 141, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T166[] =
    {
	25, 25, 231, 24, 232, 41, 41, 41, 41, 229, 25, 234, 230, 230, 25, 25, 232, 
	232, 25, 25, 52, 41, 234, 234, 232, 232, 225, 225, 25, 225, 233, 25, 25, 
	25, 25, 232, 232, 232, 232
    };static const ANTLR3_INT32 dfa13_T167[] =
    {
	25, 49, 196, 46, 25, 73, 25, 25, 25, 135, 25, 25, 90, 90, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 104, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T168[] =
    {
	25, 25, 236, 24, 237, 25, 25, 25, 25, 225, 25, 225, 235, 235, 25, 25, 237, 
	237, 25, 25, 25, 25, 225, 225, 237, 237, 225, 225, 25, 225, 226, 25, 25, 
	25, 25, 237, 237, 237, 237
    };static const ANTLR3_INT32 dfa13_T169[] =
    {
	25, 25, 132, 24, 133, 25, 25, 25, 25, 89, 25, 89, 131, 131, 25, 25, 133, 
	133, 25, 25, 25, 25, 89, 89, 133, 133, 89, 89, 25, 89, 127, 25, 25, 25, 
	25, 133, 133, 133, 133
    };static const ANTLR3_INT32 dfa13_T170[] =
    {
	25, 25, 310, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 311, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T171[] =
    {
	25, 25, 272, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 273, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T172[] =
    {
	25, 25, 53, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 56, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T173[] =
    {
	25, 25, 326, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 327, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T174[] =
    {
	25, 25, 315, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 316, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T175[] =
    {
	25, 25, 95, 24, 39, 41, 41, 41, 41, 57, 25, 41, 54, 54, 25, 25, 39, 39, 
	25, 25, 52, 41, 41, 41, 39, 55, 25, 25, 25, 25, 40, 25, 25, 25, 25, 39, 
	39, 39, 39
    };static const ANTLR3_INT32 dfa13_T176[] =
    {
	25, 25, 318, 24, 25, 25, 25, 25, 25, 25, 25, 25, 318, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T177[] =
    {
	25, 25, 293, 24, 25, 25, 25, 25, 25, 25, 25, 25, 293, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T178[] =
    {
	25, 25, 259, 24, 25, 25, 25, 25, 25, 25, 25, 25, 259, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T179[] =
    {
	25, 25, 254, 24, 25, 25, 25, 25, 25, 25, 25, 25, 254, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T180[] =
    {
	25, 25, 191, 24, 25, 25, 25, 25, 25, 25, 25, 25, 191, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T181[] =
    {
	25, 25, 216, 24, 25, 25, 25, 25, 25, 25, 25, 25, 216, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T182[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 311, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T183[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 273, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T184[] =
    {
	25, 25, 262, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 239, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T185[] =
    {
	25, 25, 269, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 265, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T186[] =
    {
	25, 25, 215, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 210, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T187[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 327, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T188[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 316, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T189[] =
    {
	25, 25, 308, 24, 25, 25, 25, 25, 25, 25, 25, 25, 140, 140, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 295, 141, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25
    };static const ANTLR3_INT32 dfa13_T190[] =
    {
	8
    };static const ANTLR3_INT32 dfa13_T191[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 265, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };static const ANTLR3_INT32 dfa13_T192[] =
    {
	25, 25, 25, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 210, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa13_transitions[] =
{
    dfa13_T105, dfa13_T111, dfa13_T111, dfa13_T111, dfa13_T111, dfa13_T111, 
    dfa13_T111, dfa13_T190, dfa13_T83, dfa13_T46, dfa13_T108, dfa13_T44, 
    dfa13_T44, dfa13_T44, dfa13_T44, dfa13_T44, dfa13_T44, dfa13_T44, dfa13_T40, 
    dfa13_T40, dfa13_T40, dfa13_T40, dfa13_T40, dfa13_T40, dfa13_T44, dfa13_T164, 
    dfa13_T_empty, dfa13_T_empty, dfa13_T_empty, dfa13_T_empty, dfa13_T124, 
    dfa13_T_empty, dfa13_T_empty, dfa13_T_empty, dfa13_T_empty, dfa13_T_empty, 
    dfa13_T_empty, dfa13_T2, dfa13_T172, dfa13_T56, dfa13_T116, dfa13_T56, 
    dfa13_T47, dfa13_T2, dfa13_T2, dfa13_T161, dfa13_T44, dfa13_T141, dfa13_T34, 
    dfa13_T159, dfa13_T103, dfa13_T49, dfa13_T112, dfa13_T7, dfa13_T133, 
    dfa13_T175, dfa13_T129, dfa13_T54, dfa13_T56, dfa13_T56, dfa13_T154, 
    dfa13_T106, dfa13_T78, dfa13_T_empty, dfa13_T133, dfa13_T54, dfa13_T127, 
    dfa13_T54, dfa13_T54, dfa13_T54, dfa13_T54, dfa13_T54, dfa13_T54, dfa13_T138, 
    dfa13_T35, dfa13_T24, dfa13_T24, dfa13_T24, dfa13_T158, dfa13_T24, dfa13_T17, 
    dfa13_T81, dfa13_T24, dfa13_T4, dfa13_T96, dfa13_T96, dfa13_T96, dfa13_T65, 
    dfa13_T96, dfa13_T82, dfa13_T53, dfa13_T1, dfa13_T45, dfa13_T104, dfa13_T98, 
    dfa13_T133, dfa13_T160, dfa13_T54, dfa13_T56, dfa13_T110, dfa13_T36, 
    dfa13_T99, dfa13_T30, dfa13_T102, dfa13_T169, dfa13_T81, dfa13_T81, 
    dfa13_T81, dfa13_T81, dfa13_T66, dfa13_T35, dfa13_T35, dfa13_T35, dfa13_T35, 
    dfa13_T35, dfa13_T146, dfa13_T35, dfa13_T35, dfa13_T48, dfa13_T123, 
    dfa13_T27, dfa13_T4, dfa13_T4, dfa13_T4, dfa13_T50, dfa13_T4, dfa13_T4, 
    dfa13_T117, dfa13_T75, dfa13_T180, dfa13_T61, dfa13_T82, dfa13_T82, 
    dfa13_T82, dfa13_T167, dfa13_T76, dfa13_T53, dfa13_T53, dfa13_T62, dfa13_T157, 
    dfa13_T88, dfa13_T12, dfa13_T20, dfa13_T107, dfa13_T79, dfa13_T28, dfa13_T128, 
    dfa13_T126, dfa13_T55, dfa13_T77, dfa13_T39, dfa13_T16, dfa13_T186, 
    dfa13_T181, dfa13_T57, dfa13_T57, dfa13_T57, dfa13_T57, dfa13_T57, dfa13_T118, 
    dfa13_T57, dfa13_T57, dfa13_T6, dfa13_T51, dfa13_T51, dfa13_T51, dfa13_T51, 
    dfa13_T57, dfa13_T67, dfa13_T51, dfa13_T24, dfa13_T6, dfa13_T6, dfa13_T6, 
    dfa13_T6, dfa13_T50, dfa13_T50, dfa13_T50, dfa13_T50, dfa13_T119, dfa13_T122, 
    dfa13_T50, dfa13_T61, dfa13_T155, dfa13_T50, dfa13_T75, dfa13_T75, dfa13_T75, 
    dfa13_T68, dfa13_T166, dfa13_T75, dfa13_T96, dfa13_T61, dfa13_T61, dfa13_T61, 
    dfa13_T168, dfa13_T88, dfa13_T149, dfa13_T121, dfa13_T88, dfa13_T19, 
    dfa13_T0, dfa13_T109, dfa13_T37, dfa13_T97, dfa13_T29, dfa13_T101, dfa13_T69, 
    dfa13_T162, dfa13_T11, dfa13_T145, dfa13_T156, dfa13_T15, dfa13_T22, 
    dfa13_T59, dfa13_T90, dfa13_T81, dfa13_T153, dfa13_T179, dfa13_T152, 
    dfa13_T3, dfa13_T3, dfa13_T3, dfa13_T3, dfa13_T3, dfa13_T80, dfa13_T115, 
    dfa13_T82, dfa13_T178, dfa13_T3, dfa13_T95, dfa13_T95, dfa13_T95, dfa13_T64, 
    dfa13_T95, dfa13_T80, dfa13_T80, dfa13_T80, dfa13_T184, dfa13_T23, dfa13_T125, 
    dfa13_T52, dfa13_T38, dfa13_T14, dfa13_T185, dfa13_T33, dfa13_T135, 
    dfa13_T87, dfa13_T171, dfa13_T32, dfa13_T9, dfa13_T137, dfa13_T192, 
    dfa13_T6, dfa13_T51, dfa13_T61, dfa13_T26, dfa13_T18, dfa13_T151, dfa13_T75, 
    dfa13_T60, dfa13_T177, dfa13_T120, dfa13_T5, dfa13_T10, dfa13_T144, 
    dfa13_T13, dfa13_T21, dfa13_T58, dfa13_T89, dfa13_T70, dfa13_T132, dfa13_T92, 
    dfa13_T143, dfa13_T131, dfa13_T85, dfa13_T26, dfa13_T26, dfa13_T26, 
    dfa13_T26, dfa13_T114, dfa13_T26, dfa13_T18, dfa13_T18, dfa13_T18, dfa13_T18, 
    dfa13_T80, dfa13_T26, dfa13_T60, dfa13_T60, dfa13_T60, dfa13_T63, dfa13_T60, 
    dfa13_T95, dfa13_T189, dfa13_T25, dfa13_T86, dfa13_T170, dfa13_T31, 
    dfa13_T8, dfa13_T136, dfa13_T191, dfa13_T134, dfa13_T183, dfa13_T174, 
    dfa13_T43, dfa13_T150, dfa13_T176, dfa13_T113, dfa13_T165, dfa13_T91, 
    dfa13_T142, dfa13_T130, dfa13_T84, dfa13_T41, dfa13_T94, dfa13_T140, 
    dfa13_T18, dfa13_T60, dfa13_T100, dfa13_T182, dfa13_T173, dfa13_T42, 
    dfa13_T188, dfa13_T74, dfa13_T163, dfa13_T93, dfa13_T139, dfa13_T148, 
    dfa13_T187, dfa13_T73, dfa13_T72, dfa13_T147, dfa13_T71	
};

static ANTLR3_INT32 dfa13_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA13_13;

    	    ANTLR3_MARKER index13_13;


    		LA13_13 = LA(1);

    	 
    	    index13_13 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 26;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_13);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA13_11;

    	    ANTLR3_MARKER index13_11;


    		LA13_11 = LA(1);

    	 
    	    index13_11 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 26;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( ((IS_TOKEN(nc))) )
    	    {
    	        s = 28;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_11);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA13_46;

    	    ANTLR3_MARKER index13_46;


    		LA13_46 = LA(1);

    	 
    	    index13_46 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(username))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( ((IS_TOKEN(realm))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( ((IS_TOKEN(nonce))) )
    	    {
    	        s = 33;
    	    }

    	    else if ( ((IS_TOKEN(uri))) )
    	    {
    	        s = 63;
    	    }

    	    else if ( ((IS_TOKEN(response))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( ((IS_TOKEN(cnonce))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( ((IS_TOKEN(opaque))) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_46);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA13_17;

    	    ANTLR3_MARKER index13_17;


    		LA13_17 = LA(1);

    	 
    	    index13_17 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 26;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_17);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA13_15;

    	    ANTLR3_MARKER index13_15;


    		LA13_15 = LA(1);

    	 
    	    index13_15 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 26;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_15);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA13_16;

    	    ANTLR3_MARKER index13_16;


    		LA13_16 = LA(1);

    	 
    	    index13_16 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 26;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_16);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA13_14;

    	    ANTLR3_MARKER index13_14;


    		LA13_14 = LA(1);

    	 
    	    index13_14 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 26;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_14);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA13_24;

    	    ANTLR3_MARKER index13_24;


    		LA13_24 = LA(1);

    	 
    	    index13_24 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(username))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( ((IS_TOKEN(realm))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( ((IS_TOKEN(nonce))) )
    	    {
    	        s = 33;
    	    }

    	    else if ( ((IS_TOKEN(response))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( ((IS_TOKEN(cnonce))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( ((IS_TOKEN(opaque))) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_24);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 8:
        
    	{
    	    ANTLR3_UINT32 LA13_12;

    	    ANTLR3_MARKER index13_12;


    		LA13_12 = LA(1);

    	 
    	    index13_12 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 26;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( ((IS_TOKEN(nc))) )
    	    {
    	        s = 28;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index13_12);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"287:1: dig_resp[belle_sip_header_authorization_t* header_authorization_base] : ( username | realm | nonce | digest_uri[header_authorization_base] | dresponse | algorithm | cnonce | opaque | message_qop | nonce_count | auth_param[header_authorization_base] );";
    EXCEPTION->decisionNum  = 13;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 13
 */
static
ANTLR3_CYCLIC_DFA cdfa13
    =	{
	    13,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"287:1: dig_resp[belle_sip_header_authorization_t* header_authorization_base] : ( username | realm | nonce | digest_uri[header_authorization_base] | dresponse | algorithm | cnonce | opaque | message_qop | nonce_count | auth_param[header_authorization_base] );",	
	    (CDFA_SPECIAL_FUNC) dfa13_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa13_eot,	    /* EOT table			    */
	    dfa13_eof,	    /* EOF table			    */
	    dfa13_min,	    /* Minimum tokens for each state    */
	    dfa13_max,	    /* Maximum tokens for each state    */
	    dfa13_accept,	/* Accept table			    */
	    dfa13_special,	/* Special transition states	    */
	    dfa13_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 13
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    452:6: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] )
 */
static const ANTLR3_INT32 dfa20_eot[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa20_eof[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa20_min[9] =
    {
	5, 5, 5, 5, 5, 5, 5, -1, -1
    };
static const ANTLR3_INT32 dfa20_max[9] =
    {
	42, 42, 42, 42, 42, 42, 42, -1, -1
    };
static const ANTLR3_INT32 dfa20_accept[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa20_special[9] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa20_T_empty	    NULL

static const ANTLR3_INT32 dfa20_T0[] =
    {
	7, 2, -1, 3, -1, -1, -1, -1, 8, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa20_T1[] =
    {
	7, 2, 7, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa20_transitions[] =
{
    dfa20_T1, dfa20_T0, dfa20_T0, dfa20_T0, dfa20_T0, dfa20_T0, dfa20_T0, 
    dfa20_T_empty, dfa20_T_empty	
};


/* Declare tracking structure for Cyclic DFA 20
 */
static
ANTLR3_CYCLIC_DFA cdfa20
    =	{
	    20,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"452:6: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa20_eot,	    /* EOT table			    */
	    dfa20_eof,	    /* EOF table			    */
	    dfa20_min,	    /* Minimum tokens for each state    */
	    dfa20_max,	    /* Maximum tokens for each state    */
	    dfa20_accept,	/* Accept table			    */
	    dfa20_special,	/* Special transition states	    */
	    dfa20_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 20
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    471:1: header_address_base[belle_sip_header_address_t* obj] returns [belle_sip_header_address_t* ret] : ( name_addr[BELLE_SIP_HEADER_ADDRESS($ret)] | addr_spec[BELLE_SIP_HEADER_ADDRESS($ret)] );
 */
static const ANTLR3_INT32 dfa22_eot[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa22_eof[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa22_min[9] =
    {
	5, 5, 5, 5, 5, 5, 5, -1, -1
    };
static const ANTLR3_INT32 dfa22_max[9] =
    {
	42, 42, 42, 42, 42, 42, 42, -1, -1
    };
static const ANTLR3_INT32 dfa22_accept[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa22_special[9] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa22_T_empty	    NULL

static const ANTLR3_INT32 dfa22_T0[] =
    {
	7, 2, -1, 3, -1, -1, -1, -1, 8, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa22_T1[] =
    {
	7, 2, 7, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa22_transitions[] =
{
    dfa22_T1, dfa22_T0, dfa22_T0, dfa22_T0, dfa22_T0, dfa22_T0, dfa22_T0, 
    dfa22_T_empty, dfa22_T_empty	
};


/* Declare tracking structure for Cyclic DFA 22
 */
static
ANTLR3_CYCLIC_DFA cdfa22
    =	{
	    22,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"471:1: header_address_base[belle_sip_header_address_t* obj] returns [belle_sip_header_address_t* ret] : ( name_addr[BELLE_SIP_HEADER_ADDRESS($ret)] | addr_spec[BELLE_SIP_HEADER_ADDRESS($ret)] );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa22_eot,	    /* EOT table			    */
	    dfa22_eof,	    /* EOF table			    */
	    dfa22_min,	    /* Minimum tokens for each state    */
	    dfa22_max,	    /* Maximum tokens for each state    */
	    dfa22_accept,	/* Accept table			    */
	    dfa22_special,	/* Special transition states	    */
	    dfa22_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 22
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    683:6: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_from::current)] )
 */
static const ANTLR3_INT32 dfa30_eot[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_eof[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_min[9] =
    {
	5, 5, 5, 5, 5, 5, 5, -1, -1
    };
static const ANTLR3_INT32 dfa30_max[9] =
    {
	42, 42, 42, 42, 42, 42, 42, -1, -1
    };
static const ANTLR3_INT32 dfa30_accept[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa30_special[9] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa30_T_empty	    NULL

static const ANTLR3_INT32 dfa30_T0[] =
    {
	7, 2, -1, 3, -1, -1, -1, -1, 8, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa30_T1[] =
    {
	7, 2, 7, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa30_transitions[] =
{
    dfa30_T1, dfa30_T0, dfa30_T0, dfa30_T0, dfa30_T0, dfa30_T0, dfa30_T0, 
    dfa30_T_empty, dfa30_T_empty	
};


/* Declare tracking structure for Cyclic DFA 30
 */
static
ANTLR3_CYCLIC_DFA cdfa30
    =	{
	    30,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"683:6: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_from::current)] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa30_eot,	    /* EOT table			    */
	    dfa30_eof,	    /* EOF table			    */
	    dfa30_min,	    /* Minimum tokens for each state    */
	    dfa30_max,	    /* Maximum tokens for each state    */
	    dfa30_accept,	/* Accept table			    */
	    dfa30_special,	/* Special transition states	    */
	    dfa30_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 30
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    742:1: challenge[belle_sip_header_www_authenticate_t* www_authenticate] : ( ({...}? token LWS digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] );
 */
static const ANTLR3_INT32 dfa34_eot[42] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa34_eof[42] =
    {
	-1, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa34_min[42] =
    {
	6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, -1, 12, 5, 5, 4, 0, 0, 0, 0, 
	0, 0, 0, 4, 4, 4, 4, 4, 4, 4, -1, 0, 4, 4, 4, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa34_max[42] =
    {
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, -1, 12, 42, 42, 
	42, 0, 0, 0, 0, 0, 0, 0, 42, 42, 42, 42, 42, 42, 42, -1, 0, 42, 42, 42, 
	42, 42, 42, 42
    };
static const ANTLR3_INT32 dfa34_accept[42] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa34_special[42] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 0, 5, 3, 6, 7, 4, 2, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa34_T_empty	    NULL

static const ANTLR3_INT32 dfa34_T0[] =
    {
	32, 32, 27, 34, 28, 32, 35, 32, 32, 32, 32, 30, 26, 26, 32, 32, 28, 28, 
	32, 32, 32, 32, 32, 32, 28, 28, 32, 32, 32, 32, 29, 31, 32, 32, 32, 28, 
	28, 28, 28
    };static const ANTLR3_INT32 dfa34_T1[] =
    {
	-1
    };static const ANTLR3_INT32 dfa34_T2[] =
    {
	15, 9, -1, 10, -1, -1, -1, 16, -1, -1, 12, 8, 8, -1, -1, 10, 10, -1, -1, 
	-1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 11, 13, -1, -1, -1, 10, 10, 10, 
	10
    };static const ANTLR3_INT32 dfa34_T3[] =
    {
	7, 2, -1, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, -1, -1, 3, 3, -1, -1, -1, 
	-1, -1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa34_T4[] =
    {
	32, 32, 32, 25, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32
    };static const ANTLR3_INT32 dfa34_T5[] =
    {
	32, 32, 37, 25, 38, 32, 32, 32, 32, 32, 32, 40, 36, 36, 32, 32, 38, 38, 
	32, 32, 32, 32, 32, 32, 38, 38, 32, 32, 32, 32, 39, 41, 32, 32, 32, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa34_T6[] =
    {
	32, 32, 37, 34, 38, 32, 35, 32, 32, 32, 32, 40, 36, 36, 32, 32, 38, 38, 
	32, 32, 32, 32, 32, 32, 38, 38, 32, 32, 32, 32, 39, 41, 32, 32, 32, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa34_T7[] =
    {
	2, -1, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, -1, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa34_T8[] =
    {
	14, 20, 18, 21, -1, -1, -1, -1, -1, -1, 23, 19, 19, -1, -1, 21, 21, -1, 
	-1, -1, -1, -1, -1, 21, 21, -1, -1, -1, -1, 22, 24, -1, -1, -1, 21, 21, 
	21, 21
    };static const ANTLR3_INT32 dfa34_T9[] =
    {
	32, 32, 27, 25, 28, 32, 32, 32, 32, 32, 32, 30, 26, 26, 32, 32, 28, 28, 
	32, 32, 32, 32, 32, 32, 28, 28, 32, 32, 32, 32, 29, 31, 32, 32, 32, 28, 
	28, 28, 28
    };static const ANTLR3_INT32 dfa34_T10[] =
    {
	14, 9, -1, 10, -1, 14, -1, -1, -1, -1, 12, 8, 8, -1, -1, 10, 10, -1, -1, 
	-1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 11, 13, -1, -1, -1, 10, 10, 10, 
	10
    };static const ANTLR3_INT32 dfa34_T11[] =
    {
	16
    };static const ANTLR3_INT32 dfa34_T12[] =
    {
	17, 20, 18, 21, -1, -1, -1, -1, -1, -1, 23, 19, 19, -1, -1, 21, 21, -1, 
	-1, -1, -1, -1, -1, 21, 21, -1, -1, -1, -1, 22, 24, -1, -1, -1, 21, 21, 
	21, 21
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa34_transitions[] =
{
    dfa34_T7, dfa34_T3, dfa34_T3, dfa34_T3, dfa34_T3, dfa34_T3, dfa34_T3, 
    dfa34_T10, dfa34_T2, dfa34_T2, dfa34_T2, dfa34_T2, dfa34_T2, dfa34_T2, 
    dfa34_T_empty, dfa34_T11, dfa34_T12, dfa34_T8, dfa34_T9, dfa34_T1, dfa34_T1, 
    dfa34_T1, dfa34_T1, dfa34_T1, dfa34_T1, dfa34_T1, dfa34_T0, dfa34_T0, 
    dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T0, dfa34_T4, dfa34_T_empty, dfa34_T1, 
    dfa34_T5, dfa34_T6, dfa34_T6, dfa34_T6, dfa34_T6, dfa34_T6, dfa34_T6	
};

static ANTLR3_INT32 dfa34_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA34_19;

    	    ANTLR3_MARKER index34_19;


    		LA34_19 = LA(1);

    	 
    	    index34_19 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 33;
    	    }

    	 
    		SEEK(index34_19);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA34_34;

    	    ANTLR3_MARKER index34_34;


    		LA34_34 = LA(1);

    	 
    	    index34_34 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 33;
    	    }

    	 
    		SEEK(index34_34);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA34_25;

    	    ANTLR3_MARKER index34_25;


    		LA34_25 = LA(1);

    	 
    	    index34_25 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 33;
    	    }

    	 
    		SEEK(index34_25);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA34_21;

    	    ANTLR3_MARKER index34_21;


    		LA34_21 = LA(1);

    	 
    	    index34_21 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 33;
    	    }

    	 
    		SEEK(index34_21);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA34_24;

    	    ANTLR3_MARKER index34_24;


    		LA34_24 = LA(1);

    	 
    	    index34_24 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 33;
    	    }

    	 
    		SEEK(index34_24);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA34_20;

    	    ANTLR3_MARKER index34_20;


    		LA34_20 = LA(1);

    	 
    	    index34_20 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 33;
    	    }

    	 
    		SEEK(index34_20);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA34_22;

    	    ANTLR3_MARKER index34_22;


    		LA34_22 = LA(1);

    	 
    	    index34_22 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 33;
    	    }

    	 
    		SEEK(index34_22);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA34_23;

    	    ANTLR3_MARKER index34_23;


    		LA34_23 = LA(1);

    	 
    	    index34_23 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 33;
    	    }

    	 
    		SEEK(index34_23);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"742:1: challenge[belle_sip_header_www_authenticate_t* www_authenticate] : ( ({...}? token LWS digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] );";
    EXCEPTION->decisionNum  = 34;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 34
 */
static
ANTLR3_CYCLIC_DFA cdfa34
    =	{
	    34,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"742:1: challenge[belle_sip_header_www_authenticate_t* www_authenticate] : ( ({...}? token LWS digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] );",	
	    (CDFA_SPECIAL_FUNC) dfa34_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa34_eot,	    /* EOT table			    */
	    dfa34_eof,	    /* EOF table			    */
	    dfa34_min,	    /* Minimum tokens for each state    */
	    dfa34_max,	    /* Maximum tokens for each state    */
	    dfa34_accept,	/* Accept table			    */
	    dfa34_special,	/* Special transition states	    */
	    dfa34_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 34
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    750:1: digest_cln[belle_sip_header_www_authenticate_t* www_authenticate] : ( | realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] );
 */
static const ANTLR3_INT32 dfa36_eot[42] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa36_eof[42] =
    {
	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa36_min[42] =
    {
	5, -1, 5, 5, 5, 5, 5, 5, 12, 5, 5, 4, 0, 0, 0, 0, 0, 0, -1, 0, 4, 4, 4, 
	4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, 0, 4, 4, 4, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa36_max[42] =
    {
	42, -1, 42, 42, 42, 42, 42, 42, 12, 42, 42, 42, 0, 0, 0, 0, 0, 0, -1, 0, 
	42, 42, 42, 42, 42, 42, 42, -1, -1, -1, -1, -1, -1, -1, 0, 42, 42, 42, 
	42, 42, 42, 42
    };
static const ANTLR3_INT32 dfa36_accept[42] =
    {
	-1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	6, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 9, 2, 3, 5, 7, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa36_special[42] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 6, 3, 7, 4, 1, -1, 5, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa36_T_empty	    NULL

static const ANTLR3_INT32 dfa36_T0[] =
    {
	26, 26, 37, 19, 38, 26, 26, 26, 26, 26, 26, 40, 36, 36, 26, 26, 38, 38, 
	26, 26, 26, 26, 26, 26, 38, 38, 26, 26, 26, 26, 39, 41, 26, 26, 26, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa36_T1[] =
    {
	9
    };static const ANTLR3_INT32 dfa36_T2[] =
    {
	1, 3, -1, 4, -1, 1, -1, -1, -1, -1, 6, 2, 2, -1, -1, 4, 4, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, 5, 7, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa36_T3[] =
    {
	-1
    };static const ANTLR3_INT32 dfa36_T4[] =
    {
	26, 26, 21, 19, 22, 26, 26, 26, 26, 26, 26, 24, 20, 20, 26, 26, 22, 22, 
	26, 26, 26, 26, 26, 26, 22, 22, 26, 26, 26, 26, 23, 25, 26, 26, 26, 22, 
	22, 22, 22
    };static const ANTLR3_INT32 dfa36_T5[] =
    {
	26, 26, 26, 19, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26
    };static const ANTLR3_INT32 dfa36_T6[] =
    {
	8, 3, -1, 4, -1, -1, -1, 9, -1, -1, 6, 2, 2, -1, -1, 4, 4, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, 5, 7, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa36_T7[] =
    {
	26, 26, 37, 34, 38, 26, 35, 26, 26, 26, 26, 40, 36, 36, 26, 26, 38, 38, 
	26, 26, 26, 26, 26, 26, 38, 38, 26, 26, 26, 26, 39, 41, 26, 26, 26, 38, 
	38, 38, 38
    };static const ANTLR3_INT32 dfa36_T8[] =
    {
	26, 26, 21, 34, 22, 26, 35, 26, 26, 26, 26, 24, 20, 20, 26, 26, 22, 22, 
	26, 26, 26, 26, 26, 26, 22, 22, 26, 26, 26, 26, 23, 25, 26, 26, 26, 22, 
	22, 22, 22
    };static const ANTLR3_INT32 dfa36_T9[] =
    {
	18, 13, 11, 14, -1, -1, -1, -1, -1, -1, 16, 12, 12, -1, -1, 14, 14, -1, 
	-1, -1, -1, -1, -1, 14, 14, -1, -1, -1, -1, 15, 17, -1, -1, -1, 14, 14, 
	14, 14
    };static const ANTLR3_INT32 dfa36_T10[] =
    {
	10, 13, 11, 14, -1, -1, -1, -1, -1, -1, 16, 12, 12, -1, -1, 14, 14, -1, 
	-1, -1, -1, -1, -1, 14, 14, -1, -1, -1, -1, 15, 17, -1, -1, -1, 14, 14, 
	14, 14
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa36_transitions[] =
{
    dfa36_T2, dfa36_T_empty, dfa36_T6, dfa36_T6, dfa36_T6, dfa36_T6, dfa36_T6, 
    dfa36_T6, dfa36_T1, dfa36_T10, dfa36_T9, dfa36_T4, dfa36_T3, dfa36_T3, 
    dfa36_T3, dfa36_T3, dfa36_T3, dfa36_T3, dfa36_T_empty, dfa36_T3, dfa36_T8, 
    dfa36_T8, dfa36_T8, dfa36_T8, dfa36_T8, dfa36_T8, dfa36_T5, dfa36_T_empty, 
    dfa36_T_empty, dfa36_T_empty, dfa36_T_empty, dfa36_T_empty, dfa36_T_empty, 
    dfa36_T_empty, dfa36_T3, dfa36_T0, dfa36_T7, dfa36_T7, dfa36_T7, dfa36_T7, 
    dfa36_T7, dfa36_T7	
};

static ANTLR3_INT32 dfa36_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA36_12;

    	    ANTLR3_MARKER index36_12;


    		LA36_12 = LA(1);

    	 
    	    index36_12 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 28;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index36_12);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA36_17;

    	    ANTLR3_MARKER index36_17;


    		LA36_17 = LA(1);

    	 
    	    index36_17 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 28;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index36_17);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA36_34;

    	    ANTLR3_MARKER index36_34;


    		LA36_34 = LA(1);

    	 
    	    index36_34 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(realm))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( ((IS_TOKEN(nonce))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( ((IS_TOKEN(opaque))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( ((IS_TOKEN(domain))) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index36_34);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA36_14;

    	    ANTLR3_MARKER index36_14;


    		LA36_14 = LA(1);

    	 
    	    index36_14 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 28;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index36_14);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA36_16;

    	    ANTLR3_MARKER index36_16;


    		LA36_16 = LA(1);

    	 
    	    index36_16 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 28;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index36_16);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA36_19;

    	    ANTLR3_MARKER index36_19;


    		LA36_19 = LA(1);

    	 
    	    index36_19 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(realm))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( ((IS_TOKEN(nonce))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( ((IS_TOKEN(opaque))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( ((IS_TOKEN(domain))) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index36_19);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA36_13;

    	    ANTLR3_MARKER index36_13;


    		LA36_13 = LA(1);

    	 
    	    index36_13 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 28;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index36_13);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA36_15;

    	    ANTLR3_MARKER index36_15;


    		LA36_15 = LA(1);

    	 
    	    index36_15 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 27;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 28;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 29;
    	    }

    	 
    		SEEK(index36_15);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"750:1: digest_cln[belle_sip_header_www_authenticate_t* www_authenticate] : ( | realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] );";
    EXCEPTION->decisionNum  = 36;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 36
 */
static
ANTLR3_CYCLIC_DFA cdfa36
    =	{
	    36,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"750:1: digest_cln[belle_sip_header_www_authenticate_t* www_authenticate] : ( | realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] );",	
	    (CDFA_SPECIAL_FUNC) dfa36_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa36_eot,	    /* EOT table			    */
	    dfa36_eof,	    /* EOF table			    */
	    dfa36_min,	    /* Minimum tokens for each state    */
	    dfa36_max,	    /* Maximum tokens for each state    */
	    dfa36_accept,	/* Accept table			    */
	    dfa36_special,	/* Special transition states	    */
	    dfa36_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 36
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    998:7: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_to::current)] )
 */
static const ANTLR3_INT32 dfa44_eot[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_eof[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_min[9] =
    {
	5, 5, 5, 5, 5, 5, 5, -1, -1
    };
static const ANTLR3_INT32 dfa44_max[9] =
    {
	42, 42, 42, 42, 42, 42, 42, -1, -1
    };
static const ANTLR3_INT32 dfa44_accept[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa44_special[9] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa44_T_empty	    NULL

static const ANTLR3_INT32 dfa44_T0[] =
    {
	7, 2, -1, 3, -1, -1, -1, -1, 8, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa44_T1[] =
    {
	7, 2, 7, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa44_transitions[] =
{
    dfa44_T1, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T0, 
    dfa44_T_empty, dfa44_T_empty	
};


/* Declare tracking structure for Cyclic DFA 44
 */
static
ANTLR3_CYCLIC_DFA cdfa44
    =	{
	    44,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"998:7: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_to::current)] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa44_eot,	    /* EOT table			    */
	    dfa44_eof,	    /* EOF table			    */
	    dfa44_min,	    /* Minimum tokens for each state    */
	    dfa44_max,	    /* Maximum tokens for each state    */
	    dfa44_accept,	/* Accept table			    */
	    dfa44_special,	/* Special transition states	    */
	    dfa44_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 44
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1017:8: ( name_addr[address] | paramless_addr_spec[address] )
 */
static const ANTLR3_INT32 dfa46_eot[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa46_eof[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa46_min[9] =
    {
	5, 5, 5, 5, 5, 5, 5, -1, -1
    };
static const ANTLR3_INT32 dfa46_max[9] =
    {
	42, 42, 42, 42, 42, 42, 42, -1, -1
    };
static const ANTLR3_INT32 dfa46_accept[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa46_special[9] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa46_T_empty	    NULL

static const ANTLR3_INT32 dfa46_T0[] =
    {
	7, 2, -1, 3, -1, -1, -1, -1, 8, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa46_T1[] =
    {
	7, 2, 7, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, 7, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa46_transitions[] =
{
    dfa46_T1, dfa46_T0, dfa46_T0, dfa46_T0, dfa46_T0, dfa46_T0, dfa46_T0, 
    dfa46_T_empty, dfa46_T_empty	
};


/* Declare tracking structure for Cyclic DFA 46
 */
static
ANTLR3_CYCLIC_DFA cdfa46
    =	{
	    46,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1017:8: ( name_addr[address] | paramless_addr_spec[address] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa46_eot,	    /* EOT table			    */
	    dfa46_eof,	    /* EOF table			    */
	    dfa46_min,	    /* Minimum tokens for each state    */
	    dfa46_max,	    /* Maximum tokens for each state    */
	    dfa46_accept,	/* Accept table			    */
	    dfa46_special,	/* Special transition states	    */
	    dfa46_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 46
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1081:1: via_params : ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] );
 */
static const ANTLR3_INT32 dfa53_eot[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa53_eof[12] =
    {
	-1, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa53_min[12] =
    {
	6, 5, 5, 5, 5, 5, 5, 5, -1, 0, 0, -1
    };
static const ANTLR3_INT32 dfa53_max[12] =
    {
	42, 42, 42, 42, 42, 42, 42, 42, -1, 0, 0, -1
    };
static const ANTLR3_INT32 dfa53_accept[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, 1
    };
static const ANTLR3_INT32 dfa53_special[12] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa53_T_empty	    NULL

static const ANTLR3_INT32 dfa53_T0[] =
    {
	8, 2, -1, 3, 8, 8, -1, 7, -1, -1, 5, 1, 1, -1, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa53_T1[] =
    {
	8, 10, 8, 8, -1, -1, -1, -1, -1, -1, 8, 9, 8, -1, -1, 8, 8, -1, -1, -1, 
	-1, -1, -1, 8, 8, -1, -1, 11, -1, 8, 8, -1, -1, -1, 8, 8, 8, 8
    };static const ANTLR3_INT32 dfa53_T2[] =
    {
	-1
    };static const ANTLR3_INT32 dfa53_T3[] =
    {
	2, -1, 3, -1, -1, -1, -1, -1, -1, 5, 1, 1, -1, -1, 3, 3, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, 4, 6, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa53_transitions[] =
{
    dfa53_T3, dfa53_T0, dfa53_T0, dfa53_T0, dfa53_T0, dfa53_T0, dfa53_T0, 
    dfa53_T1, dfa53_T_empty, dfa53_T2, dfa53_T2, dfa53_T_empty	
};

static ANTLR3_INT32 dfa53_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA53_10;

    	    ANTLR3_MARKER index53_10;


    		LA53_10 = LA(1);

    	 
    	    index53_10 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(received))) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 8;
    	    }

    	 
    		SEEK(index53_10);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA53_9;

    	    ANTLR3_MARKER index53_9;


    		LA53_9 = LA(1);

    	 
    	    index53_9 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(received))) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 8;
    	    }

    	 
    		SEEK(index53_9);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"1081:1: via_params : ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] );";
    EXCEPTION->decisionNum  = 53;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 53
 */
static
ANTLR3_CYCLIC_DFA cdfa53
    =	{
	    53,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1081:1: via_params : ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] );",	
	    (CDFA_SPECIAL_FUNC) dfa53_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa53_eot,	    /* EOT table			    */
	    dfa53_eof,	    /* EOF table			    */
	    dfa53_min,	    /* Minimum tokens for each state    */
	    dfa53_max,	    /* Maximum tokens for each state    */
	    dfa53_accept,	/* Accept table			    */
	    dfa53_special,	/* Special transition states	    */
	    dfa53_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 53
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1277:43: ( ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] )
 */
static const ANTLR3_INT32 dfa61_eot[133] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa61_eof[133] =
    {
	-1, 4, -1, -1, -1, 4, 4, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 
	-1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, 4, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 4, 4, 4, -1, 4, 4, 4, 4, 4, 4, -1, 4, -1, -1, 4, 4, 4, 4, 4, 
	4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 4, 4, -1, -1, 4, 4, 4, -1, 4, 4, -1, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, -1, 4, -1, 4, -1, 4, 4
    };
static const ANTLR3_INT32 dfa61_min[133] =
    {
	6, 5, 6, -1, -1, 5, 5, 6, 5, 6, 6, 5, 5, 6, 6, 6, 6, 6, 5, 6, 6, 6, 6, 
	6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 5, 5, 6, 6, 6, 6, 6, 5, 
	6, 5, 5, 5, 6, 5, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 5, 5, 5, 6, 
	5, 6, 6, 5, 5, 5, 5, 5, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, 5, 5, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 6, 6, 5, 5, 5, 6, 5, 5, 6, 
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 5
    };
static const ANTLR3_INT32 dfa61_max[133] =
    {
	42, 42, 42, -1, -1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 16, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 16, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 16, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, -1, -1, -1, -1, -1, -1, -1, -1, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 16, 42, 42, 42, 42, 16, 42, 42, 42, 42, 
	42, 42, 42, 42, 16, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	16, 42, 42, 42, 16, 42, 42
    };
static const ANTLR3_INT32 dfa61_accept[133] =
    {
	-1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa61_special[133] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa61_T_empty	    NULL

static const ANTLR3_INT32 dfa61_T0[] =
    {
	4, 68, -1, 69, 11, 12, 88, 88, 66, -1, 71, 67, 67, -1, -1, 69, 69, -1, 
	-1, 88, 72, 71, 71, 69, 69, 4, 4, -1, 4, 70, -1, -1, -1, -1, 69, 69, 69, 
	69
    };static const ANTLR3_INT32 dfa61_T1[] =
    {
	4, 57, 4, 58, -1, 3, -1, 3, -1, -1, 59, 56, 56, 4, -1, 58, 58, -1, -1, 
	3, 3, 3, -1, 58, 58, -1, -1, -1, -1, 4, 4, -1, -1, -1, 58, 58, 58, 58
    };static const ANTLR3_INT32 dfa61_T2[] =
    {
	4, 31, -1, 32, 3, 3, 3, 3, 51, -1, 34, 30, 30, 4, -1, 32, 32, -1, -1, 3, 
	3, 3, 3, 32, 32, -1, -1, -1, -1, 33, 4, -1, -1, -1, 32, 32, 32, 32
    };static const ANTLR3_INT32 dfa61_T3[] =
    {
	4, 26, -1, 27, 11, 12, 3, 48, 3, -1, 29, 25, 25, -1, -1, 27, 27, -1, -1, 
	3, 3, 3, 3, 27, 27, -1, -1, -1, -1, 28, 4, -1, -1, -1, 27, 27, 27, 27
    };static const ANTLR3_INT32 dfa61_T4[] =
    {
	4, 75, -1, 76, 11, 12, 88, 88, 88, -1, 78, 74, 74, -1, -1, 76, 76, -1, 
	-1, 88, 88, 88, 88, 76, 76, -1, -1, -1, -1, 77, 4, -1, -1, -1, 76, 76, 
	76, 76
    };static const ANTLR3_INT32 dfa61_T5[] =
    {
	94, -1, 95, -1, 88, -1, 109, 4, -1, 96, 93, 93, -1, -1, 95, 95, -1, -1, 
	88, 88, 97, 4, 95, 95, 4, 4, -1, 4, 4, -1, -1, -1, -1, 95, 95, 95, 95
    };static const ANTLR3_INT32 dfa61_T6[] =
    {
	43, -1, 44, -1, 3, -1, 40, 4, -1, 41, 42, 42, -1, -1, 44, 44, -1, -1, 3, 
	3, 45, 4, 44, 44, 4, 4, -1, 4, 4, -1, -1, -1, -1, 44, 44, 44, 44
    };static const ANTLR3_INT32 dfa61_T7[] =
    {
	130, -1, -1, -1, -1, -1, -1, -1, -1, -1, 130
    };static const ANTLR3_INT32 dfa61_T8[] =
    {
	112, -1, -1, -1, -1, -1, -1, -1, -1, -1, 112
    };static const ANTLR3_INT32 dfa61_T9[] =
    {
	47, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47
    };static const ANTLR3_INT32 dfa61_T10[] =
    {
	98, -1, -1, -1, -1, -1, -1, -1, -1, -1, 98
    };static const ANTLR3_INT32 dfa61_T11[] =
    {
	17, -1, 3, 3, 3, 3, 3, 3, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, 3, 3, 3, 3, 
	3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T12[] =
    {
	4, 124, -1, 125, 11, 12, 88, 88, 122, -1, 127, 123, 123, -1, -1, 125, 125, 
	-1, -1, 88, 72, 127, 127, 125, 125, 4, 4, -1, 4, 126, -1, -1, -1, -1, 125, 
	125, 125, 125
    };static const ANTLR3_INT32 dfa61_T13[] =
    {
	101, -1, 102, 88, 88, 88, 111, 99, -1, 104, 100, 100, -1, -1, 102, 102, 
	-1, -1, 88, 88, 104, 104, 102, 102, 4, 4, -1, 4, 103, -1, -1, -1, -1, 102, 
	102, 102, 102
    };static const ANTLR3_INT32 dfa61_T14[] =
    {
	21, -1, 22, 3, 3, 3, 46, 19, -1, 24, 20, 20, -1, -1, 22, 22, -1, -1, 3, 
	3, 24, 24, 22, 22, 4, 4, -1, 4, 23, -1, -1, -1, -1, 22, 22, 22, 22
    };static const ANTLR3_INT32 dfa61_T15[] =
    {
	37, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 36, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T16[] =
    {
	4, 61, -1, 62, 4, 39, -1, 88, 4, -1, 64, 60, 60, -1, -1, 62, 62, -1, -1, 
	88, 63, 65, 4, 62, 62, 4, 4, -1, 4, 4, -1, -1, -1, -1, 62, 62, 62, 62
    };static const ANTLR3_INT32 dfa61_T17[] =
    {
	4, 6, -1, 3, 11, 12, 3, 3, 9, -1, 3, 5, 5, -1, -1, 3, 3, -1, -1, 3, 3, 
	3, 10, 8, 7, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T18[] =
    {
	4, 118, -1, 119, 4, 39, -1, 88, 4, -1, 120, 117, 117, -1, -1, 119, 119, 
	-1, -1, 88, 63, 121, 4, 119, 119, 4, 4, -1, 4, 4, -1, -1, -1, -1, 119, 
	119, 119, 119
    };static const ANTLR3_INT32 dfa61_T19[] =
    {
	4, 61, -1, 62, 4, 39, -1, 3, 4, -1, 64, 60, 60, -1, -1, 62, 62, -1, -1, 
	3, 63, 65, 4, 62, 62, 4, 4, -1, 4, 4, -1, -1, -1, -1, 62, 62, 62, 62
    };static const ANTLR3_INT32 dfa61_T20[] =
    {
	4, 90, -1, 4, -1, -1, -1, -1, 4, -1, 4, 89, 4, 4, -1, 4, 4, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa61_T21[] =
    {
	4, 131, -1, 3, 11, 12, 88, 88, 9, -1, 88, 14, 14, -1, -1, 3, 3, -1, -1, 
	88, 88, 88, 10, 36, 15, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T22[] =
    {
	132, -1, -1, -1, -1, -1, -1, -1, -1, -1, 132
    };static const ANTLR3_INT32 dfa61_T23[] =
    {
	128, -1, -1, -1, -1, -1, -1, -1, -1, -1, 128
    };static const ANTLR3_INT32 dfa61_T24[] =
    {
	110, -1, -1, -1, -1, -1, -1, -1, -1, -1, 110
    };static const ANTLR3_INT32 dfa61_T25[] =
    {
	73, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73
    };static const ANTLR3_INT32 dfa61_T26[] =
    {
	37, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 3, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T27[] =
    {
	2, -1, 3, 3, 3, 3, 3, -1, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, -1, 3, 3, 
	3, 3, 3, 4, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T28[] =
    {
	4, 50, -1, 4, 4, 4, -1, 4, -1, -1, 4, 49, 4, -1, -1, 4, 4, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa61_T29[] =
    {
	4, 75, 4, 76, 3, 3, 3, 3, 3, -1, 78, 74, 74, -1, -1, 76, 76, -1, -1, 3, 
	3, 3, 3, 76, 76, -1, -1, -1, -1, 77, 4, -1, -1, -1, 76, 76, 76, 76
    };static const ANTLR3_INT32 dfa61_T30[] =
    {
	4, 57, -1, 58, -1, 88, -1, 88, 4, -1, 59, 56, 56, 4, -1, 58, 58, -1, -1, 
	88, 88, 88, -1, 58, 58, -1, -1, -1, -1, 4, 4, -1, -1, -1, 58, 58, 58, 58
    };static const ANTLR3_INT32 dfa61_T31[] =
    {
	6, -1, 3, 3, 3, 3, 3, 3, -1, 3, 5, 5, -1, -1, 3, 3, -1, -1, 3, 3, 3, 3, 
	3, 7, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T32[] =
    {
	82, -1, 83, 4, 88, 4, 85, -1, -1, 86, 81, 81, -1, -1, 83, 83, -1, -1, 88, 
	84, 87, 4, 83, 83, 4, -1, -1, -1, 4, -1, -1, -1, -1, 83, 83, 83, 83
    };static const ANTLR3_INT32 dfa61_T33[] =
    {
	54, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 55, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T34[] =
    {
	107, -1, 3, 88, 88, 88, 88, 88, -1, 88, 14, 14, -1, -1, 3, 3, -1, -1, 88, 
	88, 88, 88, 108, 15, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T35[] =
    {
	13, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 16, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T36[] =
    {
	4, 80, -1, 4, 4, 4, -1, 4, -1, -1, 4, 79, 4, -1, -1, 4, 4, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa61_T37[] =
    {
	4, 53, -1, 4, -1, -1, -1, -1, 4, -1, 4, 52, 4, 4, -1, 4, 4, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa61_T38[] =
    {
	4, 37, -1, 3, 11, 12, 88, 88, 9, -1, 88, 14, 14, -1, -1, 3, 3, -1, -1, 
	88, 88, 88, 10, 36, 15, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T39[] =
    {
	35, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 16, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T40[] =
    {
	91, -1, 3, 88, 88, 88, 88, 88, -1, 88, 14, 14, -1, -1, 3, 3, -1, -1, 88, 
	88, 88, 88, 55, 15, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T41[] =
    {
	4, 114, -1, 4, 4, 4, -1, -1, -1, -1, 4, 113, 4, -1, -1, 4, 4, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa61_T42[] =
    {
	4, 17, -1, 3, 11, 12, 3, 3, 9, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, 3, 3, 
	3, 10, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T43[] =
    {
	4, 31, 4, 32, 3, 3, 3, 3, 3, -1, 34, 30, 30, 4, -1, 32, 32, -1, -1, 3, 
	3, 3, 3, 32, 32, -1, -1, -1, -1, 33, 4, -1, -1, -1, 32, 32, 32, 32
    };static const ANTLR3_INT32 dfa61_T44[] =
    {
	4, 18, -1, 3, 4, 39, -1, 3, -1, -1, 3, 3, 3, -1, -1, 3, 3, -1, -1, 3, 3, 
	3, 4, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T45[] =
    {
	21, -1, 22, 88, 88, 88, 46, 19, -1, 24, 20, 20, -1, -1, 22, 22, -1, -1, 
	88, 88, 24, 24, 22, 22, 4, 4, -1, 4, 23, -1, -1, -1, -1, 22, 22, 22, 22
    };static const ANTLR3_INT32 dfa61_T46[] =
    {
	94, -1, 95, -1, 88, -1, 88, 4, -1, 96, 93, 93, -1, -1, 95, 95, -1, -1, 
	88, 88, 97, 4, 95, 95, 4, 4, -1, 4, 4, -1, -1, -1, -1, 95, 95, 95, 95
    };static const ANTLR3_INT32 dfa61_T47[] =
    {
	4, 26, -1, 27, 11, 12, 88, 48, 88, -1, 29, 25, 25, -1, -1, 27, 27, -1, 
	-1, 88, 88, 88, 88, 27, 27, -1, -1, -1, -1, 28, 4, -1, -1, -1, 27, 27, 
	27, 27
    };static const ANTLR3_INT32 dfa61_T48[] =
    {
	37, -1, 3, 88, 88, 88, 88, 88, -1, 88, 14, 14, -1, -1, 3, 3, -1, -1, 88, 
	88, 88, 88, 108, 15, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T49[] =
    {
	4, 68, -1, 69, 11, 12, 3, 3, 66, -1, 71, 67, 67, -1, -1, 69, 69, -1, -1, 
	3, 72, 71, 71, 69, 69, 4, 4, -1, 4, 70, -1, -1, -1, -1, 69, 69, 69, 69
    };static const ANTLR3_INT32 dfa61_T50[] =
    {
	101, -1, 102, 88, 88, 88, 88, 99, -1, 104, 100, 100, -1, -1, 102, 102, 
	-1, -1, 88, 88, 104, 104, 102, 102, 4, 4, -1, 4, 103, -1, -1, -1, -1, 102, 
	102, 102, 102
    };static const ANTLR3_INT32 dfa61_T51[] =
    {
	37, -1, 3, 88, 88, 88, 88, 88, -1, 88, 14, 14, -1, -1, 3, 3, -1, -1, 88, 
	88, 88, 88, 55, 15, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T52[] =
    {
	38, -1, 3, 3, 3, 3, 3, 3, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, 3, 3, 3, 3, 
	3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T53[] =
    {
	116, -1, 3, 88, 88, 88, 88, 88, -1, 88, 1, 1, -1, -1, 3, 3, -1, -1, 88, 
	88, 88, 88, 3, 3, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T54[] =
    {
	92, -1, 3, 88, 88, 88, 88, 88, -1, 88, 1, 1, -1, -1, 3, 3, -1, -1, 88, 
	88, 88, 88, 3, 3, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T55[] =
    {
	21, -1, 22, 3, 3, 3, 3, 19, -1, 24, 20, 20, -1, -1, 22, 22, -1, -1, 3, 
	3, 24, 24, 22, 22, 4, 4, -1, 4, 23, -1, -1, -1, -1, 22, 22, 22, 22
    };static const ANTLR3_INT32 dfa61_T56[] =
    {
	4, 26, -1, 27, 3, 3, 3, 3, 3, -1, 29, 25, 25, -1, -1, 27, 27, -1, -1, 3, 
	3, 3, 3, 27, 27, -1, -1, -1, -1, 28, 4, -1, -1, -1, 27, 27, 27, 27
    };static const ANTLR3_INT32 dfa61_T57[] =
    {
	18, -1, 3, -1, 3, -1, 3, -1, -1, 3, 3, 3, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	-1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T58[] =
    {
	4, 31, -1, 32, 88, 88, 88, 88, 51, -1, 34, 30, 30, 4, -1, 32, 32, -1, -1, 
	88, 88, 88, 88, 32, 32, -1, -1, -1, -1, 33, 4, -1, -1, -1, 32, 32, 32, 
	32
    };static const ANTLR3_INT32 dfa61_T59[] =
    {
	115, -1, 3, 88, 88, 88, 88, 88, -1, 88, 14, 14, -1, -1, 3, 3, -1, -1, 88, 
	88, 88, 88, 108, 15, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T60[] =
    {
	4, 106, -1, 4, 4, 4, -1, -1, -1, -1, 4, 105, 4, -1, -1, 4, 4, -1, -1, -1, 
	-1, -1, -1, 4, 4, -1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa61_T61[] =
    {
	37, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 16, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa61_T62[] =
    {
	4, 129, -1, 3, 11, 12, 88, 88, 9, -1, 88, 14, 14, -1, -1, 3, 3, -1, -1, 
	88, 88, 88, 10, 36, 15, -1, -1, -1, -1, 88, -1, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa61_transitions[] =
{
    dfa61_T27, dfa61_T17, dfa61_T35, dfa61_T_empty, dfa61_T_empty, dfa61_T17, 
    dfa61_T17, dfa61_T31, dfa61_T42, dfa61_T57, dfa61_T55, dfa61_T56, dfa61_T43, 
    dfa61_T39, dfa61_T15, dfa61_T26, dfa61_T52, dfa61_T15, dfa61_T44, dfa61_T6, 
    dfa61_T14, dfa61_T14, dfa61_T14, dfa61_T9, dfa61_T14, dfa61_T3, dfa61_T3, 
    dfa61_T3, dfa61_T28, dfa61_T3, dfa61_T2, dfa61_T2, dfa61_T2, dfa61_T37, 
    dfa61_T2, dfa61_T61, dfa61_T11, dfa61_T15, dfa61_T33, dfa61_T1, dfa61_T19, 
    dfa61_T6, dfa61_T6, dfa61_T6, dfa61_T6, dfa61_T6, dfa61_T49, dfa61_T25, 
    dfa61_T29, dfa61_T36, dfa61_T36, dfa61_T32, dfa61_T20, dfa61_T20, dfa61_T40, 
    dfa61_T54, dfa61_T30, dfa61_T30, dfa61_T30, dfa61_T30, dfa61_T16, dfa61_T16, 
    dfa61_T16, dfa61_T46, dfa61_T16, dfa61_T16, dfa61_T16, dfa61_T0, dfa61_T0, 
    dfa61_T0, dfa61_T10, dfa61_T0, dfa61_T50, dfa61_T45, dfa61_T4, dfa61_T4, 
    dfa61_T4, dfa61_T60, dfa61_T4, dfa61_T47, dfa61_T47, dfa61_T_empty, 
    dfa61_T_empty, dfa61_T_empty, dfa61_T_empty, dfa61_T_empty, dfa61_T_empty, 
    dfa61_T_empty, dfa61_T_empty, dfa61_T58, dfa61_T58, dfa61_T51, dfa61_T34, 
    dfa61_T5, dfa61_T5, dfa61_T5, dfa61_T5, dfa61_T5, dfa61_T24, dfa61_T5, 
    dfa61_T13, dfa61_T13, dfa61_T13, dfa61_T8, dfa61_T13, dfa61_T41, dfa61_T41, 
    dfa61_T59, dfa61_T53, dfa61_T18, dfa61_T0, dfa61_T12, dfa61_T23, dfa61_T4, 
    dfa61_T4, dfa61_T48, dfa61_T62, dfa61_T18, dfa61_T18, dfa61_T18, dfa61_T18, 
    dfa61_T18, dfa61_T18, dfa61_T12, dfa61_T12, dfa61_T12, dfa61_T7, dfa61_T12, 
    dfa61_T13, dfa61_T21, dfa61_T22, dfa61_T38, dfa61_T12	
};


/* Declare tracking structure for Cyclic DFA 61
 */
static
ANTLR3_CYCLIC_DFA cdfa61
    =	{
	    61,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1277:43: ( ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa61_eot,	    /* EOT table			    */
	    dfa61_eof,	    /* EOF table			    */
	    dfa61_min,	    /* Minimum tokens for each state    */
	    dfa61_max,	    /* Maximum tokens for each state    */
	    dfa61_accept,	/* Accept table			    */
	    dfa61_special,	/* Special transition states	    */
	    dfa61_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 61
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1289:33: ( ( userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] )
 */
static const ANTLR3_INT32 dfa63_eot[124] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa63_eof[124] =
    {
	-1, 4, -1, -1, -1, 4, -1, 4, -1, 4, 4, -1, -1, -1, -1, -1, -1, 4, 4, 4, 
	4, 4, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 
	4, -1, 4, -1, -1, -1, -1, -1, 4, -1, -1, 4, -1, -1, -1, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, -1, 4, 4, 4, 4, 4, 4, -1, 4, 4, 4, 4, 4, -1, -1, 4, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	4, 4, 4, 4, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, 4, -1, 4, -1, 4, 
	4
    };
static const ANTLR3_INT32 dfa63_min[124] =
    {
	6, 5, 6, -1, -1, 5, 6, 5, 6, 5, 5, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 6, 
	5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 
	6, 5, 6, 6, 5, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 5, 5, 
	5, 5, 5, 6, 5, 5, 5, 5, 5, 6, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 5, 
	6, 5, 6, 5, 5
    };
static const ANTLR3_INT32 dfa63_max[124] =
    {
	42, 42, 42, -1, -1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 16, 42, 42, 42, 42, 42, 42, 16, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 16, 42, 42, 42, 42, 42, 42, 42, 16, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 16, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 16, 42, 42, 42, 42, 42, 16, 42, 42, 42, 
	42, 42, 16, 42, 42, 42, 42, 16, 42, 42, 42, 42, 42, 42, 42, 16, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 42, 16, 42, 42, 42, 16, 42, 42
    };
static const ANTLR3_INT32 dfa63_accept[124] =
    {
	-1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa63_special[124] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa63_T_empty	    NULL

static const ANTLR3_INT32 dfa63_T0[] =
    {
	4, 115, 4, 116, 3, 3, 3, 3, 113, -1, 118, 114, 114, -1, 4, 116, 116, -1, 
	-1, 3, 81, 118, 118, 116, 116, 4, 4, -1, 4, 117, -1, -1, -1, -1, 116, 116, 
	116, 116
    };static const ANTLR3_INT32 dfa63_T1[] =
    {
	4, 64, 4, 66, 7, 3, 68, 3, 65, -1, 68, 63, 63, -1, 4, 66, 66, -1, -1, 3, 
	68, 68, 8, 62, 66, 4, 4, -1, -1, 67, -1, -1, -1, -1, 66, 66, 66, 66
    };static const ANTLR3_INT32 dfa63_T2[] =
    {
	4, 72, 4, 73, -1, 3, -1, 3, 4, -1, 70, 71, 71, -1, 4, 73, 73, -1, -1, 3, 
	74, 75, 4, 73, 73, 4, 4, -1, 4, 4, -1, -1, -1, -1, 73, 73, 73, 73
    };static const ANTLR3_INT32 dfa63_T3[] =
    {
	4, 78, 4, 79, 3, 3, 3, 3, 76, -1, 82, 77, 77, -1, 4, 79, 79, -1, -1, 3, 
	81, 82, 82, 79, 79, 4, 4, -1, 4, 80, -1, -1, -1, -1, 79, 79, 79, 79
    };static const ANTLR3_INT32 dfa63_T4[] =
    {
	46, -1, 47, -1, 3, -1, 48, 4, -1, 49, 45, 45, -1, -1, 47, 47, -1, -1, 3, 
	3, 50, 4, 47, 47, 4, 4, -1, 4, 4, -1, -1, -1, -1, 47, 47, 47, 47
    };static const ANTLR3_INT32 dfa63_T5[] =
    {
	89, -1, 90, -1, 3, -1, 102, 4, -1, 87, 88, 88, -1, -1, 90, 90, -1, -1, 
	3, 3, 91, 4, 90, 90, 4, 4, -1, 4, 4, -1, -1, -1, -1, 90, 90, 90, 90
    };static const ANTLR3_INT32 dfa63_T6[] =
    {
	121, -1, -1, -1, -1, -1, -1, -1, -1, -1, 121
    };static const ANTLR3_INT32 dfa63_T7[] =
    {
	105, -1, -1, -1, -1, -1, -1, -1, -1, -1, 105
    };static const ANTLR3_INT32 dfa63_T8[] =
    {
	52, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52
    };static const ANTLR3_INT32 dfa63_T9[] =
    {
	86, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86
    };static const ANTLR3_INT32 dfa63_T10[] =
    {
	92, -1, -1, -1, -1, -1, -1, -1, -1, -1, 92
    };static const ANTLR3_INT32 dfa63_T11[] =
    {
	16, -1, 3, 3, 3, 3, 3, 3, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, 3, 3, 3, 3, 
	3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T12[] =
    {
	27, -1, 28, 3, 3, 3, 51, 25, -1, 30, 26, 26, -1, -1, 28, 28, -1, -1, 3, 
	3, 30, 30, 28, 28, 4, 4, -1, 4, 29, -1, -1, -1, -1, 28, 28, 28, 28
    };static const ANTLR3_INT32 dfa63_T13[] =
    {
	95, -1, 96, 3, 3, 3, 104, 93, -1, 98, 94, 94, -1, -1, 96, 96, -1, -1, 3, 
	3, 98, 98, 96, 96, 4, 4, -1, 4, 97, -1, -1, -1, -1, 96, 96, 96, 96
    };static const ANTLR3_INT32 dfa63_T14[] =
    {
	34, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 33, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T15[] =
    {
	4, 17, 4, 3, 4, 3, -1, 3, -1, -1, 3, 3, 3, -1, 4, 3, 3, -1, -1, 3, 3, 3, 
	4, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T16[] =
    {
	4, 37, 4, 39, 4, 3, 4, 41, 4, -1, 40, 36, 36, -1, 4, 39, 39, -1, -1, 3, 
	38, 42, 4, 35, 39, 4, 4, -1, -1, 4, -1, -1, -1, -1, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa63_T17[] =
    {
	4, 20, 4, 24, 7, 3, 23, 43, 18, -1, 23, 19, 19, -1, 4, 24, 24, -1, -1, 
	3, 23, 23, 8, 21, 24, 4, 4, -1, -1, 22, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa63_T18[] =
    {
	4, 57, 4, 59, 4, 3, 4, 3, 4, -1, 60, 56, 56, -1, 4, 59, 59, -1, -1, 3, 
	58, 61, 4, 55, 59, 4, 4, -1, -1, 4, -1, -1, -1, -1, 59, 59, 59, 59
    };static const ANTLR3_INT32 dfa63_T19[] =
    {
	4, 120, 4, 3, 7, 3, 3, 3, 6, -1, 3, 14, 14, -1, 4, 3, 3, -1, -1, 3, 3, 
	3, 8, 33, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T20[] =
    {
	4, 20, 4, 24, 7, 3, 23, 3, 18, -1, 23, 19, 19, -1, 4, 24, 24, -1, -1, 3, 
	23, 23, 8, 21, 24, 4, 4, -1, -1, 22, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa63_T21[] =
    {
	4, 109, 4, 110, -1, 3, -1, 3, 4, -1, 111, 108, 108, -1, 4, 110, 110, -1, 
	-1, 3, 74, 112, 4, 110, 110, 4, 4, -1, 4, 4, -1, -1, -1, -1, 110, 110, 
	110, 110
    };static const ANTLR3_INT32 dfa63_T22[] =
    {
	123, -1, -1, -1, -1, -1, -1, -1, -1, -1, 123
    };static const ANTLR3_INT32 dfa63_T23[] =
    {
	119, -1, -1, -1, -1, -1, -1, -1, -1, -1, 119
    };static const ANTLR3_INT32 dfa63_T24[] =
    {
	34, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 3, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T25[] =
    {
	83, -1, -1, -1, -1, -1, -1, -1, -1, -1, 83
    };static const ANTLR3_INT32 dfa63_T26[] =
    {
	101, -1, -1, -1, -1, -1, -1, -1, -1, -1, 101
    };static const ANTLR3_INT32 dfa63_T27[] =
    {
	103, -1, -1, -1, -1, -1, -1, -1, -1, -1, 103
    };static const ANTLR3_INT32 dfa63_T28[] =
    {
	4, 16, 4, 3, 7, 3, 3, 3, 6, -1, 3, 1, 1, -1, 4, 3, 3, -1, -1, 3, 3, 3, 
	8, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T29[] =
    {
	10, -1, 3, 3, 3, 3, 3, 3, -1, 3, 9, 9, -1, -1, 3, 3, -1, -1, 3, 3, 3, 3, 
	3, 11, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T30[] =
    {
	57, -1, 59, -1, 3, 4, 3, 4, -1, 60, 56, 56, -1, -1, 59, 59, -1, -1, 3, 
	58, 61, -1, 55, 59, 4, 4, -1, -1, 4, -1, -1, -1, -1, 59, 59, 59, 59
    };static const ANTLR3_INT32 dfa63_T31[] =
    {
	53, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 54, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T32[] =
    {
	99, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 100, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T33[] =
    {
	12, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 13, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T34[] =
    {
	4, 10, 4, 3, 7, 3, 3, 3, 6, -1, 3, 9, 9, -1, 4, 3, 3, -1, -1, 3, 3, 3, 
	8, 5, 11, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T35[] =
    {
	64, -1, 66, 3, 3, 68, 3, 65, -1, 68, 63, 63, -1, -1, 66, 66, -1, -1, 3, 
	68, 68, 3, 62, 66, 4, 4, -1, -1, 67, -1, -1, -1, -1, 66, 66, 66, 66
    };static const ANTLR3_INT32 dfa63_T36[] =
    {
	44, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44
    };static const ANTLR3_INT32 dfa63_T37[] =
    {
	31, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 13, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T38[] =
    {
	84, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 54, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T39[] =
    {
	4, 34, 4, 3, 7, 3, 3, 3, 6, -1, 3, 14, 14, -1, 4, 3, 3, -1, -1, 3, 3, 3, 
	8, 33, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T40[] =
    {
	89, -1, 90, -1, 3, -1, 3, 4, -1, 87, 88, 88, -1, -1, 90, 90, -1, -1, 3, 
	3, 91, 4, 90, 90, 4, 4, -1, 4, 4, -1, -1, -1, -1, 90, 90, 90, 90
    };static const ANTLR3_INT32 dfa63_T41[] =
    {
	69, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69
    };static const ANTLR3_INT32 dfa63_T42[] =
    {
	34, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 100, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T43[] =
    {
	2, -1, 3, 3, 3, 3, 3, -1, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, -1, 3, 3, 
	3, 3, 3, 4, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T44[] =
    {
	95, -1, 96, 3, 3, 3, 3, 93, -1, 98, 94, 94, -1, -1, 96, 96, -1, -1, 3, 
	3, 98, 98, 96, 96, 4, 4, -1, 4, 97, -1, -1, -1, -1, 96, 96, 96, 96
    };static const ANTLR3_INT32 dfa63_T45[] =
    {
	34, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 54, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T46[] =
    {
	32, -1, 3, 3, 3, 3, 3, 3, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, 3, 3, 3, 3, 
	3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T47[] =
    {
	107, -1, 3, 3, 3, 3, 3, 3, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T48[] =
    {
	85, -1, 3, 3, 3, 3, 3, 3, -1, 3, 1, 1, -1, -1, 3, 3, -1, -1, 3, 3, 3, 3, 
	3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T49[] =
    {
	4, 122, 4, 3, 7, 3, 3, 3, 6, -1, 3, 14, 14, -1, 4, 3, 3, -1, -1, 3, 3, 
	3, 8, 33, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T50[] =
    {
	27, -1, 28, 3, 3, 3, 3, 25, -1, 30, 26, 26, -1, -1, 28, 28, -1, -1, 3, 
	3, 30, 30, 28, 28, 4, 4, -1, 4, 29, -1, -1, -1, -1, 28, 28, 28, 28
    };static const ANTLR3_INT32 dfa63_T51[] =
    {
	17, -1, 3, -1, 3, -1, 3, -1, -1, 3, 3, 3, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	-1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T52[] =
    {
	106, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 100, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa63_T53[] =
    {
	34, -1, 3, 3, 3, 3, 3, 3, -1, 3, 14, 14, -1, -1, 3, 3, -1, -1, 3, 3, 3, 
	3, 13, 15, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa63_transitions[] =
{
    dfa63_T43, dfa63_T34, dfa63_T33, dfa63_T_empty, dfa63_T_empty, dfa63_T28, 
    dfa63_T51, dfa63_T20, dfa63_T50, dfa63_T34, dfa63_T34, dfa63_T29, dfa63_T37, 
    dfa63_T46, dfa63_T14, dfa63_T24, dfa63_T14, dfa63_T15, dfa63_T16, dfa63_T17, 
    dfa63_T17, dfa63_T17, dfa63_T36, dfa63_T17, dfa63_T17, dfa63_T4, dfa63_T12, 
    dfa63_T12, dfa63_T12, dfa63_T8, dfa63_T12, dfa63_T53, dfa63_T31, dfa63_T11, 
    dfa63_T14, dfa63_T16, dfa63_T16, dfa63_T16, dfa63_T16, dfa63_T16, dfa63_T16, 
    dfa63_T30, dfa63_T16, dfa63_T35, dfa63_T41, dfa63_T4, dfa63_T4, dfa63_T4, 
    dfa63_T2, dfa63_T4, dfa63_T4, dfa63_T3, dfa63_T25, dfa63_T38, dfa63_T48, 
    dfa63_T18, dfa63_T18, dfa63_T18, dfa63_T18, dfa63_T18, dfa63_T18, dfa63_T18, 
    dfa63_T1, dfa63_T1, dfa63_T1, dfa63_T18, dfa63_T1, dfa63_T9, dfa63_T1, 
    dfa63_T17, dfa63_T2, dfa63_T2, dfa63_T2, dfa63_T2, dfa63_T40, dfa63_T2, 
    dfa63_T2, dfa63_T3, dfa63_T3, dfa63_T3, dfa63_T10, dfa63_T44, dfa63_T3, 
    dfa63_T12, dfa63_T45, dfa63_T32, dfa63_T26, dfa63_T5, dfa63_T5, dfa63_T5, 
    dfa63_T5, dfa63_T5, dfa63_T27, dfa63_T5, dfa63_T13, dfa63_T13, dfa63_T13, 
    dfa63_T7, dfa63_T13, dfa63_T52, dfa63_T47, dfa63_T1, dfa63_T21, dfa63_T3, 
    dfa63_T0, dfa63_T23, dfa63_T42, dfa63_T19, dfa63_T21, dfa63_T21, dfa63_T21, 
    dfa63_T21, dfa63_T21, dfa63_T21, dfa63_T0, dfa63_T0, dfa63_T0, dfa63_T6, 
    dfa63_T0, dfa63_T13, dfa63_T49, dfa63_T22, dfa63_T39, dfa63_T0	
};


/* Declare tracking structure for Cyclic DFA 63
 */
static
ANTLR3_CYCLIC_DFA cdfa63
    =	{
	    63,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1289:33: ( ( userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa63_eot,	    /* EOT table			    */
	    dfa63_eof,	    /* EOF table			    */
	    dfa63_min,	    /* Minimum tokens for each state    */
	    dfa63_max,	    /* Maximum tokens for each state    */
	    dfa63_accept,	/* Accept table			    */
	    dfa63_special,	/* Special transition states	    */
	    dfa63_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 63
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 1326:21: ( domainlabel '.' )*
 */
static const ANTLR3_INT32 dfa72_eot[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa72_eof[8] =
    {
	-1, 4, -1, 4, -1, 4, 4, -1
    };
static const ANTLR3_INT32 dfa72_min[8] =
    {
	6, 5, -1, 5, -1, 5, 5, 6
    };
static const ANTLR3_INT32 dfa72_max[8] =
    {
	17, 29, -1, 27, -1, 29, 29, 29
    };
static const ANTLR3_INT32 dfa72_accept[8] =
    {
	-1, -1, 1, -1, 2, -1, -1, -1
    };
static const ANTLR3_INT32 dfa72_special[8] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa72_T_empty	    NULL

static const ANTLR3_INT32 dfa72_T0[] =
    {
	4, 6, 4, -1, 4, 4, -1, -1, 4, -1, -1, 5, 5, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, 4, 3, 7
    };static const ANTLR3_INT32 dfa72_T1[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 5, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 7
    };static const ANTLR3_INT32 dfa72_T2[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1
    };static const ANTLR3_INT32 dfa72_T3[] =
    {
	4, 2, 4, -1, 4, 4, -1, -1, 4, -1, -1, 2, 2, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa72_transitions[] =
{
    dfa72_T2, dfa72_T0, dfa72_T_empty, dfa72_T3, dfa72_T_empty, dfa72_T0, 
    dfa72_T0, dfa72_T1	
};


/* Declare tracking structure for Cyclic DFA 72
 */
static
ANTLR3_CYCLIC_DFA cdfa72
    =	{
	    72,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 1326:21: ( domainlabel '.' )*",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa72_eot,	    /* EOT table			    */
	    dfa72_eof,	    /* EOF table			    */
	    dfa72_min,	    /* Minimum tokens for each state    */
	    dfa72_max,	    /* Maximum tokens for each state    */
	    dfa72_accept,	/* Accept table			    */
	    dfa72_special,	/* Special transition states	    */
	    dfa72_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 72
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1334:1: hexpart : ( hexseq | hexseq '::' ( hexseq )? | '::' ( hexseq )? );
 */
static const ANTLR3_INT32 dfa81_eot[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa81_eof[10] =
    {
	-1, 5, -1, -1, -1, -1, 5, 5, 5, 5
    };
static const ANTLR3_INT32 dfa81_min[10] =
    {
	6, 5, -1, 6, -1, -1, 5, 5, 5, 5
    };
static const ANTLR3_INT32 dfa81_max[10] =
    {
	32, 32, -1, 16, -1, -1, 32, 32, 32, 32
    };
static const ANTLR3_INT32 dfa81_accept[10] =
    {
	-1, -1, 3, -1, 2, 1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa81_special[10] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa81_T_empty	    NULL

static const ANTLR3_INT32 dfa81_T0[] =
    {
	5, 8, -1, -1, 5, 5, -1, -1, 3, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 5, -1, -1, 5, 4
    };static const ANTLR3_INT32 dfa81_T1[] =
    {
	5, 7, -1, -1, 5, 5, -1, -1, 3, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 5, 4
    };static const ANTLR3_INT32 dfa81_T2[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7
    };static const ANTLR3_INT32 dfa81_T3[] =
    {
	5, 1, -1, -1, 5, 5, -1, -1, 3, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 5, 4
    };static const ANTLR3_INT32 dfa81_T4[] =
    {
	5, 7, -1, -1, 5, 5, -1, -1, 3, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 5, -1, -1, 5, 4
    };static const ANTLR3_INT32 dfa81_T5[] =
    {
	5, 9, -1, -1, 5, 5, -1, -1, 3, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 5, -1, -1, 5, 4
    };static const ANTLR3_INT32 dfa81_T6[] =
    {
	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 2
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa81_transitions[] =
{
    dfa81_T6, dfa81_T3, dfa81_T_empty, dfa81_T2, dfa81_T_empty, dfa81_T_empty, 
    dfa81_T0, dfa81_T1, dfa81_T5, dfa81_T4	
};


/* Declare tracking structure for Cyclic DFA 81
 */
static
ANTLR3_CYCLIC_DFA cdfa81
    =	{
	    81,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1334:1: hexpart : ( hexseq | hexseq '::' ( hexseq )? | '::' ( hexseq )? );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa81_eot,	    /* EOT table			    */
	    dfa81_eof,	    /* EOF table			    */
	    dfa81_min,	    /* Minimum tokens for each state    */
	    dfa81_max,	    /* Maximum tokens for each state    */
	    dfa81_accept,	/* Accept table			    */
	    dfa81_special,	/* Special transition states	    */
	    dfa81_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 81
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1347:1: other_param : ( pname | ( pname EQUAL pvalue ) );
 */
static const ANTLR3_INT32 dfa87_eot[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa87_eof[11] =
    {
	-1, 8, 8, 8, 8, 8, -1, -1, -1, -1, 8
    };
static const ANTLR3_INT32 dfa87_min[11] =
    {
	6, 5, 5, 5, 5, 5, 6, -1, -1, 6, 5
    };
static const ANTLR3_INT32 dfa87_max[11] =
    {
	42, 42, 42, 42, 42, 42, 16, -1, -1, 16, 42
    };
static const ANTLR3_INT32 dfa87_accept[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, 2, 1, -1, -1
    };
static const ANTLR3_INT32 dfa87_special[11] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa87_T_empty	    NULL

static const ANTLR3_INT32 dfa87_T0[] =
    {
	8, 3, 8, 5, 8, -1, 4, 7, 4, -1, 4, 2, 2, -1, 8, 5, 5, -1, -1, -1, 4, 4, 
	8, 1, 5, 4, 4, -1, -1, 6, -1, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa87_T1[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10
    };static const ANTLR3_INT32 dfa87_T2[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9
    };static const ANTLR3_INT32 dfa87_T3[] =
    {
	3, -1, 5, -1, -1, 4, -1, 4, -1, 4, 2, 2, -1, -1, 5, 5, -1, -1, -1, 4, 4, 
	-1, 1, 5, 4, 4, -1, -1, 6, -1, -1, -1, -1, 5, 5, 5, 5
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa87_transitions[] =
{
    dfa87_T3, dfa87_T0, dfa87_T0, dfa87_T0, dfa87_T0, dfa87_T0, dfa87_T2, 
    dfa87_T_empty, dfa87_T_empty, dfa87_T1, dfa87_T0	
};


/* Declare tracking structure for Cyclic DFA 87
 */
static
ANTLR3_CYCLIC_DFA cdfa87
    =	{
	    87,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1347:1: other_param : ( pname | ( pname EQUAL pvalue ) );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa87_eot,	    /* EOT table			    */
	    dfa87_eof,	    /* EOF table			    */
	    dfa87_min,	    /* Minimum tokens for each state    */
	    dfa87_max,	    /* Maximum tokens for each state    */
	    dfa87_accept,	/* Accept table			    */
	    dfa87_special,	/* Special transition states	    */
	    dfa87_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 87
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */ 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start message
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:61:1: message returns [belle_sip_message_t* ret] : message_raw[&($message::message_length)] ;
 */
static belle_sip_message_t*
message(pbelle_sip_messageParser ctx)
{   
    belle_sip_message_t* ret = NULL;

    belle_sip_message_t* message_raw1;
    #undef	RETURN_TYPE_message_raw1
    #define	RETURN_TYPE_message_raw1 belle_sip_message_t*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_messageTop = pbelle_sip_messageParser_messagePush(ctx);
    ret=NULL;
    message_raw1 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:64:3: ( message_raw[&($message::message_length)] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:64:5: message_raw[&($message::message_length)]
        {
            FOLLOWPUSH(FOLLOW_message_raw_in_message63);
            message_raw1=message_raw(ctx, &(	(SCOPE_TOP(message))->message_length));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemessageEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_messagePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=message_raw1;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessageEx; /* Prevent compiler warnings */
    rulemessageEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_messagePop(ctx);

    return ret;
}
/* $ANTLR end message */

/** 
 * $ANTLR start message_raw
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:65:1: message_raw[size_t* length] returns [belle_sip_message_t* ret] : ( request | response );
 */
static belle_sip_message_t*
message_raw(pbelle_sip_messageParser ctx, size_t* length)
{   
    belle_sip_message_t* ret = NULL;

    belle_sip_request_t* request2;
    #undef	RETURN_TYPE_request2
    #define	RETURN_TYPE_request2 belle_sip_request_t*

    belle_sip_response_t* response3;
    #undef	RETURN_TYPE_response3
    #define	RETURN_TYPE_response3 belle_sip_response_t*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_message_rawTop = pbelle_sip_messageParser_message_rawPush(ctx);
    	(SCOPE_TOP(message_raw))->message_length=length;ret=NULL;
    request2 = NULL;
    response3 = NULL;

    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:68:2: ( request | response )
            
            ANTLR3_UINT32 alt1;

            alt1=2;

            alt1 = cdfa1.predict(ctx, RECOGNIZER, ISTREAM, &cdfa1);
            if  (HASEXCEPTION())
            {
                goto rulemessage_rawEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_message_rawPop(ctx);

                return ret;
            }
            switch (alt1) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:68:6: request
        	    {
        	        FOLLOWPUSH(FOLLOW_request_in_message_raw92);
        	        request2=request(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemessage_rawEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pbelle_sip_messageParser_message_rawPop(ctx);

        	            return ret;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            ret= BELLE_SIP_MESSAGE(request2);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:69:7: response
        	    {
        	        FOLLOWPUSH(FOLLOW_response_in_message_raw103);
        	        response3=response(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemessage_rawEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pbelle_sip_messageParser_message_rawPop(ctx);

        	            return ret;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            ret= BELLE_SIP_MESSAGE(response3);
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_rawEx; /* Prevent compiler warnings */
    rulemessage_rawEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_message_rawPop(ctx);

    return ret;
}
/* $ANTLR end message_raw */

/** 
 * $ANTLR start request
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:70:1: request returns [belle_sip_request_t* ret] : request_line ( message_header[BELLE_SIP_MESSAGE($request::current)] )+ last_crlf= CRLF ;
 */
static belle_sip_request_t*
request(pbelle_sip_messageParser ctx)
{   
    belle_sip_request_t* ret = NULL;

    pANTLR3_COMMON_TOKEN    last_crlf;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_requestTop = pbelle_sip_messageParser_requestPush(ctx);
    	(SCOPE_TOP(request))->current= belle_sip_request_new(); ret=	(SCOPE_TOP(request))->current; 
    last_crlf       = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:73:2: ( request_line ( message_header[BELLE_SIP_MESSAGE($request::current)] )+ last_crlf= CRLF )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:73:6: request_line ( message_header[BELLE_SIP_MESSAGE($request::current)] )+ last_crlf= CRLF
        {
            FOLLOWPUSH(FOLLOW_request_line_in_request129);
            request_line(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_requestPop(ctx);

                return ret;
            }
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:73:20: ( message_header[BELLE_SIP_MESSAGE($request::current)] )+
            {
                int cnt2=0;

                for (;;)
                {
                    int alt2=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case STAR:
            	case PLUS:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case LPAREN:
            	case RPAREN:
            	case 28:
            	case 29:
            	case 34:
            	case 35:
            	case 39:
            	case 40:
            	case 41:
            	case 42:
            		{
            			alt2=1;
            		}
            	    break;

            	}

            	switch (alt2) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:73:20: message_header[BELLE_SIP_MESSAGE($request::current)]
            	        {
            	            FOLLOWPUSH(FOLLOW_message_header_in_request132);
            	            message_header(ctx, BELLE_SIP_MESSAGE(	(SCOPE_TOP(request))->current));

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerequestEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_requestPop(ctx);

            	                return ret;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt2 >= 1 )
            		{
            		    goto loop2;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    pbelle_sip_messageParser_requestPop(ctx);

            		    return ret;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulerequestEx;
            	}
            	cnt2++;
                }
                loop2: ;	/* Jump to here if this rule does not match */
            }
            last_crlf = (pANTLR3_COMMON_TOKEN) MATCHT(CRLF, &FOLLOW_CRLF_in_request138); 
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_requestPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                *(	(SCOPE_TOP(message_raw))->message_length)=last_crlf->user1;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerequestEx; /* Prevent compiler warnings */
    rulerequestEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_requestPop(ctx);

    return ret;
}
/* $ANTLR end request */

/** 
 * $ANTLR start request_line
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:75:1: request_line : method ( SP )=> LWS uri LWS sip_version CRLF ;
 */
static void
request_line(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_method_return method4;
    #undef	RETURN_TYPE_method4
    #define	RETURN_TYPE_method4 belle_sip_messageParser_method_return

    belle_sip_uri_t* uri5;
    #undef	RETURN_TYPE_uri5
    #define	RETURN_TYPE_uri5 belle_sip_uri_t*

    /* Initialize rule variables
     */


    uri5 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:76:2: ( method ( SP )=> LWS uri LWS sip_version CRLF )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:76:6: method ( SP )=> LWS uri LWS sip_version CRLF
        {
            FOLLOWPUSH(FOLLOW_method_in_request_line157);
            method4=method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_request_set_method(	(SCOPE_TOP(request))->current,(const char*)((STRSTREAM->toStringTT(STRSTREAM, method4.start, method4.stop))->chars));
            }
             MATCHT(LWS, &FOLLOW_LWS_in_request_line171); 
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_uri_in_request_line179);
            uri5=uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_request_set_uri(	(SCOPE_TOP(request))->current,uri5);
            }
             MATCHT(LWS, &FOLLOW_LWS_in_request_line188); 
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_sip_version_in_request_line196);
            sip_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(CRLF, &FOLLOW_CRLF_in_request_line204); 
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerequest_lineEx; /* Prevent compiler warnings */
    rulerequest_lineEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end request_line */

/** 
 * $ANTLR start sip_version
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:83:1: sip_version : word ;
 */
static void
sip_version(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:84:2: ( word )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:84:4: word
        {
            FOLLOWPUSH(FOLLOW_word_in_sip_version217);
            word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesip_versionEx; /* Prevent compiler warnings */
    rulesip_versionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end sip_version */

/** 
 * $ANTLR start message_header
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:86:1: message_header[belle_sip_message_t* message] : ( header_extension[TRUE] ) CRLF ;
 */
static void
message_header(pbelle_sip_messageParser ctx, belle_sip_message_t* message)
{   
    belle_sip_messageParser_header_extension_return header_extension6;
    #undef	RETURN_TYPE_header_extension6
    #define	RETURN_TYPE_header_extension6 belle_sip_messageParser_header_extension_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:88:2: ( ( header_extension[TRUE] ) CRLF )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:88:15: ( header_extension[TRUE] ) CRLF
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:88:15: ( header_extension[TRUE] )
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:132:19: header_extension[TRUE]
            {
                FOLLOWPUSH(FOLLOW_header_extension_in_message_header293);
                header_extension6=header_extension(ctx, TRUE);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulemessage_headerEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                if ( BACKTRACKING==0 ) 
                {

                                        belle_sip_header_t* lheader = BELLE_SIP_HEADER(header_extension6.ret);
                                        do {
                                          if (lheader == NULL) break; /*sanity check*/
                                          
                                          belle_sip_message_add_header(message,lheader);
                                          }
                                        while((lheader=belle_sip_header_get_next(lheader)) != NULL); 
                }

            }

             MATCHT(CRLF, &FOLLOW_CRLF_in_message_header317); 
            if  (HASEXCEPTION())
            {
                goto rulemessage_headerEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_headerEx; /* Prevent compiler warnings */
    rulemessage_headerEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end message_header */

/** 
 * $ANTLR start method
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:155:1: method : extension_method ;
 */
static belle_sip_messageParser_method_return
method(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_method_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:155:9: ( extension_method )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:155:81: extension_method
        {
            FOLLOWPUSH(FOLLOW_extension_method_in_method364);
            extension_method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemethodEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemethodEx; /* Prevent compiler warnings */
    rulemethodEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end method */

/** 
 * $ANTLR start extension_method
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:157:1: extension_method : token ;
 */
static void
extension_method(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:158:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:158:6: token
        {
            FOLLOWPUSH(FOLLOW_token_in_extension_method378);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextension_methodEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextension_methodEx; /* Prevent compiler warnings */
    ruleextension_methodEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end extension_method */

/** 
 * $ANTLR start response
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:160:1: response returns [belle_sip_response_t* ret] : status_line ( ( message_header[BELLE_SIP_MESSAGE($response::current)] )+ last_crlf= CRLF )? ;
 */
static belle_sip_response_t*
response(pbelle_sip_messageParser ctx)
{   
    belle_sip_response_t* ret = NULL;

    pANTLR3_COMMON_TOKEN    last_crlf;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_responseTop = pbelle_sip_messageParser_responsePush(ctx);
    	(SCOPE_TOP(response))->current= belle_sip_response_new(); ret=	(SCOPE_TOP(response))->current; 
    last_crlf       = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:163:2: ( status_line ( ( message_header[BELLE_SIP_MESSAGE($response::current)] )+ last_crlf= CRLF )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:163:6: status_line ( ( message_header[BELLE_SIP_MESSAGE($response::current)] )+ last_crlf= CRLF )?
        {
            FOLLOWPUSH(FOLLOW_status_line_in_response412);
            status_line(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleresponseEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_responsePop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:163:18: ( ( message_header[BELLE_SIP_MESSAGE($response::current)] )+ last_crlf= CRLF )?
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                    case DIGIT:
                    case STAR:
                    case PLUS:
                    case HEX_CHAR:
                    case COMMON_CHAR:
                    case LPAREN:
                    case RPAREN:
                    case 28:
                    case 29:
                    case 34:
                    case 35:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:163:19: ( message_header[BELLE_SIP_MESSAGE($response::current)] )+ last_crlf= CRLF
            	    {
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:163:19: ( message_header[BELLE_SIP_MESSAGE($response::current)] )+
            	        {
            	            int cnt3=0;

            	            for (;;)
            	            {
            	                int alt3=2;
            	        	switch ( LA(1) ) 
            	        	{
            	        	case DIGIT:
            	        	case STAR:
            	        	case PLUS:
            	        	case HEX_CHAR:
            	        	case COMMON_CHAR:
            	        	case LPAREN:
            	        	case RPAREN:
            	        	case 28:
            	        	case 29:
            	        	case 34:
            	        	case 35:
            	        	case 39:
            	        	case 40:
            	        	case 41:
            	        	case 42:
            	        		{
            	        			alt3=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt3) 
            	        	{
            	        	    case 1:
            	        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:163:19: message_header[BELLE_SIP_MESSAGE($response::current)]
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_message_header_in_response415);
            	        	            message_header(ctx, BELLE_SIP_MESSAGE(	(SCOPE_TOP(response))->current));

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleresponseEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                pbelle_sip_messageParser_responsePop(ctx);

            	        	                return ret;
            	        	            }

            	        	        }
            	        	        break;

            	        	    default:
            	        	    
            	        		if ( cnt3 >= 1 )
            	        		{
            	        		    goto loop3;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    pbelle_sip_messageParser_responsePop(ctx);

            	        		    return ret;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruleresponseEx;
            	        	}
            	        	cnt3++;
            	            }
            	            loop3: ;	/* Jump to here if this rule does not match */
            	        }
            	        last_crlf = (pANTLR3_COMMON_TOKEN) MATCHT(CRLF, &FOLLOW_CRLF_in_response421); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleresponseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_responsePop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            *(	(SCOPE_TOP(message_raw))->message_length)=last_crlf->user1;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleresponseEx; /* Prevent compiler warnings */
    ruleresponseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_responsePop(ctx);

    return ret;
}
/* $ANTLR end response */

/** 
 * $ANTLR start status_line
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:165:1: status_line : sip_version LWS status_code LWS reason_phrase CRLF ;
 */
static void
status_line(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_status_code_return status_code7;
    #undef	RETURN_TYPE_status_code7
    #define	RETURN_TYPE_status_code7 belle_sip_messageParser_status_code_return

    belle_sip_messageParser_reason_phrase_return reason_phrase8;
    #undef	RETURN_TYPE_reason_phrase8
    #define	RETURN_TYPE_reason_phrase8 belle_sip_messageParser_reason_phrase_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:166:2: ( sip_version LWS status_code LWS reason_phrase CRLF )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:166:6: sip_version LWS status_code LWS reason_phrase CRLF
        {
            FOLLOWPUSH(FOLLOW_sip_version_in_status_line445);
            sip_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(LWS, &FOLLOW_LWS_in_status_line452); 
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_status_code_in_status_line454);
            status_code7=status_code(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_response_set_status_code(	(SCOPE_TOP(response))->current,atoi((char*)(STRSTREAM->toStringTT(STRSTREAM, status_code7.start, status_code7.stop))->chars));
            }
             MATCHT(LWS, &FOLLOW_LWS_in_status_line462); 
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_reason_phrase_in_status_line464);
            reason_phrase8=reason_phrase(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_response_set_reason_phrase(	(SCOPE_TOP(response))->current,(char*)(STRSTREAM->toStringTT(STRSTREAM, reason_phrase8.start, reason_phrase8.stop))->chars);
            }
             MATCHT(CRLF, &FOLLOW_CRLF_in_status_line472); 
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestatus_lineEx; /* Prevent compiler warnings */
    rulestatus_lineEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end status_line */

/** 
 * $ANTLR start status_code
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:171:1: status_code : extension_code ;
 */
static belle_sip_messageParser_status_code_return
status_code(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_status_code_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:172:2: ( extension_code )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:172:4: extension_code
        {
            FOLLOWPUSH(FOLLOW_extension_code_in_status_code488);
            extension_code(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_codeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestatus_codeEx; /* Prevent compiler warnings */
    rulestatus_codeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end status_code */

/** 
 * $ANTLR start extension_code
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:174:1: extension_code : DIGIT DIGIT DIGIT ;
 */
static void
extension_code(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:175:2: ( DIGIT DIGIT DIGIT )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:175:6: DIGIT DIGIT DIGIT
        {
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_extension_code501); 
            if  (HASEXCEPTION())
            {
                goto ruleextension_codeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_extension_code503); 
            if  (HASEXCEPTION())
            {
                goto ruleextension_codeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_extension_code505); 
            if  (HASEXCEPTION())
            {
                goto ruleextension_codeEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextension_codeEx; /* Prevent compiler warnings */
    ruleextension_codeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end extension_code */

/** 
 * $ANTLR start reason_phrase
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:176:1: reason_phrase : (~ ( CRLF ) )* ;
 */
static belle_sip_messageParser_reason_phrase_return
reason_phrase(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_reason_phrase_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:177:2: ( (~ ( CRLF ) )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:177:6: (~ ( CRLF ) )*
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:177:6: (~ ( CRLF ) )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case DIGIT:
                case DQUOTE:
                case STAR:
                case SEMI:
                case COMMA:
                case SLASH:
                case EQUAL:
                case COLON:
                case OCTET:
                case PLUS:
                case HEX_CHAR:
                case COMMON_CHAR:
                case LAQUOT:
                case RAQUOT:
                case LPAREN:
                case RPAREN:
                case HTAB:
                case SP:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:177:6: ~ ( CRLF )
            	    {
            	        if ( ((LA(1) >= LWS) && (LA(1) <= 42)) )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else 
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_reason_phrase518;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_reason_phrase518);    goto rulereason_phraseEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereason_phraseEx; /* Prevent compiler warnings */
    rulereason_phraseEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end reason_phrase */

/** 
 * $ANTLR start generic_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:207:1: generic_param[belle_sip_parameters_t* object] returns [belle_sip_param_pair_t* ret] : token ( equal gen_value )? ;
 */
static belle_sip_param_pair_t*
generic_param(pbelle_sip_messageParser ctx, belle_sip_parameters_t* object)
{   
    belle_sip_param_pair_t* ret = NULL;

    belle_sip_messageParser_token_return token9;
    #undef	RETURN_TYPE_token9
    #define	RETURN_TYPE_token9 belle_sip_messageParser_token_return

    belle_sip_messageParser_gen_value_return gen_value10;
    #undef	RETURN_TYPE_gen_value10
    #define	RETURN_TYPE_gen_value10 belle_sip_messageParser_gen_value_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_generic_paramTop = pbelle_sip_messageParser_generic_paramPush(ctx);
     	(SCOPE_TOP(generic_param))->is_value=0; ret=NULL;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:210:2: ( token ( equal gen_value )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:210:7: token ( equal gen_value )?
        {
            FOLLOWPUSH(FOLLOW_token_in_generic_param561);
            token9=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegeneric_paramEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_generic_paramPop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:210:13: ( equal gen_value )?
            {
                int alt6=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case EQUAL:
                    		    	{
                    		    		alt6=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                    case EQUAL:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:210:16: equal gen_value
            	    {
            	        FOLLOWPUSH(FOLLOW_equal_in_generic_param566);
            	        equal(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegeneric_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_generic_paramPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_gen_value_in_generic_param568);
            	        gen_value10=gen_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegeneric_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_generic_paramPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            	(SCOPE_TOP(generic_param))->is_value= 1;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {

                	                                                   if (object == NULL) {
                	                                                     ret=belle_sip_param_pair_new((const char*)((STRSTREAM->toStringTT(STRSTREAM, token9.start, token9.stop))->chars)
                	                                                                                 ,	(SCOPE_TOP(generic_param))->is_value?(const char*)((STRSTREAM->toStringTT(STRSTREAM, gen_value10.start, gen_value10.stop))->chars):NULL);
                	                                                   } else {
                	                                                     belle_sip_parameters_set_parameter(object
                	                                                                                       ,(const char*)((STRSTREAM->toStringTT(STRSTREAM, token9.start, token9.stop))->chars)
                	                                                                                       ,	(SCOPE_TOP(generic_param))->is_value?(const char*)((STRSTREAM->toStringTT(STRSTREAM, gen_value10.start, gen_value10.stop))->chars):NULL);
                	                                                     ret=NULL;
                	                                                   }
                	                                                   
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulegeneric_paramEx; /* Prevent compiler warnings */
    rulegeneric_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_generic_paramPop(ctx);

    return ret;
}
/* $ANTLR end generic_param */

/** 
 * $ANTLR start gen_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:221:1: gen_value : ( token | quoted_string );
 */
static belle_sip_messageParser_gen_value_return
gen_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_gen_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:222:2: ( token | quoted_string )
            
            ANTLR3_UINT32 alt7;

            alt7=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case STAR:
            case PLUS:
            case HEX_CHAR:
            case COMMON_CHAR:
            case LPAREN:
            case RPAREN:
            case 28:
            case 29:
            case 34:
            case 35:
            case 39:
            case 40:
            case 41:
            case 42:
            	{
            		alt7=1;
            	}
                break;
            case DQUOTE:
            	{
            		alt7=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 7;
                EXCEPTION->state        = 0;


                goto rulegen_valueEx;
            }

            switch (alt7) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:222:6: token
        	    {
        	        FOLLOWPUSH(FOLLOW_token_in_gen_value591);
        	        token(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegen_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:222:15: quoted_string
        	    {
        	        FOLLOWPUSH(FOLLOW_quoted_string_in_gen_value596);
        	        quoted_string(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegen_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulegen_valueEx; /* Prevent compiler warnings */
    rulegen_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end gen_value */

/** 
 * $ANTLR start quoted_string
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:224:1: quoted_string options {greedy=false; } : DQUOTE unquoted_value= ( ( . )* ) DQUOTE ;
 */
static belle_sip_messageParser_quoted_string_return
quoted_string(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_quoted_string_return retval;

    pANTLR3_COMMON_TOKEN    unquoted_value;

    /* Initialize rule variables
     */


    unquoted_value       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:226:2: ( DQUOTE unquoted_value= ( ( . )* ) DQUOTE )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:226:4: DQUOTE unquoted_value= ( ( . )* ) DQUOTE
        {
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_quoted_string617); 
            if  (HASEXCEPTION())
            {
                goto rulequoted_stringEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:226:26: ( ( . )* )
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:226:27: ( . )*
            {

                // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:226:27: ( . )*

                for (;;)
                {
                    int alt8=2;
                    switch ( LA(1) ) 
                    {
                    case DQUOTE:
                    	{
                    		alt8=2;
                    	}
                        break;
                    case CRLF:
                    case LWS:
                    case DIGIT:
                    case STAR:
                    case SEMI:
                    case COMMA:
                    case SLASH:
                    case EQUAL:
                    case COLON:
                    case OCTET:
                    case PLUS:
                    case HEX_CHAR:
                    case COMMON_CHAR:
                    case LAQUOT:
                    case RAQUOT:
                    case LPAREN:
                    case RPAREN:
                    case HTAB:
                    case SP:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    	{
                    		alt8=1;
                    	}
                        break;

                    }

                    switch (alt8) 
                    {
                	case 1:
                	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:226:27: .
                	    {
                	        MATCHANYT(); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulequoted_stringEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop8;	/* break out of the loop */
                	    break;
                    }
                }
                loop8: ; /* Jump out to here if this rule does not match */


            }

             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_quoted_string626); 
            if  (HASEXCEPTION())
            {
                goto rulequoted_stringEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequoted_stringEx; /* Prevent compiler warnings */
    rulequoted_stringEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end quoted_string */

/** 
 * $ANTLR start header_allow
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:254:1: header_allow returns [belle_sip_header_allow_t* ret] : {...}? token hcolon methods ;
 */
static belle_sip_header_allow_t*
header_allow(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_allow_t* ret = NULL;

    belle_sip_messageParser_methods_return methods11;
    #undef	RETURN_TYPE_methods11
    #define	RETURN_TYPE_methods11 belle_sip_messageParser_methods_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_allowTop = pbelle_sip_messageParser_header_allowPush(ctx);
    	(SCOPE_TOP(header_allow))->current= belle_sip_header_allow_new(); ret=	(SCOPE_TOP(header_allow))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:258:1: ({...}? token hcolon methods )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:258:6: {...}? token hcolon methods
        {
            if ( !((IS_TOKEN(Allow))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_allowPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Allow)";
                    EXCEPTION->ruleName	 = (void *)"header_allow";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_allow666);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_allowEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_allowPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_allow670);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_allowEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_allowPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_methods_in_header_allow672);
            methods11=methods(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_allowEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_allowPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_allow_set_method(	(SCOPE_TOP(header_allow))->current,(const char*)((STRSTREAM->toStringTT(STRSTREAM, methods11.start, methods11.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_allowEx; /* Prevent compiler warnings */
    ruleheader_allowEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_allow))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_allowPop(ctx);

    return ret;
}
/* $ANTLR end header_allow */

/** 
 * $ANTLR start methods
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:265:1: methods : ( LWS )? method ( comma method )* ;
 */
static belle_sip_messageParser_methods_return
methods(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_methods_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:265:9: ( ( LWS )? method ( comma method )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:265:11: ( LWS )? method ( comma method )*
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:265:11: ( LWS )?
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt9=1;
                    	}
                        break;
                }

                switch (alt9) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:265:11: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_methods688); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethodsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_method_in_methods691);
            method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemethodsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:265:23: ( comma method )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case COMMA:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:265:24: comma method
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_methods694);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethodsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_method_in_methods696);
            	        method(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethodsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemethodsEx; /* Prevent compiler warnings */
    rulemethodsEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end methods */

/** 
 * $ANTLR start authorization_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:266:1: authorization_token : {...}? token ;
 */
static void
authorization_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:266:20: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:266:22: {...}? token
        {
            if ( !((IS_TOKEN(Authorization))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Authorization)";
                    EXCEPTION->ruleName	 = (void *)"authorization_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_authorization_token706);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauthorization_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauthorization_tokenEx; /* Prevent compiler warnings */
    ruleauthorization_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end authorization_token */

/** 
 * $ANTLR start digest_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:267:1: digest_token : {...}? token ;
 */
static void
digest_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:267:13: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:267:15: {...}? token
        {
            if ( !((IS_TOKEN(Digest))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Digest)";
                    EXCEPTION->ruleName	 = (void *)"digest_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_digest_token714);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledigest_tokenEx; /* Prevent compiler warnings */
    ruledigest_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end digest_token */

/** 
 * $ANTLR start header_authorization
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:270:1: header_authorization returns [belle_sip_header_authorization_t* ret] : authorization_token hcolon credentials[$header_authorization::current] ;
 */
static belle_sip_header_authorization_t*
header_authorization(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_authorization_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_authorizationTop = pbelle_sip_messageParser_header_authorizationPush(ctx);
    	(SCOPE_TOP(header_authorization))->current= belle_sip_header_authorization_new(); ret=	(SCOPE_TOP(header_authorization))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:273:2: ( authorization_token hcolon credentials[$header_authorization::current] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:273:6: authorization_token hcolon credentials[$header_authorization::current]
        {
            FOLLOWPUSH(FOLLOW_authorization_token_in_header_authorization745);
            authorization_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_authorizationPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_authorization749);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_authorizationPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_credentials_in_header_authorization751);
            credentials(ctx, 	(SCOPE_TOP(header_authorization))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_authorizationPop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_authorizationEx; /* Prevent compiler warnings */
    ruleheader_authorizationEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_authorization))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_authorizationPop(ctx);

    return ret;
}
/* $ANTLR end header_authorization */

/** 
 * $ANTLR start credentials
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:281:1: credentials[belle_sip_header_authorization_t* header_authorization_base] : ( ( digest_token LWS digest_response[header_authorization_base] ) | other_response[header_authorization_base] );
 */
static void
credentials(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:282:2: ( ( digest_token LWS digest_response[header_authorization_base] ) | other_response[header_authorization_base] )
            
            ANTLR3_UINT32 alt11;

            alt11=2;

            alt11 = cdfa11.predict(ctx, RECOGNIZER, ISTREAM, &cdfa11);
            if  (HASEXCEPTION())
            {
                goto rulecredentialsEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt11) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:282:6: ( digest_token LWS digest_response[header_authorization_base] )
        	    {
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:282:6: ( digest_token LWS digest_response[header_authorization_base] )
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:282:7: digest_token LWS digest_response[header_authorization_base]
        	        {
        	            FOLLOWPUSH(FOLLOW_digest_token_in_credentials778);
        	            digest_token(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecredentialsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            if ( BACKTRACKING==0 ) 
        	            {
        	                belle_sip_header_authorization_set_scheme(header_authorization_base,"Digest");
        	            }
        	             MATCHT(LWS, &FOLLOW_LWS_in_credentials789); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecredentialsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            FOLLOWPUSH(FOLLOW_digest_response_in_credentials791);
        	            digest_response(ctx, header_authorization_base);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecredentialsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:284:24: other_response[header_authorization_base]
        	    {
        	        FOLLOWPUSH(FOLLOW_other_response_in_credentials818);
        	        other_response(ctx, header_authorization_base);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecredentialsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecredentialsEx; /* Prevent compiler warnings */
    rulecredentialsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end credentials */

/** 
 * $ANTLR start digest_response
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:285:1: digest_response[belle_sip_header_authorization_t* header_authorization_base] : dig_resp[header_authorization_base] ( comma dig_resp[header_authorization_base] )* ;
 */
static void
digest_response(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:286:2: ( dig_resp[header_authorization_base] ( comma dig_resp[header_authorization_base] )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:286:6: dig_resp[header_authorization_base] ( comma dig_resp[header_authorization_base] )*
        {
            FOLLOWPUSH(FOLLOW_dig_resp_in_digest_response834);
            dig_resp(ctx, header_authorization_base);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_responseEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:286:42: ( comma dig_resp[header_authorization_base] )*

            for (;;)
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case COMMA:
                	{
                		alt12=1;
                	}
                    break;

                }

                switch (alt12) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:286:43: comma dig_resp[header_authorization_base]
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_digest_response838);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledigest_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_dig_resp_in_digest_response840);
            	        dig_resp(ctx, header_authorization_base);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledigest_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop12;	/* break out of the loop */
            	    break;
                }
            }
            loop12: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledigest_responseEx; /* Prevent compiler warnings */
    ruledigest_responseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end digest_response */

/** 
 * $ANTLR start dig_resp
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:287:1: dig_resp[belle_sip_header_authorization_t* header_authorization_base] : ( username | realm | nonce | digest_uri[header_authorization_base] | dresponse | algorithm | cnonce | opaque | message_qop | nonce_count | auth_param[header_authorization_base] );
 */
static void
dig_resp(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    char* username12;
    #undef	RETURN_TYPE_username12
    #define	RETURN_TYPE_username12 char*

    char* realm13;
    #undef	RETURN_TYPE_realm13
    #define	RETURN_TYPE_realm13 char*

    char* nonce14;
    #undef	RETURN_TYPE_nonce14
    #define	RETURN_TYPE_nonce14 char*

    char* dresponse15;
    #undef	RETURN_TYPE_dresponse15
    #define	RETURN_TYPE_dresponse15 char*

    const char* algorithm16;
    #undef	RETURN_TYPE_algorithm16
    #define	RETURN_TYPE_algorithm16 const char*

    char* cnonce17;
    #undef	RETURN_TYPE_cnonce17
    #define	RETURN_TYPE_cnonce17 char*

    char* opaque18;
    #undef	RETURN_TYPE_opaque18
    #define	RETURN_TYPE_opaque18 char*

    const char* message_qop19;
    #undef	RETURN_TYPE_message_qop19
    #define	RETURN_TYPE_message_qop19 const char*

    const char* nonce_count20;
    #undef	RETURN_TYPE_nonce_count20
    #define	RETURN_TYPE_nonce_count20 const char*

    /* Initialize rule variables
     */


    username12 = NULL;
    realm13 = NULL;
    nonce14 = NULL;
    dresponse15 = NULL;
    algorithm16 = NULL;
    cnonce17 = NULL;
    opaque18 = NULL;
    message_qop19 = NULL;
    nonce_count20 = NULL;

    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:288:2: ( username | realm | nonce | digest_uri[header_authorization_base] | dresponse | algorithm | cnonce | opaque | message_qop | nonce_count | auth_param[header_authorization_base] )
            
            ANTLR3_UINT32 alt13;

            alt13=11;

            alt13 = cdfa13.predict(ctx, RECOGNIZER, ISTREAM, &cdfa13);
            if  (HASEXCEPTION())
            {
                goto ruledig_respEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt13) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:288:6: username
        	    {
        	        FOLLOWPUSH(FOLLOW_username_in_dig_resp865);
        	        username12=username(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             belle_sip_header_authorization_set_username(header_authorization_base,username12);
        	            	               belle_sip_free(username12);
        	            	             
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:291:4: realm
        	    {
        	        FOLLOWPUSH(FOLLOW_realm_in_dig_resp872);
        	        realm13=realm(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             belle_sip_header_authorization_set_realm(header_authorization_base,(char*)realm13);
        	                             belle_sip_free(realm13);
        	                       
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:294:4: nonce
        	    {
        	        FOLLOWPUSH(FOLLOW_nonce_in_dig_resp880);
        	        nonce14=nonce(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             belle_sip_header_authorization_set_nonce(header_authorization_base,(char*)nonce14);
        	                             belle_sip_free(nonce14);
        	                       
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:297:4: digest_uri[header_authorization_base]
        	    {
        	        FOLLOWPUSH(FOLLOW_digest_uri_in_dig_resp887);
        	        digest_uri(ctx, header_authorization_base);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 5:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:298:5: dresponse
        	    {
        	        FOLLOWPUSH(FOLLOW_dresponse_in_dig_resp894);
        	        dresponse15=dresponse(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             belle_sip_header_authorization_set_response(header_authorization_base,(char*)dresponse15);
        	                             belle_sip_free(dresponse15);
        	                           
        	        }

        	    }
        	    break;
        	case 6:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:301:5: algorithm
        	    {
        	        FOLLOWPUSH(FOLLOW_algorithm_in_dig_resp903);
        	        algorithm16=algorithm(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                            belle_sip_header_authorization_set_algorithm(header_authorization_base,(char*)algorithm16);
        	                           
        	        }

        	    }
        	    break;
        	case 7:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:304:5: cnonce
        	    {
        	        FOLLOWPUSH(FOLLOW_cnonce_in_dig_resp913);
        	        cnonce17=cnonce(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        belle_sip_header_authorization_set_cnonce(header_authorization_base,(char*)cnonce17);
        	                        belle_sip_free(cnonce17);
        	                       
        	        }

        	    }
        	    break;
        	case 8:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:308:5: opaque
        	    {
        	        FOLLOWPUSH(FOLLOW_opaque_in_dig_resp920);
        	        opaque18=opaque(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        belle_sip_header_authorization_set_opaque(header_authorization_base,(char*)opaque18);
        	                        belle_sip_free(opaque18);
        	                       
        	        }

        	    }
        	    break;
        	case 9:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:312:5: message_qop
        	    {
        	        FOLLOWPUSH(FOLLOW_message_qop_in_dig_resp928);
        	        message_qop19=message_qop(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        belle_sip_header_authorization_set_qop(header_authorization_base,message_qop19);
        	                       
        	        }

        	    }
        	    break;
        	case 10:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:315:5: nonce_count
        	    {
        	        FOLLOWPUSH(FOLLOW_nonce_count_in_dig_resp935);
        	        nonce_count20=nonce_count(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        belle_sip_header_authorization_set_nonce_count(header_authorization_base,atoi((char*)nonce_count20));
        	                       
        	        }

        	    }
        	    break;
        	case 11:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:318:5: auth_param[header_authorization_base]
        	    {
        	        FOLLOWPUSH(FOLLOW_auth_param_in_dig_resp943);
        	        auth_param(ctx, header_authorization_base);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledig_respEx; /* Prevent compiler warnings */
    ruledig_respEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end dig_resp */

/** 
 * $ANTLR start username_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:320:1: username_token : {...}? token ;
 */
static void
username_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:320:15: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:320:17: {...}? token
        {
            if ( !((IS_TOKEN(username))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(username)";
                    EXCEPTION->ruleName	 = (void *)"username_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_username_token956);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusername_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleusername_tokenEx; /* Prevent compiler warnings */
    ruleusername_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end username_token */

/** 
 * $ANTLR start username
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:321:1: username returns [char* ret] : username_token equal username_value ;
 */
static char*
username(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_username_value_return username_value21;
    #undef	RETURN_TYPE_username_value21
    #define	RETURN_TYPE_username_value21 belle_sip_messageParser_username_value_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:322:2: ( username_token equal username_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:322:6: username_token equal username_value
        {
            FOLLOWPUSH(FOLLOW_username_token_in_username980);
            username_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusernameEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_username984);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusernameEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_username_value_in_username986);
            username_value21=username_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusernameEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, username_value21.start, username_value21.stop))->chars);
                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleusernameEx; /* Prevent compiler warnings */
    ruleusernameEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end username */

/** 
 * $ANTLR start username_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:326:1: username_value : quoted_string ;
 */
static belle_sip_messageParser_username_value_return
username_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_username_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:326:19: ( quoted_string )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:326:22: quoted_string
        {
            FOLLOWPUSH(FOLLOW_quoted_string_in_username_value1000);
            quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusername_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleusername_valueEx; /* Prevent compiler warnings */
    ruleusername_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end username_value */

/** 
 * $ANTLR start uri_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:328:1: uri_token : {...}? token ;
 */
static void
uri_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:328:10: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:328:12: {...}? token
        {
            if ( !((IS_TOKEN(uri))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(uri)";
                    EXCEPTION->ruleName	 = (void *)"uri_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_uri_token1009);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuri_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuri_tokenEx; /* Prevent compiler warnings */
    ruleuri_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end uri_token */

/** 
 * $ANTLR start digest_uri
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:329:1: digest_uri[belle_sip_header_authorization_t* header_authorization_base] : uri_token equal DQUOTE uri DQUOTE ;
 */
static void
digest_uri(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    belle_sip_uri_t* uri22;
    #undef	RETURN_TYPE_uri22
    #define	RETURN_TYPE_uri22 belle_sip_uri_t*

    /* Initialize rule variables
     */


    uri22 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:330:2: ( uri_token equal DQUOTE uri DQUOTE )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:330:6: uri_token equal DQUOTE uri DQUOTE
        {
            FOLLOWPUSH(FOLLOW_uri_token_in_digest_uri1029);
            uri_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_equal_in_digest_uri1033);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_digest_uri1035); 
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_uri_in_digest_uri1037);
            uri22=uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_digest_uri1039); 
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_authorization_set_uri(header_authorization_base,uri22);
                	 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledigest_uriEx; /* Prevent compiler warnings */
    ruledigest_uriEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end digest_uri */

/** 
 * $ANTLR start message_qop
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:339:1: message_qop returns [const char* ret] : {...}? token equal qop_value ;
 */
static const char*
message_qop(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_qop_value_return qop_value23;
    #undef	RETURN_TYPE_qop_value23
    #define	RETURN_TYPE_qop_value23 belle_sip_messageParser_qop_value_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:340:2: ({...}? token equal qop_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:340:6: {...}? token equal qop_value
        {
            if ( !((IS_TOKEN(qop))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(qop)";
                    EXCEPTION->ruleName	 = (void *)"message_qop";


            }
            FOLLOWPUSH(FOLLOW_token_in_message_qop1070);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemessage_qopEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_message_qop1073);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemessage_qopEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_qop_value_in_message_qop1076);
            qop_value23=qop_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemessage_qopEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= (const char*)(STRSTREAM->toStringTT(STRSTREAM, qop_value23.start, qop_value23.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_qopEx; /* Prevent compiler warnings */
    rulemessage_qopEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end message_qop */

/** 
 * $ANTLR start qop_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:342:1: qop_value : token ;
 */
static belle_sip_messageParser_qop_value_return
qop_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_qop_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:343:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:343:5: token
        {
            FOLLOWPUSH(FOLLOW_token_in_qop_value1088);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleqop_valueEx; /* Prevent compiler warnings */
    ruleqop_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end qop_value */

/** 
 * $ANTLR start cnonce
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:345:1: cnonce returns [char* ret] : {...}? token equal cnonce_value ;
 */
static char*
cnonce(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_cnonce_value_return cnonce_value24;
    #undef	RETURN_TYPE_cnonce_value24
    #define	RETURN_TYPE_cnonce_value24 belle_sip_messageParser_cnonce_value_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:346:2: ({...}? token equal cnonce_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:346:6: {...}? token equal cnonce_value
        {
            if ( !((IS_TOKEN(cnonce))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(cnonce)";
                    EXCEPTION->ruleName	 = (void *)"cnonce";


            }
            FOLLOWPUSH(FOLLOW_token_in_cnonce1117);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_cnonce1121);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_cnonce_value_in_cnonce1123);
            cnonce_value24=cnonce_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                                              ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, cnonce_value24.start, cnonce_value24.stop))->chars);
                                                              
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecnonceEx; /* Prevent compiler warnings */
    rulecnonceEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end cnonce */

/** 
 * $ANTLR start cnonce_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:349:1: cnonce_value : nonce_value ;
 */
static belle_sip_messageParser_cnonce_value_return
cnonce_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_cnonce_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:350:2: ( nonce_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:350:6: nonce_value
        {
            FOLLOWPUSH(FOLLOW_nonce_value_in_cnonce_value1141);
            nonce_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnonce_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecnonce_valueEx; /* Prevent compiler warnings */
    rulecnonce_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end cnonce_value */

/** 
 * $ANTLR start nonce_count
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:351:1: nonce_count returns [const char* ret] : {...}? token equal nc_value ;
 */
static const char*
nonce_count(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_nc_value_return nc_value25;
    #undef	RETURN_TYPE_nc_value25
    #define	RETURN_TYPE_nc_value25 belle_sip_messageParser_nc_value_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:352:2: ({...}? token equal nc_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:352:6: {...}? token equal nc_value
        {
            if ( !((IS_TOKEN(nc))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(nc)";
                    EXCEPTION->ruleName	 = (void *)"nonce_count";


            }
            FOLLOWPUSH(FOLLOW_token_in_nonce_count1164);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonce_countEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_nonce_count1168);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonce_countEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_nc_value_in_nonce_count1170);
            nc_value25=nc_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonce_countEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=(char*)(STRSTREAM->toStringTT(STRSTREAM, nc_value25.start, nc_value25.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenonce_countEx; /* Prevent compiler warnings */
    rulenonce_countEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end nonce_count */

/** 
 * $ANTLR start nc_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:353:1: nc_value : huit_lhex ;
 */
static belle_sip_messageParser_nc_value_return
nc_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_nc_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:354:2: ( huit_lhex )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:354:6: huit_lhex
        {
            FOLLOWPUSH(FOLLOW_huit_lhex_in_nc_value1192);
            huit_lhex(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenc_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenc_valueEx; /* Prevent compiler warnings */
    rulenc_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end nc_value */

/** 
 * $ANTLR start dresponse
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:355:1: dresponse returns [char* ret] : {...}? token equal request_digest ;
 */
static char*
dresponse(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_request_digest_return request_digest26;
    #undef	RETURN_TYPE_request_digest26
    #define	RETURN_TYPE_request_digest26 belle_sip_messageParser_request_digest_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:356:2: ({...}? token equal request_digest )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:356:6: {...}? token equal request_digest
        {
            if ( !((IS_TOKEN(response))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(response)";
                    EXCEPTION->ruleName	 = (void *)"dresponse";


            }
            FOLLOWPUSH(FOLLOW_token_in_dresponse1217);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledresponseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_dresponse1221);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledresponseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_request_digest_in_dresponse1223);
            request_digest26=request_digest(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledresponseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, request_digest26.start, request_digest26.stop))->chars);
                                     
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledresponseEx; /* Prevent compiler warnings */
    ruledresponseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end dresponse */

/** 
 * $ANTLR start request_digest
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:359:1: request_digest : quoted_string ;
 */
static belle_sip_messageParser_request_digest_return
request_digest(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_request_digest_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:360:2: ( quoted_string )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:360:6: quoted_string
        {
            FOLLOWPUSH(FOLLOW_quoted_string_in_request_digest1238);
            quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequest_digestEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerequest_digestEx; /* Prevent compiler warnings */
    rulerequest_digestEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end request_digest */

/** 
 * $ANTLR start huit_lhex
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:362:1: huit_lhex : ( hexdigit )+ ;
 */
static void
huit_lhex(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:363:2: ( ( hexdigit )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:363:4: ( hexdigit )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:363:4: ( hexdigit )+
            {
                int cnt14=0;

                for (;;)
                {
                    int alt14=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt14=1;
            		}
            	    break;

            	}

            	switch (alt14) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:363:4: hexdigit
            	        {
            	            FOLLOWPUSH(FOLLOW_hexdigit_in_huit_lhex1248);
            	            hexdigit(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehuit_lhexEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt14 >= 1 )
            		{
            		    goto loop14;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehuit_lhexEx;
            	}
            	cnt14++;
                }
                loop14: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehuit_lhexEx; /* Prevent compiler warnings */
    rulehuit_lhexEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end huit_lhex */

/** 
 * $ANTLR start auth_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:365:1: auth_param[belle_sip_header_authorization_t* header_authorization_base] : auth_param_name equal auth_param_value ;
 */
static void
auth_param(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    belle_sip_messageParser_auth_param_name_return auth_param_name27;
    #undef	RETURN_TYPE_auth_param_name27
    #define	RETURN_TYPE_auth_param_name27 belle_sip_messageParser_auth_param_name_return

    belle_sip_messageParser_auth_param_value_return auth_param_value28;
    #undef	RETURN_TYPE_auth_param_value28
    #define	RETURN_TYPE_auth_param_value28 belle_sip_messageParser_auth_param_value_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:366:2: ( auth_param_name equal auth_param_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:366:6: auth_param_name equal auth_param_value
        {
            FOLLOWPUSH(FOLLOW_auth_param_name_in_auth_param1270);
            auth_param_name27=auth_param_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_equal_in_auth_param1272);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_auth_param_value_in_auth_param1295);
            auth_param_value28=auth_param_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_parameters_set_parameter(BELLE_SIP_PARAMETERS(header_authorization_base)
                                                                                         ,(char*)(STRSTREAM->toStringTT(STRSTREAM, auth_param_name27.start, auth_param_name27.stop))->chars
                                                                                         ,(char*)(STRSTREAM->toStringTT(STRSTREAM, auth_param_value28.start, auth_param_value28.stop))->chars);
                                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauth_paramEx; /* Prevent compiler warnings */
    ruleauth_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end auth_param */

/** 
 * $ANTLR start auth_param_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:372:1: auth_param_value : ( token | quoted_string );
 */
static belle_sip_messageParser_auth_param_value_return
auth_param_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_auth_param_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:372:18: ( token | quoted_string )
            
            ANTLR3_UINT32 alt15;

            alt15=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case STAR:
            case PLUS:
            case HEX_CHAR:
            case COMMON_CHAR:
            case LPAREN:
            case RPAREN:
            case 28:
            case 29:
            case 34:
            case 35:
            case 39:
            case 40:
            case 41:
            case 42:
            	{
            		alt15=1;
            	}
                break;
            case DQUOTE:
            	{
            		alt15=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruleauth_param_valueEx;
            }

            switch (alt15) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:372:20: token
        	    {
        	        FOLLOWPUSH(FOLLOW_token_in_auth_param_value1315);
        	        token(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleauth_param_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:372:28: quoted_string
        	    {
        	        FOLLOWPUSH(FOLLOW_quoted_string_in_auth_param_value1319);
        	        quoted_string(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleauth_param_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleauth_param_valueEx; /* Prevent compiler warnings */
    ruleauth_param_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end auth_param_value */

/** 
 * $ANTLR start auth_param_name
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:373:1: auth_param_name : token ;
 */
static belle_sip_messageParser_auth_param_name_return
auth_param_name(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_auth_param_name_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:374:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:374:6: token
        {
            FOLLOWPUSH(FOLLOW_token_in_auth_param_name1343);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_param_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauth_param_nameEx; /* Prevent compiler warnings */
    ruleauth_param_nameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end auth_param_name */

/** 
 * $ANTLR start other_response
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:375:1: other_response[belle_sip_header_authorization_t* header_authorization_base] : auth_scheme LWS auth_param[header_authorization_base] ( comma auth_param[header_authorization_base] )* ;
 */
static void
other_response(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    belle_sip_messageParser_auth_scheme_return auth_scheme29;
    #undef	RETURN_TYPE_auth_scheme29
    #define	RETURN_TYPE_auth_scheme29 belle_sip_messageParser_auth_scheme_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:376:2: ( auth_scheme LWS auth_param[header_authorization_base] ( comma auth_param[header_authorization_base] )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:376:6: auth_scheme LWS auth_param[header_authorization_base] ( comma auth_param[header_authorization_base] )*
        {
            FOLLOWPUSH(FOLLOW_auth_scheme_in_other_response1359);
            auth_scheme29=auth_scheme(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_responseEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_authorization_set_scheme(header_authorization_base,(const char*)(STRSTREAM->toStringTT(STRSTREAM, auth_scheme29.start, auth_scheme29.stop))->chars);
            }
             MATCHT(LWS, &FOLLOW_LWS_in_other_response1368); 
            if  (HASEXCEPTION())
            {
                goto ruleother_responseEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_auth_param_in_other_response1370);
            auth_param(ctx, header_authorization_base);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_responseEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:378:22: ( comma auth_param[header_authorization_base] )*

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case COMMA:
                	{
                		alt16=1;
                	}
                    break;

                }

                switch (alt16) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:378:23: comma auth_param[header_authorization_base]
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_other_response1395);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleother_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_auth_param_in_other_response1397);
            	        auth_param(ctx, header_authorization_base);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleother_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleother_responseEx; /* Prevent compiler warnings */
    ruleother_responseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end other_response */

/** 
 * $ANTLR start auth_scheme
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:380:1: auth_scheme : token ;
 */
static belle_sip_messageParser_auth_scheme_return
auth_scheme(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_auth_scheme_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:381:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:381:6: token
        {
            FOLLOWPUSH(FOLLOW_token_in_auth_scheme1418);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_schemeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauth_schemeEx; /* Prevent compiler warnings */
    ruleauth_schemeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end auth_scheme */

/** 
 * $ANTLR start nonce_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:392:1: nonce_value : quoted_string ;
 */
static belle_sip_messageParser_nonce_value_return
nonce_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_nonce_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:392:21: ( quoted_string )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:392:24: quoted_string
        {
            FOLLOWPUSH(FOLLOW_quoted_string_in_nonce_value1436);
            quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonce_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenonce_valueEx; /* Prevent compiler warnings */
    rulenonce_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end nonce_value */

/** 
 * $ANTLR start call_id_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:400:1: call_id_token : {...}? token ;
 */
static void
call_id_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:400:14: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:400:16: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Call-ID,i))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Call-ID,i)";
                    EXCEPTION->ruleName	 = (void *)"call_id_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_call_id_token1448);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecall_id_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecall_id_tokenEx; /* Prevent compiler warnings */
    rulecall_id_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end call_id_token */

/** 
 * $ANTLR start header_call_id
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:402:1: header_call_id returns [belle_sip_header_call_id_t* ret] : call_id_token hcolon call_id ;
 */
static belle_sip_header_call_id_t*
header_call_id(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_call_id_t* ret = NULL;

    belle_sip_messageParser_call_id_return call_id30;
    #undef	RETURN_TYPE_call_id30
    #define	RETURN_TYPE_call_id30 belle_sip_messageParser_call_id_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_call_idTop = pbelle_sip_messageParser_header_call_idPush(ctx);
    	(SCOPE_TOP(header_call_id))->current= belle_sip_header_call_id_new(); ret=	(SCOPE_TOP(header_call_id))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:405:3: ( call_id_token hcolon call_id )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:405:6: call_id_token hcolon call_id
        {
            FOLLOWPUSH(FOLLOW_call_id_token_in_header_call_id1478);
            call_id_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_call_idEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_call_idPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_call_id1482);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_call_idEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_call_idPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_call_id_in_header_call_id1484);
            call_id30=call_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_call_idEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_call_idPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_call_id_set_call_id(	(SCOPE_TOP(header_call_id))->current,(const char*) (STRSTREAM->toStringTT(STRSTREAM, call_id30.start, call_id30.stop))->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_call_idEx; /* Prevent compiler warnings */
    ruleheader_call_idEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_call_id))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_call_idPop(ctx);

    return ret;
}
/* $ANTLR end header_call_id */

/** 
 * $ANTLR start call_id
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:412:1: call_id : word ( '@' word )? ;
 */
static belle_sip_messageParser_call_id_return
call_id(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_call_id_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:413:2: ( word ( '@' word )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:413:6: word ( '@' word )?
        {
            FOLLOWPUSH(FOLLOW_word_in_call_id1506);
            word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecall_idEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:413:11: ( '@' word )?
            {
                int alt17=2;
                switch ( LA(1) ) 
                {
                    case 24:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:413:13: '@' word
            	    {
            	         MATCHT(24, &FOLLOW_24_in_call_id1510); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecall_idEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_word_in_call_id1512);
            	        word(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecall_idEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecall_idEx; /* Prevent compiler warnings */
    rulecall_idEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end call_id */

/** 
 * $ANTLR start contact_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:424:1: contact_token : {...}? token ;
 */
static void
contact_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:424:14: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:424:16: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Contact,m))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Contact,m)";
                    EXCEPTION->ruleName	 = (void *)"contact_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_contact_token1528);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontact_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontact_tokenEx; /* Prevent compiler warnings */
    rulecontact_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end contact_token */

/** 
 * $ANTLR start header_contact
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:426:1: header_contact returns [belle_sip_header_contact_t* ret] : ( contact_token ) hcolon ( STAR | ( contact_param ( comma contact_param )* ) ) ;
 */
static belle_sip_header_contact_t*
header_contact(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_contact_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_contactTop = pbelle_sip_messageParser_header_contactPush(ctx);
     	(SCOPE_TOP(header_contact))->current=NULL; ret=NULL; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:429:2: ( ( contact_token ) hcolon ( STAR | ( contact_param ( comma contact_param )* ) ) )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:429:6: ( contact_token ) hcolon ( STAR | ( contact_param ( comma contact_param )* ) )
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:429:6: ( contact_token )
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:429:7: contact_token
            {
                FOLLOWPUSH(FOLLOW_contact_token_in_header_contact1561);
                contact_token(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleheader_contactEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_header_contactPop(ctx);

                    return ret;
                }

            }

            FOLLOWPUSH(FOLLOW_hcolon_in_header_contact1569);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_contactEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_contactPop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:430:19: ( STAR | ( contact_param ( comma contact_param )* ) )
            {
                int alt19=2;
                switch ( LA(1) ) 
                {
                case STAR:
                	{
                		switch ( LA(2) ) 
                		{
                		case EOF:
                			{
                				alt19=1;
                			}
                		    break;
                		case LWS:
                		case DIGIT:
                		case STAR:
                		case COLON:
                		case PLUS:
                		case HEX_CHAR:
                		case COMMON_CHAR:
                		case LAQUOT:
                		case LPAREN:
                		case RPAREN:
                		case 28:
                		case 29:
                		case 34:
                		case 35:
                		case 39:
                		case 40:
                		case 41:
                		case 42:
                			{
                				alt19=2;
                			}
                		    break;

                		default:
                		    if (BACKTRACKING>0)
                		    {
                		        FAILEDFLAG = ANTLR3_TRUE;
                		        pbelle_sip_messageParser_header_contactPop(ctx);

                		        return ret;
                		    }
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 19;
                		    EXCEPTION->state        = 1;


                		    goto ruleheader_contactEx;
                		}

                	}
                    break;
                case LWS:
                case DIGIT:
                case DQUOTE:
                case PLUS:
                case HEX_CHAR:
                case COMMON_CHAR:
                case LAQUOT:
                case LPAREN:
                case RPAREN:
                case 28:
                case 29:
                case 34:
                case 35:
                case 39:
                case 40:
                case 41:
                case 42:
                	{
                		alt19=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        pbelle_sip_messageParser_header_contactPop(ctx);

                        return ret;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 19;
                    EXCEPTION->state        = 0;


                    goto ruleheader_contactEx;
                }

                switch (alt19) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:430:21: STAR
            	    {
            	         MATCHT(STAR, &FOLLOW_STAR_in_header_contact1591); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_contactEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_contactPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	             	(SCOPE_TOP(header_contact))->current= belle_sip_header_contact_new();
            	                                        belle_sip_header_contact_set_wildcard(	(SCOPE_TOP(header_contact))->current,1);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:432:21: ( contact_param ( comma contact_param )* )
            	    {
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:432:21: ( contact_param ( comma contact_param )* )
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:432:22: contact_param ( comma contact_param )*
            	        {
            	            FOLLOWPUSH(FOLLOW_contact_param_in_header_contact1617);
            	            contact_param(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleheader_contactEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_header_contactPop(ctx);

            	                return ret;
            	            }

            	            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:432:36: ( comma contact_param )*

            	            for (;;)
            	            {
            	                int alt18=2;
            	                switch ( LA(1) ) 
            	                {
            	                case LWS:
            	                case COMMA:
            	                	{
            	                		alt18=1;
            	                	}
            	                    break;

            	                }

            	                switch (alt18) 
            	                {
            	            	case 1:
            	            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:432:37: comma contact_param
            	            	    {
            	            	        FOLLOWPUSH(FOLLOW_comma_in_header_contact1620);
            	            	        comma(ctx);

            	            	        FOLLOWPOP();
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleheader_contactEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            pbelle_sip_messageParser_header_contactPop(ctx);

            	            	            return ret;
            	            	        }
            	            	        FOLLOWPUSH(FOLLOW_contact_param_in_header_contact1622);
            	            	        contact_param(ctx);

            	            	        FOLLOWPOP();
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleheader_contactEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            pbelle_sip_messageParser_header_contactPop(ctx);

            	            	            return ret;
            	            	        }

            	            	    }
            	            	    break;

            	            	default:
            	            	    goto loop18;	/* break out of the loop */
            	            	    break;
            	                }
            	            }
            	            loop18: ; /* Jump out to here if this rule does not match */


            	        }


            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_contact))->first; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_contactEx; /* Prevent compiler warnings */
    ruleheader_contactEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if (	(SCOPE_TOP(header_contact))->current) belle_sip_object_unref(	(SCOPE_TOP(header_contact))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_contactPop(ctx);

    return ret;
}
/* $ANTLR end header_contact */

/** 
 * $ANTLR start contact_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:440:1: contact_param : ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] ) ( semi contact_params )* ;
 */
static void
contact_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_contact_paramTop = pbelle_sip_messageParser_contact_paramPush(ctx);
     if (	(SCOPE_TOP(header_contact))->current == NULL) {
                	(SCOPE_TOP(header_contact))->current= belle_sip_header_contact_new();
                 	(SCOPE_TOP(header_contact))->first= 	(SCOPE_TOP(header_contact))->current;
                 	(SCOPE_TOP(contact_param))->prev=NULL; 
             } else {
                	(SCOPE_TOP(contact_param))->prev=	(SCOPE_TOP(header_contact))->current;
                belle_sip_header_set_next(BELLE_SIP_HEADER(	(SCOPE_TOP(header_contact))->current),(belle_sip_header_t*)belle_sip_header_contact_new());
                	(SCOPE_TOP(header_contact))->current= (belle_sip_header_contact_t*)belle_sip_header_get_next(BELLE_SIP_HEADER(	(SCOPE_TOP(header_contact))->current));
             } 
          
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:452:2: ( ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] ) ( semi contact_params )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:452:6: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] ) ( semi contact_params )*
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:452:6: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] )
            {
                int alt20=2;
                alt20 = cdfa20.predict(ctx, RECOGNIZER, ISTREAM, &cdfa20);
                if  (HASEXCEPTION())
                {
                    goto rulecontact_paramEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_contact_paramPop(ctx);

                    return ;
                }
                switch (alt20) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:452:7: name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_name_addr_in_contact_param1675);
            	        name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_contact))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontact_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:453:7: paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_paramless_addr_spec_in_contact_param1685);
            	        paramless_addr_spec(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_contact))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontact_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:453:80: ( semi contact_params )*

            for (;;)
            {
                int alt21=2;
                switch ( LA(1) ) 
                {
                case LWS:
                	{
                		switch ( LA(2) ) 
                		{
                		case SEMI:
                			{
                				alt21=1;
                			}
                		    break;

                		}

                	}
                    break;
                case SEMI:
                	{
                		alt21=1;
                	}
                    break;

                }

                switch (alt21) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:453:81: semi contact_params
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_contact_param1690);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontact_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_contact_params_in_contact_param1692);
            	        contact_params(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontact_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontact_paramEx; /* Prevent compiler warnings */
    rulecontact_paramEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if ( 	(SCOPE_TOP(contact_param))->prev == NULL) {
	          	(SCOPE_TOP(header_contact))->first=NULL;
	       } else {
	         belle_sip_header_set_next(BELLE_SIP_HEADER(	(SCOPE_TOP(contact_param))->prev),NULL); 
	       }
	       belle_sip_object_unref(	(SCOPE_TOP(header_contact))->current);
	       	(SCOPE_TOP(header_contact))->current=	(SCOPE_TOP(contact_param))->prev;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_contact_paramPop(ctx);

    return ;
}
/* $ANTLR end contact_param */

/** 
 * $ANTLR start header_address
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:467:1: header_address returns [belle_sip_header_address_t* ret] : header_address_base[belle_sip_header_address_new()] ;
 */
static belle_sip_header_address_t*
header_address(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_address_t* ret = NULL;

    belle_sip_header_address_t* header_address_base31;
    #undef	RETURN_TYPE_header_address_base31
    #define	RETURN_TYPE_header_address_base31 belle_sip_header_address_t*

    /* Initialize rule variables
     */


     ret=NULL; 
    header_address_base31 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:469:3: ( header_address_base[belle_sip_header_address_new()] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:469:5: header_address_base[belle_sip_header_address_new()]
        {
            FOLLOWPUSH(FOLLOW_header_address_base_in_header_address1723);
            header_address_base31=header_address_base(ctx, belle_sip_header_address_new());

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_addressEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=header_address_base31;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_addressEx; /* Prevent compiler warnings */
    ruleheader_addressEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end header_address */

/** 
 * $ANTLR start header_address_base
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:471:1: header_address_base[belle_sip_header_address_t* obj] returns [belle_sip_header_address_t* ret] : ( name_addr[BELLE_SIP_HEADER_ADDRESS($ret)] | addr_spec[BELLE_SIP_HEADER_ADDRESS($ret)] );
 */
static belle_sip_header_address_t*
header_address_base(pbelle_sip_messageParser ctx, belle_sip_header_address_t* obj)
{   
    belle_sip_header_address_t* ret = NULL;

    /* Initialize rule variables
     */


     ret=obj; 
    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:473:5: ( name_addr[BELLE_SIP_HEADER_ADDRESS($ret)] | addr_spec[BELLE_SIP_HEADER_ADDRESS($ret)] )
            
            ANTLR3_UINT32 alt22;

            alt22=2;

            alt22 = cdfa22.predict(ctx, RECOGNIZER, ISTREAM, &cdfa22);
            if  (HASEXCEPTION())
            {
                goto ruleheader_address_baseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            switch (alt22) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:473:7: name_addr[BELLE_SIP_HEADER_ADDRESS($ret)]
        	    {
        	        FOLLOWPUSH(FOLLOW_name_addr_in_header_address_base1757);
        	        name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(ret));

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleheader_address_baseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ret;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:474:7: addr_spec[BELLE_SIP_HEADER_ADDRESS($ret)]
        	    {
        	        FOLLOWPUSH(FOLLOW_addr_spec_in_header_address_base1767);
        	        addr_spec(ctx, BELLE_SIP_HEADER_ADDRESS(ret));

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleheader_address_baseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ret;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_address_baseEx; /* Prevent compiler warnings */
    ruleheader_address_baseEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	      belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	      belle_sip_object_unref(ret);
	      ret=NULL;

	}


    }
    else
    {
    }

    return ret;
}
/* $ANTLR end header_address_base */

/** 
 * $ANTLR start name_addr
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:481:1: name_addr[belle_sip_header_address_t* object] : ( display_name[object] )? sp_laquot_sp addr_spec[object] sp_raquot_sp ;
 */
static void
name_addr(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:482:2: ( ( display_name[object] )? sp_laquot_sp addr_spec[object] sp_raquot_sp )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:482:6: ( display_name[object] )? sp_laquot_sp addr_spec[object] sp_raquot_sp
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:482:6: ( display_name[object] )?
            {
                int alt23=2;
                switch ( LA(1) ) 
                {
                    case DIGIT:
                    case DQUOTE:
                    case STAR:
                    case PLUS:
                    case HEX_CHAR:
                    case COMMON_CHAR:
                    case LPAREN:
                    case RPAREN:
                    case 28:
                    case 29:
                    case 34:
                    case 35:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:482:8: display_name[object]
            	    {
            	        FOLLOWPUSH(FOLLOW_display_name_in_name_addr1798);
            	        display_name(ctx, object);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulename_addrEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_sp_laquot_sp_in_name_addr1804);
            sp_laquot_sp(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addrEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_addr_spec_in_name_addr1806);
            addr_spec(ctx, object);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addrEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_sp_raquot_sp_in_name_addr1809);
            sp_raquot_sp(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addrEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulename_addrEx; /* Prevent compiler warnings */
    rulename_addrEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end name_addr */

/** 
 * $ANTLR start addr_spec
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:483:1: addr_spec[belle_sip_header_address_t* object] : uri ;
 */
static void
addr_spec(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    belle_sip_uri_t* uri32;
    #undef	RETURN_TYPE_uri32
    #define	RETURN_TYPE_uri32 belle_sip_uri_t*

    /* Initialize rule variables
     */


    uri32 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:484:3: ( uri )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:484:6: uri
        {
            FOLLOWPUSH(FOLLOW_uri_in_addr_spec1826);
            uri32=uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaddr_specEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_address_set_uri(object,uri32);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleaddr_specEx; /* Prevent compiler warnings */
    ruleaddr_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end addr_spec */

/** 
 * $ANTLR start paramless_addr_spec
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:486:1: paramless_addr_spec[belle_sip_header_address_t* object] : paramless_uri ;
 */
static void
paramless_addr_spec(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    belle_sip_uri_t* paramless_uri33;
    #undef	RETURN_TYPE_paramless_uri33
    #define	RETURN_TYPE_paramless_uri33 belle_sip_uri_t*

    /* Initialize rule variables
     */


    paramless_uri33 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:487:3: ( paramless_uri )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:487:6: paramless_uri
        {
            FOLLOWPUSH(FOLLOW_paramless_uri_in_paramless_addr_spec1846);
            paramless_uri33=paramless_uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparamless_addr_specEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_address_set_uri(object,paramless_uri33);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamless_addr_specEx; /* Prevent compiler warnings */
    ruleparamless_addr_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end paramless_addr_spec */

/** 
 * $ANTLR start display_name
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:489:1: display_name[belle_sip_header_address_t* object] : ( token | quoted_string );
 */
static void
display_name(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    belle_sip_messageParser_token_return token34;
    #undef	RETURN_TYPE_token34
    #define	RETURN_TYPE_token34 belle_sip_messageParser_token_return

    belle_sip_messageParser_quoted_string_return quoted_string35;
    #undef	RETURN_TYPE_quoted_string35
    #define	RETURN_TYPE_quoted_string35 belle_sip_messageParser_quoted_string_return

    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:490:3: ( token | quoted_string )
            
            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case STAR:
            case PLUS:
            case HEX_CHAR:
            case COMMON_CHAR:
            case LPAREN:
            case RPAREN:
            case 28:
            case 29:
            case 34:
            case 35:
            case 39:
            case 40:
            case 41:
            case 42:
            	{
            		alt24=1;
            	}
                break;
            case DQUOTE:
            	{
            		alt24=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruledisplay_nameEx;
            }

            switch (alt24) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:490:6: token
        	    {
        	        FOLLOWPUSH(FOLLOW_token_in_display_name1864);
        	        token34=token(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledisplay_nameEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_address_set_displayname(object,(const char*)((STRSTREAM->toStringTT(STRSTREAM, token34.start, token34.stop))->chars));
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:491:8: quoted_string
        	    {
        	        FOLLOWPUSH(FOLLOW_quoted_string_in_display_name1875);
        	        quoted_string35=quoted_string(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledisplay_nameEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_address_set_quoted_displayname(object,(const char*)((STRSTREAM->toStringTT(STRSTREAM, quoted_string35.start, quoted_string35.stop))->chars));
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledisplay_nameEx; /* Prevent compiler warnings */
    ruledisplay_nameEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end display_name */

/** 
 * $ANTLR start contact_params
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:494:1: contact_params : contact_extension ;
 */
static void
contact_params(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:495:2: ( contact_extension )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:496:27: contact_extension
        {
            FOLLOWPUSH(FOLLOW_contact_extension_in_contact_params1901);
            contact_extension(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontact_paramsEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontact_paramsEx; /* Prevent compiler warnings */
    rulecontact_paramsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end contact_params */

/** 
 * $ANTLR start contact_extension
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:501:1: contact_extension : generic_param[BELLE_SIP_PARAMETERS($header_contact::current)] ;
 */
static void
contact_extension(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:502:2: ( generic_param[BELLE_SIP_PARAMETERS($header_contact::current)] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:502:6: generic_param[BELLE_SIP_PARAMETERS($header_contact::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_contact_extension1915);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_contact))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontact_extensionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontact_extensionEx; /* Prevent compiler warnings */
    rulecontact_extensionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end contact_extension */

/** 
 * $ANTLR start delta_seconds
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:504:1: delta_seconds : ( DIGIT )+ ;
 */
static belle_sip_messageParser_delta_seconds_return
delta_seconds(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_delta_seconds_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:505:2: ( ( DIGIT )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:505:6: ( DIGIT )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:505:6: ( DIGIT )+
            {
                int cnt25=0;

                for (;;)
                {
                    int alt25=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt25=1;
            		}
            	    break;

            	}

            	switch (alt25) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:505:6: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_delta_seconds1934); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledelta_secondsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt25 >= 1 )
            		{
            		    goto loop25;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledelta_secondsEx;
            	}
            	cnt25++;
                }
                loop25: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledelta_secondsEx; /* Prevent compiler warnings */
    ruledelta_secondsEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end delta_seconds */

/** 
 * $ANTLR start content_length_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:544:1: content_length_token : {...}? token ;
 */
static void
content_length_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:544:22: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:544:25: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Content-Length,l))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Content-Length,l)";
                    EXCEPTION->ruleName	 = (void *)"content_length_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_content_length_token1949);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontent_length_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontent_length_tokenEx; /* Prevent compiler warnings */
    rulecontent_length_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end content_length_token */

/** 
 * $ANTLR start header_content_length
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:545:1: header_content_length returns [belle_sip_header_content_length_t* ret] : content_length_token hcolon content_length ;
 */
static belle_sip_header_content_length_t*
header_content_length(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_content_length_t* ret = NULL;

    belle_sip_messageParser_content_length_return content_length36;
    #undef	RETURN_TYPE_content_length36
    #define	RETURN_TYPE_content_length36 belle_sip_messageParser_content_length_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_content_lengthTop = pbelle_sip_messageParser_header_content_lengthPush(ctx);
    	(SCOPE_TOP(header_content_length))->current= belle_sip_header_content_length_new(); ret=	(SCOPE_TOP(header_content_length))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:548:2: ( content_length_token hcolon content_length )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:548:5: content_length_token hcolon content_length
        {
            FOLLOWPUSH(FOLLOW_content_length_token_in_header_content_length1977);
            content_length_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_lengthEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_lengthPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_content_length1986);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_lengthEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_lengthPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_content_length_in_header_content_length1993);
            content_length36=content_length(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_lengthEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_lengthPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_content_length_set_content_length(	(SCOPE_TOP(header_content_length))->current,atoi((const char*)(STRSTREAM->toStringTT(STRSTREAM, content_length36.start, content_length36.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_content_lengthEx; /* Prevent compiler warnings */
    ruleheader_content_lengthEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_content_length))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_content_lengthPop(ctx);

    return ret;
}
/* $ANTLR end header_content_length */

/** 
 * $ANTLR start content_length
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:557:1: content_length : ( DIGIT )+ ;
 */
static belle_sip_messageParser_content_length_return
content_length(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_content_length_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:557:15: ( ( DIGIT )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:557:16: ( DIGIT )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:557:16: ( DIGIT )+
            {
                int cnt26=0;

                for (;;)
                {
                    int alt26=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt26=1;
            		}
            	    break;

            	}

            	switch (alt26) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:557:16: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_content_length2006); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecontent_lengthEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt26 >= 1 )
            		{
            		    goto loop26;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulecontent_lengthEx;
            	}
            	cnt26++;
                }
                loop26: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontent_lengthEx; /* Prevent compiler warnings */
    rulecontent_lengthEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end content_length */

/** 
 * $ANTLR start content_type_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:559:1: content_type_token : {...}? token ;
 */
static void
content_type_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:559:20: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:559:23: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Content-Type,c))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Content-Type,c)";
                    EXCEPTION->ruleName	 = (void *)"content_type_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_content_type_token2019);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontent_type_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontent_type_tokenEx; /* Prevent compiler warnings */
    rulecontent_type_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end content_type_token */

/** 
 * $ANTLR start header_content_type
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:560:1: header_content_type returns [belle_sip_header_content_type_t* ret] : content_type_token hcolon media_type ;
 */
static belle_sip_header_content_type_t*
header_content_type(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_content_type_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_content_typeTop = pbelle_sip_messageParser_header_content_typePush(ctx);
     	(SCOPE_TOP(header_content_type))->current= belle_sip_header_content_type_new();ret=	(SCOPE_TOP(header_content_type))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:563:2: ( content_type_token hcolon media_type )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:563:5: content_type_token hcolon media_type
        {
            FOLLOWPUSH(FOLLOW_content_type_token_in_header_content_type2045);
            content_type_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_typeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_typePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_content_type2048);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_typeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_typePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_media_type_in_header_content_type2050);
            media_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_typeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_typePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_content_typeEx; /* Prevent compiler warnings */
    ruleheader_content_typeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	      belle_sip_object_unref(	(SCOPE_TOP(header_content_type))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_content_typePop(ctx);

    return ret;
}
/* $ANTLR end header_content_type */

/** 
 * $ANTLR start media_type
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:570:1: media_type : m_type slash m_subtype ( semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)] )* ;
 */
static void
media_type(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_m_type_return m_type37;
    #undef	RETURN_TYPE_m_type37
    #define	RETURN_TYPE_m_type37 belle_sip_messageParser_m_type_return

    belle_sip_messageParser_m_subtype_return m_subtype38;
    #undef	RETURN_TYPE_m_subtype38
    #define	RETURN_TYPE_m_subtype38 belle_sip_messageParser_m_subtype_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:571:2: ( m_type slash m_subtype ( semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)] )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:571:5: m_type slash m_subtype ( semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)] )*
        {
            FOLLOWPUSH(FOLLOW_m_type_in_media_type2074);
            m_type37=m_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemedia_typeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_content_type_set_type(	(SCOPE_TOP(header_content_type))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, m_type37.start, m_type37.stop))->chars);
            }
            FOLLOWPUSH(FOLLOW_slash_in_media_type2083);
            slash(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemedia_typeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_m_subtype_in_media_type2090);
            m_subtype38=m_subtype(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemedia_typeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_content_type_set_subtype(	(SCOPE_TOP(header_content_type))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, m_subtype38.start, m_subtype38.stop))->chars);
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:574:5: ( semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)] )*

            for (;;)
            {
                int alt27=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case SEMI:
                	{
                		alt27=1;
                	}
                    break;

                }

                switch (alt27) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:574:6: semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_media_type2100);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_typeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_generic_param_in_media_type2103);
            	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_content_type))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_typeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop27;	/* break out of the loop */
            	    break;
                }
            }
            loop27: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemedia_typeEx; /* Prevent compiler warnings */
    rulemedia_typeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end media_type */

/** 
 * $ANTLR start m_type
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:575:1: m_type : token ;
 */
static belle_sip_messageParser_m_type_return
m_type(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_m_type_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:576:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:576:4: token
        {
            FOLLOWPUSH(FOLLOW_token_in_m_type2126);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulem_typeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulem_typeEx; /* Prevent compiler warnings */
    rulem_typeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end m_type */

/** 
 * $ANTLR start m_subtype
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:588:1: m_subtype : token ;
 */
static belle_sip_messageParser_m_subtype_return
m_subtype(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_m_subtype_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:588:18: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:588:20: token
        {
            FOLLOWPUSH(FOLLOW_token_in_m_subtype2142);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulem_subtypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulem_subtypeEx; /* Prevent compiler warnings */
    rulem_subtypeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end m_subtype */

/** 
 * $ANTLR start cseq_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:599:1: cseq_token : {...}? token ;
 */
static void
cseq_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:599:12: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:599:15: {...}? token
        {
            if ( !((IS_TOKEN(CSeq))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(CSeq)";
                    EXCEPTION->ruleName	 = (void *)"cseq_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_cseq_token2155);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecseq_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecseq_tokenEx; /* Prevent compiler warnings */
    rulecseq_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end cseq_token */

/** 
 * $ANTLR start header_cseq
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:600:1: header_cseq returns [belle_sip_header_cseq_t* ret] : cseq_token hcolon seq_number LWS method ;
 */
static belle_sip_header_cseq_t*
header_cseq(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_cseq_t* ret = NULL;

    belle_sip_messageParser_seq_number_return seq_number39;
    #undef	RETURN_TYPE_seq_number39
    #define	RETURN_TYPE_seq_number39 belle_sip_messageParser_seq_number_return

    belle_sip_messageParser_method_return method40;
    #undef	RETURN_TYPE_method40
    #define	RETURN_TYPE_method40 belle_sip_messageParser_method_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_cseqTop = pbelle_sip_messageParser_header_cseqPush(ctx);
     	(SCOPE_TOP(header_cseq))->current= belle_sip_header_cseq_new();ret= 	(SCOPE_TOP(header_cseq))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:603:3: ( cseq_token hcolon seq_number LWS method )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:603:5: cseq_token hcolon seq_number LWS method
        {
            FOLLOWPUSH(FOLLOW_cseq_token_in_header_cseq2181);
            cseq_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_cseq2187);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_seq_number_in_header_cseq2194);
            seq_number39=seq_number(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_cseq_set_seq_number(	(SCOPE_TOP(header_cseq))->current,atoi((const char*)(STRSTREAM->toStringTT(STRSTREAM, seq_number39.start, seq_number39.stop))->chars));
            }
             MATCHT(LWS, &FOLLOW_LWS_in_header_cseq2203); 
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_method_in_header_cseq2210);
            method40=method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_cseq_set_method(	(SCOPE_TOP(header_cseq))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, method40.start, method40.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_cseqEx; /* Prevent compiler warnings */
    ruleheader_cseqEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_cseq))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_cseqPop(ctx);

    return ret;
}
/* $ANTLR end header_cseq */

/** 
 * $ANTLR start seq_number
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:614:1: seq_number : ( DIGIT )+ ;
 */
static belle_sip_messageParser_seq_number_return
seq_number(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_seq_number_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:614:11: ( ( DIGIT )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:614:12: ( DIGIT )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:614:12: ( DIGIT )+
            {
                int cnt28=0;

                for (;;)
                {
                    int alt28=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt28=1;
            		}
            	    break;

            	}

            	switch (alt28) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:614:12: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_seq_number2229); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleseq_numberEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt28 >= 1 )
            		{
            		    goto loop28;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleseq_numberEx;
            	}
            	cnt28++;
                }
                loop28: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleseq_numberEx; /* Prevent compiler warnings */
    ruleseq_numberEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end seq_number */

/** 
 * $ANTLR start date_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:617:1: date_token : {...}? token ;
 */
static void
date_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:617:11: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:617:13: {...}? token
        {
            if ( !((IS_TOKEN(Date))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Date)";
                    EXCEPTION->ruleName	 = (void *)"date_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_date_token2241);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledate_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledate_tokenEx; /* Prevent compiler warnings */
    ruledate_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end date_token */

/** 
 * $ANTLR start header_date
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:619:1: header_date returns [belle_sip_header_date_t* ret] : date_token hcolon sip_date ;
 */
static belle_sip_header_date_t*
header_date(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_date_t* ret = NULL;

    belle_sip_messageParser_sip_date_return sip_date41;
    #undef	RETURN_TYPE_sip_date41
    #define	RETURN_TYPE_sip_date41 belle_sip_messageParser_sip_date_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_dateTop = pbelle_sip_messageParser_header_datePush(ctx);
    	(SCOPE_TOP(header_date))->current= belle_sip_header_date_new(); ret=	(SCOPE_TOP(header_date))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:622:3: ( date_token hcolon sip_date )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:622:6: date_token hcolon sip_date
        {
            FOLLOWPUSH(FOLLOW_date_token_in_header_date2271);
            date_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_dateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_datePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_date2275);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_dateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_datePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_sip_date_in_header_date2277);
            sip_date41=sip_date(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_dateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_datePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_date_set_date(	(SCOPE_TOP(header_date))->current,(const char*) (STRSTREAM->toStringTT(STRSTREAM, sip_date41.start, sip_date41.stop))->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_dateEx; /* Prevent compiler warnings */
    ruleheader_dateEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_date))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_datePop(ctx);

    return ret;
}
/* $ANTLR end header_date */

/** 
 * $ANTLR start date
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:630:1: date : sip_date ;
 */
static void
date(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:631:2: ( sip_date )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:631:4: sip_date
        {
            FOLLOWPUSH(FOLLOW_sip_date_in_date2293);
            sip_date(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledateEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledateEx; /* Prevent compiler warnings */
    ruledateEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end date */

/** 
 * $ANTLR start sip_date
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:633:1: sip_date : (~ ( CRLF ) )* ;
 */
static belle_sip_messageParser_sip_date_return
sip_date(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_sip_date_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:634:2: ( (~ ( CRLF ) )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:634:4: (~ ( CRLF ) )*
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:634:4: (~ ( CRLF ) )*

            for (;;)
            {
                int alt29=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case DIGIT:
                case DQUOTE:
                case STAR:
                case SEMI:
                case COMMA:
                case SLASH:
                case EQUAL:
                case COLON:
                case OCTET:
                case PLUS:
                case HEX_CHAR:
                case COMMON_CHAR:
                case LAQUOT:
                case RAQUOT:
                case LPAREN:
                case RPAREN:
                case HTAB:
                case SP:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                	{
                		alt29=1;
                	}
                    break;

                }

                switch (alt29) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:634:4: ~ ( CRLF )
            	    {
            	        if ( ((LA(1) >= LWS) && (LA(1) <= 42)) )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else 
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_sip_date2302;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_sip_date2302);    goto rulesip_dateEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop29;	/* break out of the loop */
            	    break;
                }
            }
            loop29: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesip_dateEx; /* Prevent compiler warnings */
    rulesip_dateEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end sip_date */

/** 
 * $ANTLR start header_expires
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:658:1: header_expires returns [belle_sip_header_expires_t* ret] : {...}? token hcolon delta_seconds ;
 */
static belle_sip_header_expires_t*
header_expires(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_expires_t* ret = NULL;

    belle_sip_messageParser_delta_seconds_return delta_seconds42;
    #undef	RETURN_TYPE_delta_seconds42
    #define	RETURN_TYPE_delta_seconds42 belle_sip_messageParser_delta_seconds_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_expiresTop = pbelle_sip_messageParser_header_expiresPush(ctx);
     	(SCOPE_TOP(header_expires))->current= belle_sip_header_expires_new();ret= 	(SCOPE_TOP(header_expires))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:661:2: ({...}? token hcolon delta_seconds )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:661:6: {...}? token hcolon delta_seconds
        {
            if ( !((IS_TOKEN(Expires))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_expiresPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Expires)";
                    EXCEPTION->ruleName	 = (void *)"header_expires";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_expires2346);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_expiresEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_expiresPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_expires2350);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_expiresEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_expiresPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_delta_seconds_in_header_expires2352);
            delta_seconds42=delta_seconds(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_expiresEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_expiresPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_expires_set_expires(	(SCOPE_TOP(header_expires))->current,atoi((const char *)(STRSTREAM->toStringTT(STRSTREAM, delta_seconds42.start, delta_seconds42.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_expiresEx; /* Prevent compiler warnings */
    ruleheader_expiresEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_expires))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_expiresPop(ctx);

    return ret;
}
/* $ANTLR end header_expires */

/** 
 * $ANTLR start from_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:669:1: from_token : {...}? token ;
 */
static void
from_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:669:11: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:669:14: {...}? token
        {
            if ( !((IS_HEADER_NAMED(From,f))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(From,f)";
                    EXCEPTION->ruleName	 = (void *)"from_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_from_token2373);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefrom_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefrom_tokenEx; /* Prevent compiler warnings */
    rulefrom_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end from_token */

/** 
 * $ANTLR start header_from
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:670:1: header_from returns [belle_sip_header_from_t* ret] : from_token hcolon from_spec ;
 */
static belle_sip_header_from_t*
header_from(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_from_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_fromTop = pbelle_sip_messageParser_header_fromPush(ctx);
     	(SCOPE_TOP(header_from))->current= belle_sip_header_from_new();ret= 	(SCOPE_TOP(header_from))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:674:2: ( from_token hcolon from_spec )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:674:6: from_token hcolon from_spec
        {
            FOLLOWPUSH(FOLLOW_from_token_in_header_from2409);
            from_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_fromEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_fromPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_from2412);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_fromEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_fromPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_from_spec_in_header_from2414);
            from_spec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_fromEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_fromPop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_fromEx; /* Prevent compiler warnings */
    ruleheader_fromEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_from))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_fromPop(ctx);

    return ret;
}
/* $ANTLR end header_from */

/** 
 * $ANTLR start from_spec
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:682:1: from_spec : ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_from::current)] ) ( SEMI from_param )* ;
 */
static void
from_spec(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:683:2: ( ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_from::current)] ) ( SEMI from_param )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:683:6: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_from::current)] ) ( SEMI from_param )*
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:683:6: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_from::current)] )
            {
                int alt30=2;
                alt30 = cdfa30.predict(ctx, RECOGNIZER, ISTREAM, &cdfa30);
                if  (HASEXCEPTION())
                {
                    goto rulefrom_specEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                switch (alt30) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:683:8: name_addr[BELLE_SIP_HEADER_ADDRESS($header_from::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_name_addr_in_from_spec2439);
            	        name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_from))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefrom_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:683:69: paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_from::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_paramless_addr_spec_in_from_spec2444);
            	        paramless_addr_spec(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_from))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefrom_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:684:16: ( SEMI from_param )*

            for (;;)
            {
                int alt31=2;
                switch ( LA(1) ) 
                {
                case SEMI:
                	{
                		alt31=1;
                	}
                    break;

                }

                switch (alt31) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:684:18: SEMI from_param
            	    {
            	         MATCHT(SEMI, &FOLLOW_SEMI_in_from_spec2466); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefrom_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_from_param_in_from_spec2468);
            	        from_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefrom_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop31;	/* break out of the loop */
            	    break;
                }
            }
            loop31: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefrom_specEx; /* Prevent compiler warnings */
    rulefrom_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end from_spec */

/** 
 * $ANTLR start from_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:685:1: from_param : generic_param[BELLE_SIP_PARAMETERS($header_from::current)] ;
 */
static void
from_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:686:2: ( generic_param[BELLE_SIP_PARAMETERS($header_from::current)] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:686:22: generic_param[BELLE_SIP_PARAMETERS($header_from::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_from_param2485);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_from))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefrom_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefrom_paramEx; /* Prevent compiler warnings */
    rulefrom_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end from_param */

/** 
 * $ANTLR start header_max_forwards
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:696:1: header_max_forwards returns [belle_sip_header_max_forwards_t* ret] : {...}? token hcolon max_forwards ;
 */
static belle_sip_header_max_forwards_t*
header_max_forwards(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_max_forwards_t* ret = NULL;

    belle_sip_messageParser_max_forwards_return max_forwards43;
    #undef	RETURN_TYPE_max_forwards43
    #define	RETURN_TYPE_max_forwards43 belle_sip_messageParser_max_forwards_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_max_forwardsTop = pbelle_sip_messageParser_header_max_forwardsPush(ctx);
     	(SCOPE_TOP(header_max_forwards))->current= belle_sip_header_max_forwards_new();ret= 	(SCOPE_TOP(header_max_forwards))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:699:3: ({...}? token hcolon max_forwards )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:699:7: {...}? token hcolon max_forwards
        {
            if ( !((IS_TOKEN(Max-Forwards))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_max_forwardsPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Max-Forwards)";
                    EXCEPTION->ruleName	 = (void *)"header_max_forwards";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_max_forwards2546);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_max_forwardsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_max_forwardsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_max_forwards2550);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_max_forwardsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_max_forwardsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_max_forwards_in_header_max_forwards2557);
            max_forwards43=max_forwards(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_max_forwardsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_max_forwardsPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_max_forwards_set_max_forwards(	(SCOPE_TOP(header_max_forwards))->current,atoi((const char*)(STRSTREAM->toStringTT(STRSTREAM, max_forwards43.start, max_forwards43.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_max_forwardsEx; /* Prevent compiler warnings */
    ruleheader_max_forwardsEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_max_forwards))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_max_forwardsPop(ctx);

    return ret;
}
/* $ANTLR end header_max_forwards */

/** 
 * $ANTLR start max_forwards
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:707:1: max_forwards : ( DIGIT )+ ;
 */
static belle_sip_messageParser_max_forwards_return
max_forwards(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_max_forwards_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:707:13: ( ( DIGIT )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:707:14: ( DIGIT )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:707:14: ( DIGIT )+
            {
                int cnt32=0;

                for (;;)
                {
                    int alt32=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt32=1;
            		}
            	    break;

            	}

            	switch (alt32) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:707:14: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_max_forwards2571); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemax_forwardsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt32 >= 1 )
            		{
            		    goto loop32;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulemax_forwardsEx;
            	}
            	cnt32++;
                }
                loop32: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemax_forwardsEx; /* Prevent compiler warnings */
    rulemax_forwardsEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end max_forwards */

/** 
 * $ANTLR start header_proxy_authenticate
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:730:1: header_proxy_authenticate returns [belle_sip_header_proxy_authenticate_t* ret] : {...}? token hcolon challenge[BELLE_SIP_HEADER_WWW_AUTHENTICATE($header_proxy_authenticate::current)] ;
 */
static belle_sip_header_proxy_authenticate_t*
header_proxy_authenticate(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_proxy_authenticate_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_proxy_authenticateTop = pbelle_sip_messageParser_header_proxy_authenticatePush(ctx);
     	(SCOPE_TOP(header_proxy_authenticate))->current= belle_sip_header_proxy_authenticate_new();ret= 	(SCOPE_TOP(header_proxy_authenticate))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:733:2: ({...}? token hcolon challenge[BELLE_SIP_HEADER_WWW_AUTHENTICATE($header_proxy_authenticate::current)] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:733:6: {...}? token hcolon challenge[BELLE_SIP_HEADER_WWW_AUTHENTICATE($header_proxy_authenticate::current)]
        {
            if ( !((IS_TOKEN(Proxy-Authenticate))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Proxy-Authenticate)";
                    EXCEPTION->ruleName	 = (void *)"header_proxy_authenticate";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_proxy_authenticate2605);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_proxy_authenticate2611);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_challenge_in_header_proxy_authenticate2613);
            challenge(ctx, BELLE_SIP_HEADER_WWW_AUTHENTICATE(	(SCOPE_TOP(header_proxy_authenticate))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_proxy_authenticateEx; /* Prevent compiler warnings */
    ruleheader_proxy_authenticateEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_proxy_authenticate))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

    return ret;
}
/* $ANTLR end header_proxy_authenticate */

/** 
 * $ANTLR start challenge
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:742:1: challenge[belle_sip_header_www_authenticate_t* www_authenticate] : ( ({...}? token LWS digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] );
 */
static void
challenge(pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:743:2: ( ({...}? token LWS digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] )
            
            ANTLR3_UINT32 alt34;

            alt34=2;

            alt34 = cdfa34.predict(ctx, RECOGNIZER, ISTREAM, &cdfa34);
            if  (HASEXCEPTION())
            {
                goto rulechallengeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt34) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:743:6: ({...}? token LWS digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* )
        	    {
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:743:6: ({...}? token LWS digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* )
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:743:7: {...}? token LWS digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )*
        	        {
        	            if ( !((IS_TOKEN(Digest))) ) 
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"IS_TOKEN(Digest)";
        	                    EXCEPTION->ruleName	 = (void *)"challenge";


        	            }
        	            FOLLOWPUSH(FOLLOW_token_in_challenge2648);
        	            token(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulechallengeEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            if ( BACKTRACKING==0 ) 
        	            {
        	                belle_sip_header_www_authenticate_set_scheme(www_authenticate,"Digest");
        	            }
        	             MATCHT(LWS, &FOLLOW_LWS_in_challenge2659); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulechallengeEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            FOLLOWPUSH(FOLLOW_digest_cln_in_challenge2661);
        	            digest_cln(ctx, www_authenticate);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulechallengeEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:744:38: ( comma digest_cln[www_authenticate] )*

        	            for (;;)
        	            {
        	                int alt33=2;
        	                switch ( LA(1) ) 
        	                {
        	                case LWS:
        	                case COMMA:
        	                	{
        	                		alt33=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt33) 
        	                {
        	            	case 1:
        	            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:744:39: comma digest_cln[www_authenticate]
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_comma_in_challenge2665);
        	            	        comma(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulechallengeEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }
        	            	        FOLLOWPUSH(FOLLOW_digest_cln_in_challenge2667);
        	            	        digest_cln(ctx, www_authenticate);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulechallengeEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop33;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop33: ; /* Jump out to here if this rule does not match */


        	        }


        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:745:26: other_challenge[www_authenticate]
        	    {
        	        FOLLOWPUSH(FOLLOW_other_challenge_in_challenge2698);
        	        other_challenge(ctx, www_authenticate);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulechallengeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulechallengeEx; /* Prevent compiler warnings */
    rulechallengeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end challenge */

/** 
 * $ANTLR start other_challenge
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:746:1: other_challenge[belle_sip_header_www_authenticate_t* www_authenticate] : auth_scheme LWS auth_param[NULL] ( comma auth_param[NULL] )* ;
 */
static void
other_challenge(pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate)
{   
    belle_sip_messageParser_auth_scheme_return auth_scheme44;
    #undef	RETURN_TYPE_auth_scheme44
    #define	RETURN_TYPE_auth_scheme44 belle_sip_messageParser_auth_scheme_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:747:2: ( auth_scheme LWS auth_param[NULL] ( comma auth_param[NULL] )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:747:6: auth_scheme LWS auth_param[NULL] ( comma auth_param[NULL] )*
        {
            FOLLOWPUSH(FOLLOW_auth_scheme_in_other_challenge2716);
            auth_scheme44=auth_scheme(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_challengeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_www_authenticate_set_scheme(www_authenticate,(char*)(STRSTREAM->toStringTT(STRSTREAM, auth_scheme44.start, auth_scheme44.stop))->chars);
            }
             MATCHT(LWS, &FOLLOW_LWS_in_other_challenge2725); 
            if  (HASEXCEPTION())
            {
                goto ruleother_challengeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_auth_param_in_other_challenge2727);
            auth_param(ctx, NULL);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_challengeEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:749:24: ( comma auth_param[NULL] )*

            for (;;)
            {
                int alt35=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case COMMA:
                	{
                		alt35=1;
                	}
                    break;

                }

                switch (alt35) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:749:25: comma auth_param[NULL]
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_other_challenge2754);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleother_challengeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_auth_param_in_other_challenge2756);
            	        auth_param(ctx, NULL);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleother_challengeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop35;	/* break out of the loop */
            	    break;
                }
            }
            loop35: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleother_challengeEx; /* Prevent compiler warnings */
    ruleother_challengeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end other_challenge */

/** 
 * $ANTLR start digest_cln
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:750:1: digest_cln[belle_sip_header_www_authenticate_t* www_authenticate] : ( | realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] );
 */
static void
digest_cln(pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate)
{   
    char* realm45;
    #undef	RETURN_TYPE_realm45
    #define	RETURN_TYPE_realm45 char*

    char* nonce46;
    #undef	RETURN_TYPE_nonce46
    #define	RETURN_TYPE_nonce46 char*

    const char* algorithm47;
    #undef	RETURN_TYPE_algorithm47
    #define	RETURN_TYPE_algorithm47 const char*

    char* opaque48;
    #undef	RETURN_TYPE_opaque48
    #define	RETURN_TYPE_opaque48 char*

    belle_sip_list_t* qop_opts49;
    #undef	RETURN_TYPE_qop_opts49
    #define	RETURN_TYPE_qop_opts49 belle_sip_list_t*

    char* domain50;
    #undef	RETURN_TYPE_domain50
    #define	RETURN_TYPE_domain50 char*

    const char* stale51;
    #undef	RETURN_TYPE_stale51
    #define	RETURN_TYPE_stale51 const char*

    /* Initialize rule variables
     */


    realm45 = NULL;
    nonce46 = NULL;
    algorithm47 = NULL;
    opaque48 = NULL;
    qop_opts49 = NULL;
    domain50 = NULL;
    stale51 = NULL;

    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:751:2: ( | realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] )
            
            ANTLR3_UINT32 alt36;

            alt36=9;

            alt36 = cdfa36.predict(ctx, RECOGNIZER, ISTREAM, &cdfa36);
            if  (HASEXCEPTION())
            {
                goto ruledigest_clnEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt36) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:752:3: 
        	    {
        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:752:5: realm
        	    {
        	        FOLLOWPUSH(FOLLOW_realm_in_digest_cln2783);
        	        realm45=realm(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_realm(www_authenticate,(char*)realm45);
        	                       belle_sip_free(realm45);
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:754:5: nonce
        	    {
        	        FOLLOWPUSH(FOLLOW_nonce_in_digest_cln2792);
        	        nonce46=nonce(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_nonce(www_authenticate,(char*)nonce46);
        	                       belle_sip_free(nonce46);
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:756:5: algorithm
        	    {
        	        FOLLOWPUSH(FOLLOW_algorithm_in_digest_cln2800);
        	        algorithm47=algorithm(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_algorithm(www_authenticate,algorithm47);
        	        }

        	    }
        	    break;
        	case 5:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:757:5: opaque
        	    {
        	        FOLLOWPUSH(FOLLOW_opaque_in_digest_cln2809);
        	        opaque48=opaque(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_opaque(www_authenticate,opaque48);
        	                         belle_sip_free(opaque48);
        	        }

        	    }
        	    break;
        	case 6:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:759:5: qop_opts
        	    {
        	        FOLLOWPUSH(FOLLOW_qop_opts_in_digest_cln2818);
        	        qop_opts49=qop_opts(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_qop(www_authenticate,qop_opts49);
        	                          /*belle_sip_free(qop_opts49);*/
        	        }

        	    }
        	    break;
        	case 7:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:761:4: domain
        	    {
        	        FOLLOWPUSH(FOLLOW_domain_in_digest_cln2825);
        	        domain50=domain(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_domain(www_authenticate,domain50);
        	                         belle_sip_free(domain50);
        	        }

        	    }
        	    break;
        	case 8:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:763:4: stale
        	    {
        	        FOLLOWPUSH(FOLLOW_stale_in_digest_cln2833);
        	        stale51=stale(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             if (strcmp("true",stale51)==0) {
        	            	             belle_sip_header_www_authenticate_set_stale(www_authenticate,1);
        	            	           }
        	            	        
        	        }

        	    }
        	    break;
        	case 9:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:767:8: auth_param[(belle_sip_header_authorization_t*)www_authenticate]
        	    {
        	        FOLLOWPUSH(FOLLOW_auth_param_in_digest_cln2844);
        	        auth_param(ctx, (belle_sip_header_authorization_t*)www_authenticate);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledigest_clnEx; /* Prevent compiler warnings */
    ruledigest_clnEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end digest_cln */

/** 
 * $ANTLR start realm
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:770:1: realm returns [char* ret] : {...}? token equal realm_value ;
 */
static char*
realm(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_realm_value_return realm_value52;
    #undef	RETURN_TYPE_realm_value52
    #define	RETURN_TYPE_realm_value52 belle_sip_messageParser_realm_value_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:771:2: ({...}? token equal realm_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:771:6: {...}? token equal realm_value
        {
            if ( !((IS_TOKEN(realm))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(realm)";
                    EXCEPTION->ruleName	 = (void *)"realm";


            }
            FOLLOWPUSH(FOLLOW_token_in_realm2878);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerealmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_realm2882);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerealmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_realm_value_in_realm2884);
            realm_value52=realm_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerealmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                	                    ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, realm_value52.start, realm_value52.stop))->chars);
                	                     
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerealmEx; /* Prevent compiler warnings */
    rulerealmEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end realm */

/** 
 * $ANTLR start realm_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:774:1: realm_value : quoted_string ;
 */
static belle_sip_messageParser_realm_value_return
realm_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_realm_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:775:2: ( quoted_string )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:775:6: quoted_string
        {
            FOLLOWPUSH(FOLLOW_quoted_string_in_realm_value2905);
            quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerealm_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerealm_valueEx; /* Prevent compiler warnings */
    rulerealm_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end realm_value */

/** 
 * $ANTLR start domain
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:777:1: domain returns [char* ret] : {...}? token equal quoted_string ;
 */
static char*
domain(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_quoted_string_return quoted_string53;
    #undef	RETURN_TYPE_quoted_string53
    #define	RETURN_TYPE_quoted_string53 belle_sip_messageParser_quoted_string_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:778:2: ({...}? token equal quoted_string )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:778:6: {...}? token equal quoted_string
        {
            if ( !((IS_TOKEN(domain))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(domain)";
                    EXCEPTION->ruleName	 = (void *)"domain";


            }
            FOLLOWPUSH(FOLLOW_token_in_domain2937);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledomainEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_domain2941);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledomainEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_quoted_string_in_domain2943);
            quoted_string53=quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledomainEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, quoted_string53.start, quoted_string53.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledomainEx; /* Prevent compiler warnings */
    ruledomainEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end domain */

/** 
 * $ANTLR start nonce
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:785:1: nonce returns [char* ret] : {...}? token equal nonce_value ;
 */
static char*
nonce(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_nonce_value_return nonce_value54;
    #undef	RETURN_TYPE_nonce_value54
    #define	RETURN_TYPE_nonce_value54 belle_sip_messageParser_nonce_value_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:786:2: ({...}? token equal nonce_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:786:6: {...}? token equal nonce_value
        {
            if ( !((IS_TOKEN(nonce))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(nonce)";
                    EXCEPTION->ruleName	 = (void *)"nonce";


            }
            FOLLOWPUSH(FOLLOW_token_in_nonce2978);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_nonce2982);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_nonce_value_in_nonce2984);
            nonce_value54=nonce_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, nonce_value54.start, nonce_value54.stop))->chars);
                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenonceEx; /* Prevent compiler warnings */
    rulenonceEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end nonce */

/** 
 * $ANTLR start opaque
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:789:1: opaque returns [char* ret] : {...}? token equal quoted_string ;
 */
static char*
opaque(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_quoted_string_return quoted_string55;
    #undef	RETURN_TYPE_quoted_string55
    #define	RETURN_TYPE_quoted_string55 belle_sip_messageParser_quoted_string_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:790:3: ({...}? token equal quoted_string )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:790:7: {...}? token equal quoted_string
        {
            if ( !((IS_TOKEN(opaque))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(opaque)";
                    EXCEPTION->ruleName	 = (void *)"opaque";


            }
            FOLLOWPUSH(FOLLOW_token_in_opaque3015);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopaqueEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_opaque3019);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopaqueEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_quoted_string_in_opaque3021);
            quoted_string55=quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopaqueEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, quoted_string55.start, quoted_string55.stop))->chars);
                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleopaqueEx; /* Prevent compiler warnings */
    ruleopaqueEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end opaque */

/** 
 * $ANTLR start stale
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:794:1: stale returns [const char* ret] : {...}? token equal stale_value ;
 */
static const char*
stale(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_stale_value_return stale_value56;
    #undef	RETURN_TYPE_stale_value56
    #define	RETURN_TYPE_stale_value56 belle_sip_messageParser_stale_value_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:795:2: ({...}? token equal stale_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:795:6: {...}? token equal stale_value
        {
            if ( !((IS_TOKEN(stale))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(stale)";
                    EXCEPTION->ruleName	 = (void *)"stale";


            }
            FOLLOWPUSH(FOLLOW_token_in_stale3053);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestaleEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_stale3057);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestaleEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_stale_value_in_stale3059);
            stale_value56=stale_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestaleEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=(char*)(STRSTREAM->toStringTT(STRSTREAM, stale_value56.start, stale_value56.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestaleEx; /* Prevent compiler warnings */
    rulestaleEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end stale */

/** 
 * $ANTLR start stale_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:797:1: stale_value : token ;
 */
static belle_sip_messageParser_stale_value_return
stale_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_stale_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:797:12: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:797:13: token
        {
            FOLLOWPUSH(FOLLOW_token_in_stale_value3069);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestale_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestale_valueEx; /* Prevent compiler warnings */
    rulestale_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end stale_value */

/** 
 * $ANTLR start algorithm
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:799:1: algorithm returns [const char* ret] : {...}? token equal alg_value= token ;
 */
static const char*
algorithm(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_token_return alg_value;
    #undef	RETURN_TYPE_alg_value
    #define	RETURN_TYPE_alg_value belle_sip_messageParser_token_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:800:2: ({...}? token equal alg_value= token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:800:6: {...}? token equal alg_value= token
        {
            if ( !((IS_TOKEN(algorithm))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(algorithm)";
                    EXCEPTION->ruleName	 = (void *)"algorithm";


            }
            FOLLOWPUSH(FOLLOW_token_in_algorithm3097);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealgorithmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_algorithm3101);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealgorithmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_token_in_algorithm3107);
            alg_value=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealgorithmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=(char*)(STRSTREAM->toStringTT(STRSTREAM, alg_value.start, alg_value.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealgorithmEx; /* Prevent compiler warnings */
    rulealgorithmEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end algorithm */

/** 
 * $ANTLR start qop_opts
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:804:1: qop_opts returns [belle_sip_list_t* ret] : {...}? token equal ldquot qop_opts_value ( COMMA qop_opts_value )* rdquot ;
 */
static belle_sip_list_t*
qop_opts(pbelle_sip_messageParser ctx)
{   
    belle_sip_list_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_qop_optsTop = pbelle_sip_messageParser_qop_optsPush(ctx);
    	(SCOPE_TOP(qop_opts))->list=NULL;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:807:2: ({...}? token equal ldquot qop_opts_value ( COMMA qop_opts_value )* rdquot )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:807:6: {...}? token equal ldquot qop_opts_value ( COMMA qop_opts_value )* rdquot
        {
            if ( !((IS_TOKEN(qop))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_qop_optsPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(qop)";
                    EXCEPTION->ruleName	 = (void *)"qop_opts";


            }
            FOLLOWPUSH(FOLLOW_token_in_qop_opts3146);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_qop_opts3150);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_ldquot_in_qop_opts3154);
            ldquot(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_qop_opts_value_in_qop_opts3158);
            qop_opts_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:810:3: ( COMMA qop_opts_value )*

            for (;;)
            {
                int alt37=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt37=1;
                	}
                    break;

                }

                switch (alt37) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:810:4: COMMA qop_opts_value
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_qop_opts3164); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleqop_optsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_qop_optsPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_qop_opts_value_in_qop_opts3166);
            	        qop_opts_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleqop_optsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_qop_optsPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */

            FOLLOWPUSH(FOLLOW_rdquot_in_qop_opts3173);
            rdquot(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=	(SCOPE_TOP(qop_opts))->list;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleqop_optsEx; /* Prevent compiler warnings */
    ruleqop_optsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_qop_optsPop(ctx);

    return ret;
}
/* $ANTLR end qop_opts */

/** 
 * $ANTLR start qop_opts_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:813:1: qop_opts_value : token ;
 */
static void
qop_opts_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_token_return token57;
    #undef	RETURN_TYPE_token57
    #define	RETURN_TYPE_token57 belle_sip_messageParser_token_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:814:1: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:814:3: token
        {
            FOLLOWPUSH(FOLLOW_token_in_qop_opts_value3188);
            token57=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_opts_valueEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                	(SCOPE_TOP(qop_opts))->list=belle_sip_list_append(	(SCOPE_TOP(qop_opts))->list,belle_sip_strdup((const char*)(STRSTREAM->toStringTT(STRSTREAM, token57.start, token57.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleqop_opts_valueEx; /* Prevent compiler warnings */
    ruleqop_opts_valueEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end qop_opts_value */

/** 
 * $ANTLR start header_proxy_authorization
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:816:1: header_proxy_authorization returns [belle_sip_header_proxy_authorization_t* ret] : {...}? token hcolon credentials[(belle_sip_header_authorization_t*)$header_proxy_authorization::current] ;
 */
static belle_sip_header_proxy_authorization_t*
header_proxy_authorization(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_proxy_authorization_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_proxy_authorizationTop = pbelle_sip_messageParser_header_proxy_authorizationPush(ctx);
     	(SCOPE_TOP(header_proxy_authorization))->current= belle_sip_header_proxy_authorization_new();ret= 	(SCOPE_TOP(header_proxy_authorization))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:819:2: ({...}? token hcolon credentials[(belle_sip_header_authorization_t*)$header_proxy_authorization::current] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:819:6: {...}? token hcolon credentials[(belle_sip_header_authorization_t*)$header_proxy_authorization::current]
        {
            if ( !((IS_TOKEN(Proxy-Authorization))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Proxy-Authorization)";
                    EXCEPTION->ruleName	 = (void *)"header_proxy_authorization";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_proxy_authorization3217);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_proxy_authorization3221);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_credentials_in_header_proxy_authorization3223);
            credentials(ctx, (belle_sip_header_authorization_t*)	(SCOPE_TOP(header_proxy_authorization))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_proxy_authorizationEx; /* Prevent compiler warnings */
    ruleheader_proxy_authorizationEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_proxy_authorization))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

    return ret;
}
/* $ANTLR end header_proxy_authorization */

/** 
 * $ANTLR start service_route_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:835:1: service_route_token : {...}? token ;
 */
static void
service_route_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:835:20: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:835:23: {...}? token
        {
            if ( !((IS_TOKEN(Service-Route))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Service-Route)";
                    EXCEPTION->ruleName	 = (void *)"service_route_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_service_route_token3244);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleservice_route_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleservice_route_tokenEx; /* Prevent compiler warnings */
    ruleservice_route_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end service_route_token */

/** 
 * $ANTLR start header_service_route
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:836:1: header_service_route returns [belle_sip_header_service_route_t* ret] : service_route_token hcolon srv_route ( comma srv_route )* ;
 */
static belle_sip_header_service_route_t*
header_service_route(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_service_route_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_service_routeTop = pbelle_sip_messageParser_header_service_routePush(ctx);
     	(SCOPE_TOP(header_service_route))->current= NULL;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:839:3: ( service_route_token hcolon srv_route ( comma srv_route )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:839:7: service_route_token hcolon srv_route ( comma srv_route )*
        {
            FOLLOWPUSH(FOLLOW_service_route_token_in_header_service_route3272);
            service_route_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_service_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_service_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_service_route3276);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_service_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_service_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_srv_route_in_header_service_route3278);
            srv_route(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_service_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_service_routePop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:839:64: ( comma srv_route )*

            for (;;)
            {
                int alt38=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case COMMA:
                	{
                		alt38=1;
                	}
                    break;

                }

                switch (alt38) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:839:65: comma srv_route
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_header_service_route3281);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_service_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_service_routePop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_srv_route_in_header_service_route3283);
            	        srv_route(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_service_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_service_routePop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop38;	/* break out of the loop */
            	    break;
                }
            }
            loop38: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_service_route))->first;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_service_routeEx; /* Prevent compiler warnings */
    ruleheader_service_routeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_service_route))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_service_routePop(ctx);

    return ret;
}
/* $ANTLR end header_service_route */

/** 
 * $ANTLR start srv_route
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:846:1: srv_route : name_addr[BELLE_SIP_HEADER_ADDRESS($header_service_route::current)] ( semi sr_param )* ;
 */
static void
srv_route(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_srv_routeTop = pbelle_sip_messageParser_srv_routePush(ctx);
     if (	(SCOPE_TOP(header_service_route))->current == NULL) {
                	(SCOPE_TOP(header_service_route))->first= 	(SCOPE_TOP(header_service_route))->current = belle_sip_header_service_route_new();
                	(SCOPE_TOP(srv_route))->prev=NULL;
             } else {
                belle_sip_header_t* header = BELLE_SIP_HEADER(	(SCOPE_TOP(header_service_route))->current); 
                	(SCOPE_TOP(srv_route))->prev=	(SCOPE_TOP(header_service_route))->current;
                belle_sip_header_set_next(header,(belle_sip_header_t*)(	(SCOPE_TOP(header_service_route))->current= belle_sip_header_service_route_new()));
             } 
          
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:857:3: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_service_route::current)] ( semi sr_param )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:857:7: name_addr[BELLE_SIP_HEADER_ADDRESS($header_service_route::current)] ( semi sr_param )*
        {
            FOLLOWPUSH(FOLLOW_name_addr_in_srv_route3318);
            name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_service_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesrv_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_srv_routePop(ctx);

                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:857:75: ( semi sr_param )*

            for (;;)
            {
                int alt39=2;
                switch ( LA(1) ) 
                {
                case LWS:
                	{
                		switch ( LA(2) ) 
                		{
                		case SEMI:
                			{
                				alt39=1;
                			}
                		    break;

                		}

                	}
                    break;
                case SEMI:
                	{
                		alt39=1;
                	}
                    break;

                }

                switch (alt39) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:857:77: semi sr_param
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_srv_route3323);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesrv_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_srv_routePop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_sr_param_in_srv_route3325);
            	        sr_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesrv_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_srv_routePop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop39;	/* break out of the loop */
            	    break;
                }
            }
            loop39: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesrv_routeEx; /* Prevent compiler warnings */
    rulesrv_routeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if ( 	(SCOPE_TOP(srv_route))->prev == NULL) {
	          	(SCOPE_TOP(header_service_route))->first=NULL;
	       } else {
	         belle_sip_header_set_next(BELLE_SIP_HEADER(	(SCOPE_TOP(srv_route))->prev),NULL); 
	       }
	       belle_sip_object_unref(	(SCOPE_TOP(header_service_route))->current);
	       	(SCOPE_TOP(header_service_route))->current=	(SCOPE_TOP(srv_route))->prev;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_srv_routePop(ctx);

    return ;
}
/* $ANTLR end srv_route */

/** 
 * $ANTLR start sr_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:870:1: sr_param : generic_param[BELLE_SIP_PARAMETERS($header_service_route::current)] ;
 */
static void
sr_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:871:3: ( generic_param[BELLE_SIP_PARAMETERS($header_service_route::current)] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:871:7: generic_param[BELLE_SIP_PARAMETERS($header_service_route::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_sr_param3354);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_service_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesr_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesr_paramEx; /* Prevent compiler warnings */
    rulesr_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end sr_param */

/** 
 * $ANTLR start record_route_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:873:1: record_route_token : {...}? token ;
 */
static void
record_route_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:873:19: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:873:22: {...}? token
        {
            if ( !((IS_TOKEN(Record-Route))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Record-Route)";
                    EXCEPTION->ruleName	 = (void *)"record_route_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_record_route_token3367);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerecord_route_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerecord_route_tokenEx; /* Prevent compiler warnings */
    rulerecord_route_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end record_route_token */

/** 
 * $ANTLR start header_record_route
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:874:1: header_record_route returns [belle_sip_header_record_route_t* ret] : record_route_token hcolon rec_route ( comma rec_route )* ;
 */
static belle_sip_header_record_route_t*
header_record_route(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_record_route_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_record_routeTop = pbelle_sip_messageParser_header_record_routePush(ctx);
     	(SCOPE_TOP(header_record_route))->current= NULL;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:877:2: ( record_route_token hcolon rec_route ( comma rec_route )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:877:6: record_route_token hcolon rec_route ( comma rec_route )*
        {
            FOLLOWPUSH(FOLLOW_record_route_token_in_header_record_route3394);
            record_route_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_record_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_record_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_record_route3398);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_record_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_record_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_rec_route_in_header_record_route3400);
            rec_route(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_record_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_record_routePop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:877:61: ( comma rec_route )*

            for (;;)
            {
                int alt40=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case COMMA:
                	{
                		alt40=1;
                	}
                    break;

                }

                switch (alt40) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:877:62: comma rec_route
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_header_record_route3403);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_record_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_record_routePop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_rec_route_in_header_record_route3405);
            	        rec_route(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_record_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_record_routePop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop40;	/* break out of the loop */
            	    break;
                }
            }
            loop40: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_record_route))->first;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_record_routeEx; /* Prevent compiler warnings */
    ruleheader_record_routeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_record_route))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_record_routePop(ctx);

    return ret;
}
/* $ANTLR end header_record_route */

/** 
 * $ANTLR start rec_route
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:884:1: rec_route : name_addr[BELLE_SIP_HEADER_ADDRESS($header_record_route::current)] ( semi rr_param )* ;
 */
static void
rec_route(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_rec_routeTop = pbelle_sip_messageParser_rec_routePush(ctx);
     if (	(SCOPE_TOP(header_record_route))->current == NULL) {
                	(SCOPE_TOP(header_record_route))->first= 	(SCOPE_TOP(header_record_route))->current = belle_sip_header_record_route_new();
                	(SCOPE_TOP(rec_route))->prev=NULL;
             } else {
                belle_sip_header_t* header = BELLE_SIP_HEADER(	(SCOPE_TOP(header_record_route))->current); 
                	(SCOPE_TOP(rec_route))->prev=	(SCOPE_TOP(header_record_route))->current;
                belle_sip_header_set_next(header,(belle_sip_header_t*)(	(SCOPE_TOP(header_record_route))->current= belle_sip_header_record_route_new()));
             } 
          
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:895:2: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_record_route::current)] ( semi rr_param )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:895:6: name_addr[BELLE_SIP_HEADER_ADDRESS($header_record_route::current)] ( semi rr_param )*
        {
            FOLLOWPUSH(FOLLOW_name_addr_in_rec_route3439);
            name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_record_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerec_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_rec_routePop(ctx);

                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:895:73: ( semi rr_param )*

            for (;;)
            {
                int alt41=2;
                switch ( LA(1) ) 
                {
                case LWS:
                	{
                		switch ( LA(2) ) 
                		{
                		case SEMI:
                			{
                				alt41=1;
                			}
                		    break;

                		}

                	}
                    break;
                case SEMI:
                	{
                		alt41=1;
                	}
                    break;

                }

                switch (alt41) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:895:75: semi rr_param
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_rec_route3444);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerec_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_rec_routePop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_rr_param_in_rec_route3446);
            	        rr_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerec_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_rec_routePop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop41;	/* break out of the loop */
            	    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerec_routeEx; /* Prevent compiler warnings */
    rulerec_routeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if ( 	(SCOPE_TOP(rec_route))->prev == NULL) {
	          	(SCOPE_TOP(header_record_route))->first=NULL;
	       } else {
	         belle_sip_header_set_next(BELLE_SIP_HEADER(	(SCOPE_TOP(rec_route))->prev),NULL); 
	       }
	       belle_sip_object_unref(	(SCOPE_TOP(header_record_route))->current);
	       	(SCOPE_TOP(header_record_route))->current=	(SCOPE_TOP(rec_route))->prev;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_rec_routePop(ctx);

    return ;
}
/* $ANTLR end rec_route */

/** 
 * $ANTLR start rr_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:908:1: rr_param : generic_param[BELLE_SIP_PARAMETERS($header_record_route::current)] ;
 */
static void
rr_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:909:2: ( generic_param[BELLE_SIP_PARAMETERS($header_record_route::current)] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:909:6: generic_param[BELLE_SIP_PARAMETERS($header_record_route::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_rr_param3473);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_record_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerr_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerr_paramEx; /* Prevent compiler warnings */
    rulerr_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end rr_param */

/** 
 * $ANTLR start comment
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:925:1: comment : '(' . ')' ;
 */
static void
comment(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:925:9: ( '(' . ')' )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:925:11: '(' . ')'
        {
             MATCHT(LPAREN, &FOLLOW_LPAREN_in_comment3483); 
            if  (HASEXCEPTION())
            {
                goto rulecommentEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            MATCHANYT(); 
            if  (HASEXCEPTION())
            {
                goto rulecommentEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(RPAREN, &FOLLOW_RPAREN_in_comment3487); 
            if  (HASEXCEPTION())
            {
                goto rulecommentEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommentEx; /* Prevent compiler warnings */
    rulecommentEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end comment */

/** 
 * $ANTLR start route_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:932:1: route_token : {...}? token ;
 */
static void
route_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:932:12: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:932:15: {...}? token
        {
            if ( !((IS_TOKEN(Route))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Route)";
                    EXCEPTION->ruleName	 = (void *)"route_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_route_token3500);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleroute_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleroute_tokenEx; /* Prevent compiler warnings */
    ruleroute_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end route_token */

/** 
 * $ANTLR start header_route
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:933:1: header_route returns [belle_sip_header_route_t* ret] : route_token hcolon route_param ( comma route_param )* ;
 */
static belle_sip_header_route_t*
header_route(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_route_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_routeTop = pbelle_sip_messageParser_header_routePush(ctx);
     	(SCOPE_TOP(header_route))->current= NULL; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:936:3: ( route_token hcolon route_param ( comma route_param )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:936:7: route_token hcolon route_param ( comma route_param )*
        {
            FOLLOWPUSH(FOLLOW_route_token_in_header_route3528);
            route_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_route3532);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_route_param_in_header_route3534);
            route_param(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_routePop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:936:50: ( comma route_param )*

            for (;;)
            {
                int alt42=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case COMMA:
                	{
                		alt42=1;
                	}
                    break;

                }

                switch (alt42) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:936:51: comma route_param
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_header_route3537);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_routePop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_route_param_in_header_route3539);
            	        route_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_routePop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_route))->first;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_routeEx; /* Prevent compiler warnings */
    ruleheader_routeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_header_routePop(ctx);

    return ret;
}
/* $ANTLR end header_route */

/** 
 * $ANTLR start route_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:937:1: route_param : name_addr[BELLE_SIP_HEADER_ADDRESS($header_route::current)] ( semi r_param )* ;
 */
static void
route_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_route_paramTop = pbelle_sip_messageParser_route_paramPush(ctx);
     if (	(SCOPE_TOP(header_route))->current == NULL) {
                	(SCOPE_TOP(header_route))->first= 	(SCOPE_TOP(header_route))->current = belle_sip_header_route_new();
                 	(SCOPE_TOP(route_param))->prev=NULL;
             } else {
                belle_sip_header_t* header = BELLE_SIP_HEADER(	(SCOPE_TOP(header_route))->current); 
                	(SCOPE_TOP(route_param))->prev=	(SCOPE_TOP(header_route))->current;
                belle_sip_header_set_next(header,(belle_sip_header_t*)(	(SCOPE_TOP(header_route))->current= belle_sip_header_route_new()));
             } 
          
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:948:3: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_route::current)] ( semi r_param )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:948:7: name_addr[BELLE_SIP_HEADER_ADDRESS($header_route::current)] ( semi r_param )*
        {
            FOLLOWPUSH(FOLLOW_name_addr_in_route_param3569);
            name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleroute_paramEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_route_paramPop(ctx);

                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:948:67: ( semi r_param )*

            for (;;)
            {
                int alt43=2;
                switch ( LA(1) ) 
                {
                case LWS:
                	{
                		switch ( LA(2) ) 
                		{
                		case SEMI:
                			{
                				alt43=1;
                			}
                		    break;

                		}

                	}
                    break;
                case SEMI:
                	{
                		alt43=1;
                	}
                    break;

                }

                switch (alt43) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:948:69: semi r_param
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_route_param3574);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleroute_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_route_paramPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_r_param_in_route_param3576);
            	        r_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleroute_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_route_paramPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop43;	/* break out of the loop */
            	    break;
                }
            }
            loop43: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleroute_paramEx; /* Prevent compiler warnings */
    ruleroute_paramEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if ( 	(SCOPE_TOP(route_param))->prev == NULL) {
	          	(SCOPE_TOP(header_route))->first=NULL;
	       } else {
	         belle_sip_header_set_next(BELLE_SIP_HEADER(	(SCOPE_TOP(route_param))->prev),NULL); 
	       }
	       belle_sip_object_unref(	(SCOPE_TOP(header_record_route))->current);
	       	(SCOPE_TOP(header_route))->current=	(SCOPE_TOP(route_param))->prev;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_route_paramPop(ctx);

    return ;
}
/* $ANTLR end route_param */

/** 
 * $ANTLR start r_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:960:1: r_param : generic_param[BELLE_SIP_PARAMETERS($header_route::current)] ;
 */
static void
r_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:961:3: ( generic_param[BELLE_SIP_PARAMETERS($header_route::current)] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:961:7: generic_param[BELLE_SIP_PARAMETERS($header_route::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_r_param3604);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruler_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruler_paramEx; /* Prevent compiler warnings */
    ruler_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end r_param */

/** 
 * $ANTLR start to_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:985:1: to_token : {...}? token ;
 */
static void
to_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:985:9: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:985:12: {...}? token
        {
            if ( !((IS_HEADER_NAMED(To,t))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(To,t)";
                    EXCEPTION->ruleName	 = (void *)"to_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_to_token3619);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleto_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleto_tokenEx; /* Prevent compiler warnings */
    ruleto_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end to_token */

/** 
 * $ANTLR start header_to
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:986:1: header_to returns [belle_sip_header_to_t* ret] : to_token hcolon to_spec ;
 */
static belle_sip_header_to_t*
header_to(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_to_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_toTop = pbelle_sip_messageParser_header_toPush(ctx);
     	(SCOPE_TOP(header_to))->current= belle_sip_header_to_new(); ret= 	(SCOPE_TOP(header_to))->current;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:990:3: ( to_token hcolon to_spec )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:990:7: to_token hcolon to_spec
        {
            FOLLOWPUSH(FOLLOW_to_token_in_header_to3656);
            to_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_toEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_toPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_to3660);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_toEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_toPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_to_spec_in_header_to3662);
            to_spec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_toEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_toPop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_toEx; /* Prevent compiler warnings */
    ruleheader_toEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_to))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_toPop(ctx);

    return ret;
}
/* $ANTLR end header_to */

/** 
 * $ANTLR start to_spec
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:997:1: to_spec : ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_to::current)] ) ( semi to_param )* ;
 */
static void
to_spec(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:998:3: ( ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_to::current)] ) ( semi to_param )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:998:7: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_to::current)] ) ( semi to_param )*
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:998:7: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_to::current)] )
            {
                int alt44=2;
                alt44 = cdfa44.predict(ctx, RECOGNIZER, ISTREAM, &cdfa44);
                if  (HASEXCEPTION())
                {
                    goto ruleto_specEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                switch (alt44) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:998:9: name_addr[BELLE_SIP_HEADER_ADDRESS($header_to::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_name_addr_in_to_spec3686);
            	        name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_to))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleto_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:998:68: paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_to::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_paramless_addr_spec_in_to_spec3691);
            	        paramless_addr_spec(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_to))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleto_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:999:16: ( semi to_param )*

            for (;;)
            {
                int alt45=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case SEMI:
                	{
                		alt45=1;
                	}
                    break;

                }

                switch (alt45) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:999:18: semi to_param
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_to_spec3713);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleto_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_to_param_in_to_spec3715);
            	        to_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleto_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop45;	/* break out of the loop */
            	    break;
                }
            }
            loop45: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleto_specEx; /* Prevent compiler warnings */
    ruleto_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end to_spec */

/** 
 * $ANTLR start to_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1000:1: to_param : generic_param[BELLE_SIP_PARAMETERS($header_to::current)] ;
 */
static void
to_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1001:3: ( generic_param[BELLE_SIP_PARAMETERS($header_to::current)] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1001:23: generic_param[BELLE_SIP_PARAMETERS($header_to::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_to_param3733);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_to))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleto_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleto_paramEx; /* Prevent compiler warnings */
    ruleto_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end to_param */

/** 
 * $ANTLR start refer_to_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1003:1: refer_to_token : {...}? token ;
 */
static void
refer_to_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1003:15: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1003:18: {...}? token
        {
            if ( !((IS_TOKEN(Refer-To))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Refer-To)";
                    EXCEPTION->ruleName	 = (void *)"refer_to_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_refer_to_token3745);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerefer_to_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerefer_to_tokenEx; /* Prevent compiler warnings */
    rulerefer_to_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end refer_to_token */

/** 
 * $ANTLR start header_refer_to
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1004:1: header_refer_to returns [belle_sip_header_refer_to_t* ret] : refer_to_token hcolon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_refer_to_new())] ;
 */
static belle_sip_header_refer_to_t*
header_refer_to(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_refer_to_t* ret = NULL;

    belle_sip_header_address_t* refer_to_spec58;
    #undef	RETURN_TYPE_refer_to_spec58
    #define	RETURN_TYPE_refer_to_spec58 belle_sip_header_address_t*

    /* Initialize rule variables
     */


    refer_to_spec58 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1005:3: ( refer_to_token hcolon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_refer_to_new())] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1005:7: refer_to_token hcolon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_refer_to_new())]
        {
            FOLLOWPUSH(FOLLOW_refer_to_token_in_header_refer_to3764);
            refer_to_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_refer_toEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_refer_to3775);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_refer_toEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_refer_to_spec_in_header_refer_to3784);
            refer_to_spec58=refer_to_spec(ctx, BELLE_SIP_HEADER_ADDRESS(belle_sip_header_refer_to_new()));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_refer_toEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= BELLE_SIP_HEADER_REFER_TO(refer_to_spec58);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_refer_toEx; /* Prevent compiler warnings */
    ruleheader_refer_toEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end header_refer_to */

/** 
 * $ANTLR start referred_by_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1009:1: referred_by_token : {...}? token ;
 */
static void
referred_by_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1009:18: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1009:21: {...}? token
        {
            if ( !((IS_TOKEN(Referred-By))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Referred-By)";
                    EXCEPTION->ruleName	 = (void *)"referred_by_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_referred_by_token3797);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulereferred_by_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereferred_by_tokenEx; /* Prevent compiler warnings */
    rulereferred_by_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end referred_by_token */

/** 
 * $ANTLR start header_referred_by
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1010:1: header_referred_by returns [belle_sip_header_referred_by_t* ret] : referred_by_token hcolon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_referred_by_new())] ;
 */
static belle_sip_header_referred_by_t*
header_referred_by(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_referred_by_t* ret = NULL;

    belle_sip_header_address_t* refer_to_spec59;
    #undef	RETURN_TYPE_refer_to_spec59
    #define	RETURN_TYPE_refer_to_spec59 belle_sip_header_address_t*

    /* Initialize rule variables
     */


    refer_to_spec59 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1011:3: ( referred_by_token hcolon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_referred_by_new())] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1011:7: referred_by_token hcolon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_referred_by_new())]
        {
            FOLLOWPUSH(FOLLOW_referred_by_token_in_header_referred_by3816);
            referred_by_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_referred_byEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_referred_by3827);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_referred_byEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_refer_to_spec_in_header_referred_by3836);
            refer_to_spec59=refer_to_spec(ctx, BELLE_SIP_HEADER_ADDRESS(belle_sip_header_referred_by_new()));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_referred_byEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= BELLE_SIP_HEADER_REFERRED_BY(refer_to_spec59);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_referred_byEx; /* Prevent compiler warnings */
    ruleheader_referred_byEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end header_referred_by */

/** 
 * $ANTLR start refer_to_spec
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1015:1: refer_to_spec[belle_sip_header_address_t* address] returns [belle_sip_header_address_t* ret] : ( ( name_addr[address] | paramless_addr_spec[address] ) ( semi generic_param[BELLE_SIP_PARAMETERS(address)] )* ) ;
 */
static belle_sip_header_address_t*
refer_to_spec(pbelle_sip_messageParser ctx, belle_sip_header_address_t* address)
{   
    belle_sip_header_address_t* ret = NULL;

    /* Initialize rule variables
     */


    ret=address;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:3: ( ( ( name_addr[address] | paramless_addr_spec[address] ) ( semi generic_param[BELLE_SIP_PARAMETERS(address)] )* ) )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:7: ( ( name_addr[address] | paramless_addr_spec[address] ) ( semi generic_param[BELLE_SIP_PARAMETERS(address)] )* )
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:7: ( ( name_addr[address] | paramless_addr_spec[address] ) ( semi generic_param[BELLE_SIP_PARAMETERS(address)] )* )
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:8: ( name_addr[address] | paramless_addr_spec[address] ) ( semi generic_param[BELLE_SIP_PARAMETERS(address)] )*
            {

                // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:8: ( name_addr[address] | paramless_addr_spec[address] )
                {
                    int alt46=2;
                    alt46 = cdfa46.predict(ctx, RECOGNIZER, ISTREAM, &cdfa46);
                    if  (HASEXCEPTION())
                    {
                        goto rulerefer_to_specEx;
                    }
                    if (HASFAILED())
                    {
                        return ret;
                    }
                    switch (alt46) 
                    {
                	case 1:
                	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:10: name_addr[address]
                	    {
                	        FOLLOWPUSH(FOLLOW_name_addr_in_refer_to_spec3870);
                	        name_addr(ctx, address);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulerefer_to_specEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ret;
                	        }

                	    }
                	    break;
                	case 2:
                	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:31: paramless_addr_spec[address]
                	    {
                	        FOLLOWPUSH(FOLLOW_paramless_addr_spec_in_refer_to_spec3875);
                	        paramless_addr_spec(ctx, address);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulerefer_to_specEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ret;
                	        }

                	    }
                	    break;

                    }
                }

                // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:63: ( semi generic_param[BELLE_SIP_PARAMETERS(address)] )*

                for (;;)
                {
                    int alt47=2;
                    switch ( LA(1) ) 
                    {
                    case LWS:
                    case SEMI:
                    	{
                    		alt47=1;
                    	}
                        break;

                    }

                    switch (alt47) 
                    {
                	case 1:
                	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1017:65: semi generic_param[BELLE_SIP_PARAMETERS(address)]
                	    {
                	        FOLLOWPUSH(FOLLOW_semi_in_refer_to_spec3883);
                	        semi(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulerefer_to_specEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ret;
                	        }
                	        FOLLOWPUSH(FOLLOW_generic_param_in_refer_to_spec3885);
                	        generic_param(ctx, BELLE_SIP_PARAMETERS(address));

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulerefer_to_specEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ret;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop47;	/* break out of the loop */
                	    break;
                    }
                }
                loop47: ; /* Jump out to here if this rule does not match */


            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerefer_to_specEx; /* Prevent compiler warnings */
    rulerefer_to_specEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(address);
	       ret=NULL;

	}


    }
    else
    {
    }

    return ret;
}
/* $ANTLR end refer_to_spec */

/** 
 * $ANTLR start header_user_agent
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1030:1: header_user_agent returns [belle_sip_header_user_agent_t* ret] : {...}? token hcolon server_val ( LWS server_val )* ;
 */
static belle_sip_header_user_agent_t*
header_user_agent(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_user_agent_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_user_agentTop = pbelle_sip_messageParser_header_user_agentPush(ctx);
     	(SCOPE_TOP(header_user_agent))->current= belle_sip_header_user_agent_new();ret= 	(SCOPE_TOP(header_user_agent))->current;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1033:2: ({...}? token hcolon server_val ( LWS server_val )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1033:6: {...}? token hcolon server_val ( LWS server_val )*
        {
            if ( !((IS_TOKEN(User-Agent))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_user_agentPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(User-Agent)";
                    EXCEPTION->ruleName	 = (void *)"header_user_agent";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_user_agent3936);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_user_agentEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_user_agentPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_user_agent3940);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_user_agentEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_user_agentPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_server_val_in_header_user_agent3942);
            server_val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_user_agentEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_user_agentPop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1033:71: ( LWS server_val )*

            for (;;)
            {
                int alt48=2;
                switch ( LA(1) ) 
                {
                case LWS:
                	{
                		alt48=1;
                	}
                    break;

                }

                switch (alt48) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1033:72: LWS server_val
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_header_user_agent3945); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_user_agentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_user_agentPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_server_val_in_header_user_agent3947);
            	        server_val(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_user_agentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_user_agentPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop48;	/* break out of the loop */
            	    break;
                }
            }
            loop48: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_user_agentEx; /* Prevent compiler warnings */
    ruleheader_user_agentEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_user_agent))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_user_agentPop(ctx);

    return ret;
}
/* $ANTLR end header_user_agent */

/** 
 * $ANTLR start server_val
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1041:1: server_val : word ;
 */
static void
server_val(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_word_return word60;
    #undef	RETURN_TYPE_word60
    #define	RETURN_TYPE_word60 belle_sip_messageParser_word_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1041:15: ( word )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1041:17: word
        {
            FOLLOWPUSH(FOLLOW_word_in_server_val3967);
            word60=word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleserver_valEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_user_agent_add_product(	(SCOPE_TOP(header_user_agent))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, word60.start, word60.stop))->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleserver_valEx; /* Prevent compiler warnings */
    ruleserver_valEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end server_val */

/** 
 * $ANTLR start serval_item
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1042:1: serval_item : ( product | comment );
 */
static void
serval_item(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1043:3: ( product | comment )
            
            ANTLR3_UINT32 alt49;

            alt49=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case STAR:
            case PLUS:
            case HEX_CHAR:
            case COMMON_CHAR:
            case RPAREN:
            case 28:
            case 29:
            case 34:
            case 35:
            case 39:
            case 40:
            case 41:
            case 42:
            	{
            		alt49=1;
            	}
                break;
            case LPAREN:
            	{
            		switch ( LA(2) ) 
            		{
            		case SLASH:
            			{
            				switch ( LA(3) ) 
            				{
            				case DIGIT:
            				case STAR:
            				case PLUS:
            				case HEX_CHAR:
            				case COMMON_CHAR:
            				case LPAREN:
            				case RPAREN:
            				case 28:
            				case 29:
            				case 34:
            				case 35:
            				case 39:
            				case 40:
            				case 41:
            				case 42:
            					{
            						alt49=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 49;
            				    EXCEPTION->state        = 3;


            				    goto ruleserval_itemEx;
            				}

            			}
            		    break;
            		case HEX_CHAR:
            		case COMMON_CHAR:
            			{
            				switch ( LA(3) ) 
            				{
            				case EOF:
            				case DIGIT:
            				case STAR:
            				case SLASH:
            				case PLUS:
            				case LPAREN:
            				case RPAREN:
            				case 28:
            				case 29:
            				case 34:
            				case 35:
            				case 39:
            				case 40:
            				case 41:
            				case 42:
            					{
            						alt49=1;
            					}
            				    break;
            				case HEX_CHAR:
            				case COMMON_CHAR:
            					{
            						alt49=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 49;
            				    EXCEPTION->state        = 4;


            				    goto ruleserval_itemEx;
            				}

            			}
            		    break;
            		case EOF:
            			{
            				alt49=1;
            			}
            		    break;
            		case DIGIT:
            			{
            				switch ( LA(3) ) 
            				{
            				case EOF:
            				case DIGIT:
            				case STAR:
            				case SLASH:
            				case PLUS:
            				case LPAREN:
            				case RPAREN:
            				case 28:
            				case 29:
            				case 34:
            				case 35:
            				case 39:
            				case 40:
            				case 41:
            				case 42:
            					{
            						alt49=1;
            					}
            				    break;
            				case HEX_CHAR:
            				case COMMON_CHAR:
            					{
            						alt49=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 49;
            				    EXCEPTION->state        = 5;


            				    goto ruleserval_itemEx;
            				}

            			}
            		    break;
            		case STAR:
            		case LPAREN:
            		case RPAREN:
            		case 28:
            		case 29:
            		case 39:
            		case 40:
            		case 41:
            		case 42:
            			{
            				switch ( LA(3) ) 
            				{
            				case EOF:
            				case DIGIT:
            				case STAR:
            				case SLASH:
            				case PLUS:
            				case LPAREN:
            				case RPAREN:
            				case 28:
            				case 29:
            				case 34:
            				case 35:
            				case 39:
            				case 40:
            				case 41:
            				case 42:
            					{
            						alt49=1;
            					}
            				    break;
            				case HEX_CHAR:
            				case COMMON_CHAR:
            					{
            						alt49=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 49;
            				    EXCEPTION->state        = 6;


            				    goto ruleserval_itemEx;
            				}

            			}
            		    break;
            		case 34:
            			{
            				switch ( LA(3) ) 
            				{
            				case EOF:
            				case DIGIT:
            				case STAR:
            				case SLASH:
            				case PLUS:
            				case LPAREN:
            				case RPAREN:
            				case 28:
            				case 29:
            				case 34:
            				case 35:
            				case 39:
            				case 40:
            				case 41:
            				case 42:
            					{
            						alt49=1;
            					}
            				    break;
            				case HEX_CHAR:
            				case COMMON_CHAR:
            					{
            						alt49=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 49;
            				    EXCEPTION->state        = 7;


            				    goto ruleserval_itemEx;
            				}

            			}
            		    break;
            		case PLUS:
            			{
            				switch ( LA(3) ) 
            				{
            				case EOF:
            				case DIGIT:
            				case STAR:
            				case SLASH:
            				case PLUS:
            				case LPAREN:
            				case RPAREN:
            				case 28:
            				case 29:
            				case 34:
            				case 35:
            				case 39:
            				case 40:
            				case 41:
            				case 42:
            					{
            						alt49=1;
            					}
            				    break;
            				case HEX_CHAR:
            				case COMMON_CHAR:
            					{
            						alt49=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 49;
            				    EXCEPTION->state        = 8;


            				    goto ruleserval_itemEx;
            				}

            			}
            		    break;
            		case 35:
            			{
            				switch ( LA(3) ) 
            				{
            				case EOF:
            				case DIGIT:
            				case STAR:
            				case SLASH:
            				case PLUS:
            				case LPAREN:
            				case RPAREN:
            				case 28:
            				case 29:
            				case 34:
            				case 35:
            				case 39:
            				case 40:
            				case 41:
            				case 42:
            					{
            						alt49=1;
            					}
            				    break;
            				case HEX_CHAR:
            				case COMMON_CHAR:
            					{
            						alt49=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 49;
            				    EXCEPTION->state        = 9;


            				    goto ruleserval_itemEx;
            				}

            			}
            		    break;
            		case CRLF:
            		case LWS:
            		case DQUOTE:
            		case SEMI:
            		case COMMA:
            		case EQUAL:
            		case COLON:
            		case OCTET:
            		case LAQUOT:
            		case RAQUOT:
            		case HTAB:
            		case SP:
            		case 24:
            		case 25:
            		case 26:
            		case 27:
            		case 30:
            		case 31:
            		case 32:
            		case 33:
            		case 36:
            		case 37:
            		case 38:
            			{
            				alt49=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 49;
            		    EXCEPTION->state        = 2;


            		    goto ruleserval_itemEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 49;
                EXCEPTION->state        = 0;


                goto ruleserval_itemEx;
            }

            switch (alt49) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1043:7: product
        	    {
        	        FOLLOWPUSH(FOLLOW_product_in_serval_item3984);
        	        product(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleserval_itemEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1043:17: comment
        	    {
        	        FOLLOWPUSH(FOLLOW_comment_in_serval_item3988);
        	        comment(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleserval_itemEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleserval_itemEx; /* Prevent compiler warnings */
    ruleserval_itemEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end serval_item */

/** 
 * $ANTLR start product
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1044:1: product : token ( SLASH product_version )? ;
 */
static void
product(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1045:3: ( token ( SLASH product_version )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1045:7: token ( SLASH product_version )?
        {
            FOLLOWPUSH(FOLLOW_token_in_product4011);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproductEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1045:13: ( SLASH product_version )?
            {
                int alt50=2;
                switch ( LA(1) ) 
                {
                    case SLASH:
                    	{
                    		alt50=1;
                    	}
                        break;
                }

                switch (alt50) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1045:14: SLASH product_version
            	    {
            	         MATCHT(SLASH, &FOLLOW_SLASH_in_product4014); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproductEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_product_version_in_product4016);
            	        product_version(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleproductEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproductEx; /* Prevent compiler warnings */
    ruleproductEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end product */

/** 
 * $ANTLR start product_version
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1046:1: product_version : token ;
 */
static void
product_version(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1047:3: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1047:7: token
        {
            FOLLOWPUSH(FOLLOW_token_in_product_version4031);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleproduct_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleproduct_versionEx; /* Prevent compiler warnings */
    ruleproduct_versionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end product_version */

/** 
 * $ANTLR start via_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1049:1: via_token : {...}? token ;
 */
static void
via_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1049:10: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1049:13: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Via,v))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Via,v)";
                    EXCEPTION->ruleName	 = (void *)"via_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_via_token4043);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_tokenEx; /* Prevent compiler warnings */
    rulevia_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end via_token */

/** 
 * $ANTLR start header_via
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1050:1: header_via returns [belle_sip_header_via_t* ret] : via_token hcolon via_parm ( comma via_parm )* ;
 */
static belle_sip_header_via_t*
header_via(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_via_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_viaTop = pbelle_sip_messageParser_header_viaPush(ctx);
     	(SCOPE_TOP(header_via))->current= NULL;ret= NULL;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1054:3: ( via_token hcolon via_parm ( comma via_parm )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1054:7: via_token hcolon via_parm ( comma via_parm )*
        {
            FOLLOWPUSH(FOLLOW_via_token_in_header_via4080);
            via_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_viaEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_viaPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_via4083);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_viaEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_viaPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_via_parm_in_header_via4085);
            via_parm(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_viaEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_viaPop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1054:53: ( comma via_parm )*

            for (;;)
            {
                int alt51=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case COMMA:
                	{
                		alt51=1;
                	}
                    break;

                }

                switch (alt51) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1054:54: comma via_parm
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_header_via4088);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_viaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_viaPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_via_parm_in_header_via4090);
            	        via_parm(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_viaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_viaPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop51;	/* break out of the loop */
            	    break;
                }
            }
            loop51: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_via))->first;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_viaEx; /* Prevent compiler warnings */
    ruleheader_viaEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_header_viaPop(ctx);

    return ret;
}
/* $ANTLR end header_via */

/** 
 * $ANTLR start via_parm
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1056:1: via_parm : sent_protocol LWS sent_by ( semi via_params )* ;
 */
static void
via_parm(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_via_parmTop = pbelle_sip_messageParser_via_parmPush(ctx);
     if (	(SCOPE_TOP(header_via))->current == NULL) {
                	(SCOPE_TOP(header_via))->first= 	(SCOPE_TOP(header_via))->current = belle_sip_header_via_new();
                	(SCOPE_TOP(via_parm))->prev=NULL;
             } else {
    			belle_sip_header_t* header;
                	(SCOPE_TOP(via_parm))->prev=	(SCOPE_TOP(header_via))->current;
                header = BELLE_SIP_HEADER(	(SCOPE_TOP(header_via))->current); 
                belle_sip_header_set_next(header,(belle_sip_header_t*)(	(SCOPE_TOP(header_via))->current= belle_sip_header_via_new()));
             } 
          
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1068:2: ( sent_protocol LWS sent_by ( semi via_params )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1068:6: sent_protocol LWS sent_by ( semi via_params )*
        {
            FOLLOWPUSH(FOLLOW_sent_protocol_in_via_parm4125);
            sent_protocol(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_parmEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_via_parmPop(ctx);

                return ;
            }
             MATCHT(LWS, &FOLLOW_LWS_in_via_parm4128); 
            if  (HASEXCEPTION())
            {
                goto rulevia_parmEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_via_parmPop(ctx);

                return ;
            }
            FOLLOWPUSH(FOLLOW_sent_by_in_via_parm4130);
            sent_by(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_parmEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_via_parmPop(ctx);

                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1068:33: ( semi via_params )*

            for (;;)
            {
                int alt52=2;
                switch ( LA(1) ) 
                {
                case LWS:
                	{
                		switch ( LA(2) ) 
                		{
                		case SEMI:
                			{
                				alt52=1;
                			}
                		    break;

                		}

                	}
                    break;
                case SEMI:
                	{
                		alt52=1;
                	}
                    break;

                }

                switch (alt52) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1068:35: semi via_params
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_via_parm4134);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevia_parmEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_via_parmPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_via_params_in_via_parm4136);
            	        via_params(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevia_parmEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_via_parmPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop52;	/* break out of the loop */
            	    break;
                }
            }
            loop52: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_parmEx; /* Prevent compiler warnings */
    rulevia_parmEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if ( 	(SCOPE_TOP(via_parm))->prev == NULL) {
	          	(SCOPE_TOP(header_via))->first=NULL;
	       } else {
	         belle_sip_header_set_next(BELLE_SIP_HEADER(	(SCOPE_TOP(via_parm))->prev),NULL); 
	       }
	       belle_sip_object_unref(	(SCOPE_TOP(header_via))->current);
	       	(SCOPE_TOP(header_via))->current=	(SCOPE_TOP(via_parm))->prev;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_via_parmPop(ctx);

    return ;
}
/* $ANTLR end via_parm */

/** 
 * $ANTLR start via_params
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1081:1: via_params : ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] );
 */
static void
via_params(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1082:2: ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] )
            
            ANTLR3_UINT32 alt53;

            alt53=2;

            alt53 = cdfa53.predict(ctx, RECOGNIZER, ISTREAM, &cdfa53);
            if  (HASEXCEPTION())
            {
                goto rulevia_paramsEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt53) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1084:41: via_received[$header_via::current]
        	    {
        	        FOLLOWPUSH(FOLLOW_via_received_in_via_params4168);
        	        via_received(ctx, 	(SCOPE_TOP(header_via))->current);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_paramsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1084:78: generic_param[BELLE_SIP_PARAMETERS($header_via::current)]
        	    {
        	        FOLLOWPUSH(FOLLOW_generic_param_in_via_params4173);
        	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_via))->current));

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_paramsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_paramsEx; /* Prevent compiler warnings */
    rulevia_paramsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end via_params */

/** 
 * $ANTLR start via_received
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1089:1: via_received[belle_sip_header_via_t* object] : {...}? token EQUAL via_address ;
 */
static void
via_received(pbelle_sip_messageParser ctx, belle_sip_header_via_t* object)
{   
    belle_sip_messageParser_via_address_return via_address61;
    #undef	RETURN_TYPE_via_address61
    #define	RETURN_TYPE_via_address61 belle_sip_messageParser_via_address_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1090:3: ({...}? token EQUAL via_address )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1090:5: {...}? token EQUAL via_address
        {
            if ( !((IS_TOKEN(received))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(received)";
                    EXCEPTION->ruleName	 = (void *)"via_received";


            }
            FOLLOWPUSH(FOLLOW_token_in_via_received4191);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_receivedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(EQUAL, &FOLLOW_EQUAL_in_via_received4193); 
            if  (HASEXCEPTION())
            {
                goto rulevia_receivedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_via_address_in_via_received4195);
            via_address61=via_address(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_receivedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_via_set_received(object,(const char*)(STRSTREAM->toStringTT(STRSTREAM, via_address61.start, via_address61.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_receivedEx; /* Prevent compiler warnings */
    rulevia_receivedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end via_received */

/** 
 * $ANTLR start via_address
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1092:1: via_address : ( ipv4address | ipv6address );
 */
static belle_sip_messageParser_via_address_return
via_address(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_via_address_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1092:12: ( ipv4address | ipv6address )
            
            ANTLR3_UINT32 alt54;

            alt54=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            	{
            		switch ( LA(2) ) 
            		{
            		case DIGIT:
            			{
            				switch ( LA(3) ) 
            				{
            				case DIGIT:
            					{
            						switch ( LA(4) ) 
            						{
            						case EOF:
            						case LWS:
            						case DIGIT:
            						case SEMI:
            						case COMMA:
            						case COLON:
            						case HEX_CHAR:
            						case 32:
            							{
            								alt54=2;
            							}
            						    break;
            						case 28:
            							{
            								alt54=1;
            							}
            						    break;

            						default:
            						    if (BACKTRACKING>0)
            						    {
            						        FAILEDFLAG = ANTLR3_TRUE;
            						        return retval;
            						    }
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 54;
            						    EXCEPTION->state        = 5;


            						    goto rulevia_addressEx;
            						}

            					}
            				    break;
            				case EOF:
            				case LWS:
            				case SEMI:
            				case COMMA:
            				case COLON:
            				case HEX_CHAR:
            				case 32:
            					{
            						alt54=2;
            					}
            				    break;
            				case 28:
            					{
            						alt54=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return retval;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 54;
            				    EXCEPTION->state        = 3;


            				    goto rulevia_addressEx;
            				}

            			}
            		    break;
            		case EOF:
            		case LWS:
            		case SEMI:
            		case COMMA:
            		case COLON:
            		case HEX_CHAR:
            		case 32:
            			{
            				alt54=2;
            			}
            		    break;
            		case 28:
            			{
            				alt54=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 54;
            		    EXCEPTION->state        = 1;


            		    goto rulevia_addressEx;
            		}

            	}
                break;
            case HEX_CHAR:
            case 32:
            	{
            		alt54=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 54;
                EXCEPTION->state        = 0;


                goto rulevia_addressEx;
            }

            switch (alt54) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1092:14: ipv4address
        	    {
        	        FOLLOWPUSH(FOLLOW_ipv4address_in_via_address4204);
        	        ipv4address(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1092:28: ipv6address
        	    {
        	        FOLLOWPUSH(FOLLOW_ipv6address_in_via_address4208);
        	        ipv6address(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_addressEx; /* Prevent compiler warnings */
    rulevia_addressEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end via_address */

/** 
 * $ANTLR start sent_protocol
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1098:1: sent_protocol : ( protocol_name slash protocol_version ) slash transport ;
 */
static belle_sip_messageParser_sent_protocol_return
sent_protocol(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_sent_protocol_return retval;

    belle_sip_messageParser_transport_return transport62;
    #undef	RETURN_TYPE_transport62
    #define	RETURN_TYPE_transport62 belle_sip_messageParser_transport_return

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1099:2: ( ( protocol_name slash protocol_version ) slash transport )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1099:6: ( protocol_name slash protocol_version ) slash transport
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1099:6: ( protocol_name slash protocol_version )
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1099:7: protocol_name slash protocol_version
            {
                FOLLOWPUSH(FOLLOW_protocol_name_in_sent_protocol4226);
                protocol_name(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesent_protocolEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                FOLLOWPUSH(FOLLOW_slash_in_sent_protocol4228);
                slash(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesent_protocolEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                FOLLOWPUSH(FOLLOW_protocol_version_in_sent_protocol4230);
                protocol_version(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesent_protocolEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

            }

            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_via_set_protocol(	(SCOPE_TOP(header_via))->current,(const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
            }
            FOLLOWPUSH(FOLLOW_slash_in_sent_protocol4256);
            slash(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesent_protocolEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_transport_in_sent_protocol4258);
            transport62=transport(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesent_protocolEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_via_set_transport(	(SCOPE_TOP(header_via))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, transport62.start, transport62.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesent_protocolEx; /* Prevent compiler warnings */
    rulesent_protocolEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end sent_protocol */

/** 
 * $ANTLR start protocol_name
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1101:1: protocol_name : token ;
 */
static void
protocol_name(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1102:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1102:18: token
        {
            FOLLOWPUSH(FOLLOW_token_in_protocol_name4278);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprotocol_nameEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprotocol_nameEx; /* Prevent compiler warnings */
    ruleprotocol_nameEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end protocol_name */

/** 
 * $ANTLR start protocol_version
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1103:1: protocol_version : token ;
 */
static void
protocol_version(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1104:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1104:6: token
        {
            FOLLOWPUSH(FOLLOW_token_in_protocol_version4290);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprotocol_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprotocol_versionEx; /* Prevent compiler warnings */
    ruleprotocol_versionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end protocol_version */

/** 
 * $ANTLR start transport
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1105:1: transport : other_transport ;
 */
static belle_sip_messageParser_transport_return
transport(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_transport_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1106:2: ( other_transport )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1107:27: other_transport
        {
            FOLLOWPUSH(FOLLOW_other_transport_in_transport4310);
            other_transport(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletransportEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletransportEx; /* Prevent compiler warnings */
    ruletransportEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end transport */

/** 
 * $ANTLR start other_transport
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1108:1: other_transport : token ;
 */
static void
other_transport(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1109:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1109:4: token
        {
            FOLLOWPUSH(FOLLOW_token_in_other_transport4318);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_transportEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleother_transportEx; /* Prevent compiler warnings */
    ruleother_transportEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end other_transport */

/** 
 * $ANTLR start sent_by
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1111:1: sent_by : host ( COLON port )? ;
 */
static void
sent_by(pbelle_sip_messageParser ctx)
{   
    const char* host63;
    #undef	RETURN_TYPE_host63
    #define	RETURN_TYPE_host63 const char*

    belle_sip_messageParser_port_return port64;
    #undef	RETURN_TYPE_port64
    #define	RETURN_TYPE_port64 belle_sip_messageParser_port_return

    /* Initialize rule variables
     */


    host63 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1112:2: ( host ( COLON port )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1112:6: host ( COLON port )?
        {
            FOLLOWPUSH(FOLLOW_host_in_sent_by4340);
            host63=host(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesent_byEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_via_set_host(	(SCOPE_TOP(header_via))->current,host63);
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1113:5: ( COLON port )?
            {
                int alt55=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt55=1;
                    	}
                        break;
                }

                switch (alt55) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1113:7: COLON port
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_sent_by4350); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesent_byEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_port_in_sent_by4352);
            	        port64=port(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesent_byEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_header_via_set_port(	(SCOPE_TOP(header_via))->current,port64.ret);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesent_byEx; /* Prevent compiler warnings */
    rulesent_byEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end sent_by */

/** 
 * $ANTLR start header_www_authenticate
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1132:1: header_www_authenticate returns [belle_sip_header_www_authenticate_t* ret] : {...}? token hcolon challenge[$header_www_authenticate::current] ;
 */
static belle_sip_header_www_authenticate_t*
header_www_authenticate(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_www_authenticate_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_www_authenticateTop = pbelle_sip_messageParser_header_www_authenticatePush(ctx);
     	(SCOPE_TOP(header_www_authenticate))->current= belle_sip_header_www_authenticate_new();ret= 	(SCOPE_TOP(header_www_authenticate))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1135:2: ({...}? token hcolon challenge[$header_www_authenticate::current] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1135:6: {...}? token hcolon challenge[$header_www_authenticate::current]
        {
            if ( !((IS_TOKEN(WWW-Authenticate))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_www_authenticatePop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(WWW-Authenticate)";
                    EXCEPTION->ruleName	 = (void *)"header_www_authenticate";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_www_authenticate4391);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_www_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_www_authenticatePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_www_authenticate4395);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_www_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_www_authenticatePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_challenge_in_header_www_authenticate4397);
            challenge(ctx, 	(SCOPE_TOP(header_www_authenticate))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_www_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_www_authenticatePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_www_authenticateEx; /* Prevent compiler warnings */
    ruleheader_www_authenticateEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_www_authenticate))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_www_authenticatePop(ctx);

    return ret;
}
/* $ANTLR end header_www_authenticate */

/** 
 * $ANTLR start state_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1142:1: state_value : token ;
 */
static belle_sip_messageParser_state_value_return
state_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_state_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1142:12: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1142:14: token
        {
            FOLLOWPUSH(FOLLOW_token_in_state_value4410);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestate_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestate_valueEx; /* Prevent compiler warnings */
    rulestate_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end state_value */

/** 
 * $ANTLR start header_subscription_state
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1144:1: header_subscription_state returns [belle_sip_header_subscription_state_t* ret] : {...}? token hcolon state_value ( semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)] )* ;
 */
static belle_sip_header_subscription_state_t*
header_subscription_state(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_subscription_state_t* ret = NULL;

    belle_sip_messageParser_state_value_return state_value65;
    #undef	RETURN_TYPE_state_value65
    #define	RETURN_TYPE_state_value65 belle_sip_messageParser_state_value_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_subscription_stateTop = pbelle_sip_messageParser_header_subscription_statePush(ctx);
     	(SCOPE_TOP(header_subscription_state))->current= belle_sip_header_subscription_state_new();ret= 	(SCOPE_TOP(header_subscription_state))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1147:2: ({...}? token hcolon state_value ( semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)] )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1147:4: {...}? token hcolon state_value ( semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)] )*
        {
            if ( !((IS_TOKEN(Subscription-State))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_subscription_statePop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Subscription-State)";
                    EXCEPTION->ruleName	 = (void *)"header_subscription_state";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_subscription_state4438);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_subscription_stateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_subscription_statePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_subscription_state4444);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_subscription_stateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_subscription_statePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_state_value_in_header_subscription_state4446);
            state_value65=state_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_subscription_stateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_subscription_statePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_subscription_state_set_state(	(SCOPE_TOP(header_subscription_state))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, state_value65.start, state_value65.stop))->chars);
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1149:2: ( semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)] )*

            for (;;)
            {
                int alt56=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case SEMI:
                	{
                		alt56=1;
                	}
                    break;

                }

                switch (alt56) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1149:3: semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_header_subscription_state4453);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_subscription_stateEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_subscription_statePop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_generic_param_in_header_subscription_state4456);
            	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_subscription_state))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_subscription_stateEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_subscription_statePop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop56;	/* break out of the loop */
            	    break;
                }
            }
            loop56: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_subscription_stateEx; /* Prevent compiler warnings */
    ruleheader_subscription_stateEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_subscription_state))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_subscription_statePop(ctx);

    return ret;
}
/* $ANTLR end header_subscription_state */

/** 
 * $ANTLR start header_replaces
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1168:1: header_replaces returns [belle_sip_header_replaces_t* ret] : {...}? token hcolon call_id ( semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)] )* ;
 */
static belle_sip_header_replaces_t*
header_replaces(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_replaces_t* ret = NULL;

    belle_sip_messageParser_call_id_return call_id66;
    #undef	RETURN_TYPE_call_id66
    #define	RETURN_TYPE_call_id66 belle_sip_messageParser_call_id_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_replacesTop = pbelle_sip_messageParser_header_replacesPush(ctx);
     	(SCOPE_TOP(header_replaces))->current= belle_sip_header_replaces_new();ret= 	(SCOPE_TOP(header_replaces))->current; 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1171:2: ({...}? token hcolon call_id ( semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)] )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1171:4: {...}? token hcolon call_id ( semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)] )*
        {
            if ( !((IS_TOKEN(Replaces))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_replacesPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Replaces)";
                    EXCEPTION->ruleName	 = (void *)"header_replaces";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_replaces4500);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_replacesEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_replacesPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_replaces4506);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_replacesEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_replacesPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_call_id_in_header_replaces4508);
            call_id66=call_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_replacesEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_replacesPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_replaces_set_call_id(	(SCOPE_TOP(header_replaces))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, call_id66.start, call_id66.stop))->chars);
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1173:3: ( semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)] )*

            for (;;)
            {
                int alt57=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case SEMI:
                	{
                		alt57=1;
                	}
                    break;

                }

                switch (alt57) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1173:4: semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_header_replaces4516);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_replacesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_replacesPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_generic_param_in_header_replaces4519);
            	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_replaces))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_replacesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_replacesPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop57;	/* break out of the loop */
            	    break;
                }
            }
            loop57: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_replacesEx; /* Prevent compiler warnings */
    ruleheader_replacesEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_replaces))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_replacesPop(ctx);

    return ret;
}
/* $ANTLR end header_replaces */

/** 
 * $ANTLR start header_p_preferred_identity
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1184:1: header_p_preferred_identity returns [belle_sip_header_p_preferred_identity_t* ret] : {...}? token hcolon header_address_base[(belle_sip_header_address_t*)belle_sip_header_p_preferred_identity_new()] ;
 */
static belle_sip_header_p_preferred_identity_t*
header_p_preferred_identity(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_p_preferred_identity_t* ret = NULL;

    belle_sip_header_address_t* header_address_base67;
    #undef	RETURN_TYPE_header_address_base67
    #define	RETURN_TYPE_header_address_base67 belle_sip_header_address_t*

    /* Initialize rule variables
     */


     ret=NULL; 
    header_address_base67 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1186:3: ({...}? token hcolon header_address_base[(belle_sip_header_address_t*)belle_sip_header_p_preferred_identity_new()] )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1186:6: {...}? token hcolon header_address_base[(belle_sip_header_address_t*)belle_sip_header_p_preferred_identity_new()]
        {
            if ( !((IS_TOKEN(P-Preferred-Identity))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(P-Preferred-Identity)";
                    EXCEPTION->ruleName	 = (void *)"header_p_preferred_identity";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_p_preferred_identity4558);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_p_preferred_identityEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_p_preferred_identity4564);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_p_preferred_identityEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_header_address_base_in_header_p_preferred_identity4566);
            header_address_base67=header_address_base(ctx, (belle_sip_header_address_t*)belle_sip_header_p_preferred_identity_new());

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_p_preferred_identityEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=(belle_sip_header_p_preferred_identity_t*)header_address_base67;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_p_preferred_identityEx; /* Prevent compiler warnings */
    ruleheader_p_preferred_identityEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ret;
}
/* $ANTLR end header_p_preferred_identity */

/** 
 * $ANTLR start header_privacy
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1189:1: header_privacy returns [belle_sip_header_privacy_t* ret] : {...}? token hcolon privacy_val ( semi privacy_val )* ;
 */
static belle_sip_header_privacy_t*
header_privacy(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_privacy_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_privacyTop = pbelle_sip_messageParser_header_privacyPush(ctx);
     	(SCOPE_TOP(header_privacy))->current= belle_sip_header_privacy_new();ret= 	(SCOPE_TOP(header_privacy))->current;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1192:3: ({...}? token hcolon privacy_val ( semi privacy_val )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1192:7: {...}? token hcolon privacy_val ( semi privacy_val )*
        {
            if ( !((IS_TOKEN(Privacy))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_privacyPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Privacy)";
                    EXCEPTION->ruleName	 = (void *)"header_privacy";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_privacy4603);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_privacyEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_privacyPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_privacy4607);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_privacyEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_privacyPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_privacy_val_in_header_privacy4609);
            privacy_val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_privacyEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_privacyPop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1192:67: ( semi privacy_val )*

            for (;;)
            {
                int alt58=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case SEMI:
                	{
                		alt58=1;
                	}
                    break;

                }

                switch (alt58) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1192:68: semi privacy_val
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_header_privacy4612);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_privacyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_privacyPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_privacy_val_in_header_privacy4614);
            	        privacy_val(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_privacyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_privacyPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop58;	/* break out of the loop */
            	    break;
                }
            }
            loop58: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_privacyEx; /* Prevent compiler warnings */
    ruleheader_privacyEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_privacyPop(ctx);

    return ret;
}
/* $ANTLR end header_privacy */

/** 
 * $ANTLR start privacy_val
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1199:1: privacy_val : token ;
 */
static void
privacy_val(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_token_return token68;
    #undef	RETURN_TYPE_token68
    #define	RETURN_TYPE_token68 belle_sip_messageParser_token_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1199:12: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1199:14: token
        {
            FOLLOWPUSH(FOLLOW_token_in_privacy_val4629);
            token68=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprivacy_valEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_privacy_add_privacy(	(SCOPE_TOP(header_privacy))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, token68.start, token68.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprivacy_valEx; /* Prevent compiler warnings */
    ruleprivacy_valEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end privacy_val */

/** 
 * $ANTLR start header_extension
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1203:1: header_extension[ANTLR3_BOOLEAN check_for_known_header] returns [belle_sip_header_t* ret] : header_name hcolon header_value ;
 */
static belle_sip_messageParser_header_extension_return
header_extension(pbelle_sip_messageParser ctx, ANTLR3_BOOLEAN check_for_known_header)
{   
    belle_sip_messageParser_header_extension_return retval;

    belle_sip_messageParser_header_name_return header_name69;
    #undef	RETURN_TYPE_header_name69
    #define	RETURN_TYPE_header_name69 belle_sip_messageParser_header_name_return

    belle_sip_messageParser_header_value_return header_value70;
    #undef	RETURN_TYPE_header_value70
    #define	RETURN_TYPE_header_value70 belle_sip_messageParser_header_value_return

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1204:2: ( header_name hcolon header_value )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1204:7: header_name hcolon header_value
        {
            FOLLOWPUSH(FOLLOW_header_name_in_header_extension4651);
            header_name69=header_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_extensionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_extension4660);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_extensionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_header_value_in_header_extension4669);
            header_value70=header_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_extensionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {
                if (check_for_known_header && STRCASECMP_HEADER_NAMED(BELLE_SIP_CONTACT,"m",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars)) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_contact_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && STRCASECMP_HEADER_NAMED(BELLE_SIP_FROM,"f",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars)) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_from_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && STRCASECMP_HEADER_NAMED(BELLE_SIP_TO,"t",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars)) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_to_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && STRCASECMP_HEADER_NAMED(BELLE_SIP_CALL_ID,"i",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars)) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_call_id_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && STRCASECMP_HEADER_NAMED(BELLE_SIP_CONTENT_LENGTH,"l",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars)) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_content_length_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && STRCASECMP_HEADER_NAMED(BELLE_SIP_CONTENT_TYPE,"c",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars)) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_content_type_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("CSeq",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_cseq_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("Route",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_route_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("Record-Route",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_record_route_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && STRCASECMP_HEADER_NAMED(BELLE_SIP_VIA,"v",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars)) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_via_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("Authorization",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_authorization_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("Proxy-Authorization",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_proxy_authorization_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("WWW-Authenticate",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_www_authenticate_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("Proxy-Authenticate",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_proxy_authenticate_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("Max-Forwards",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_max_forwards_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("User-Agent",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_user_agent_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("Expires",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_expires_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp("Allow",(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_allow_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    } else if (check_for_known_header && strcasecmp(BELLE_SIP_SUBSCRIPTION_STATE,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_subscription_state_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    }else if (check_for_known_header && strcasecmp(BELLE_SIP_SERVICE_ROUTE,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_service_route_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    }else if (check_for_known_header && strcasecmp(BELLE_SIP_REFER_TO,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_refer_to_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    }else if (check_for_known_header && strcasecmp(BELLE_SIP_REFERRED_BY,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_referred_by_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    }else if (check_for_known_header && strcasecmp(BELLE_SIP_REPLACES,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_replaces_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    }else if (check_for_known_header && strcasecmp(BELLE_SIP_DATE,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_date_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    }else if (check_for_known_header && strcasecmp(BELLE_SIP_P_PREFERRED_IDENTITY,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_p_preferred_identity_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    }else if (check_for_known_header && strcasecmp(BELLE_SIP_PRIVACY,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars) == 0) {
                                     retval.ret= BELLE_SIP_HEADER(belle_sip_header_privacy_parse((const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars));
                                    }else {
                                      retval.ret=  BELLE_SIP_HEADER(belle_sip_header_extension_new());
                                      belle_sip_header_extension_set_value((belle_sip_header_extension_t*)retval.ret,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_value70.start, header_value70.stop))->chars);
                                      belle_sip_header_set_name(retval.ret,(const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name69.start, header_name69.stop))->chars);
                                     }
                                   
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_extensionEx; /* Prevent compiler warnings */
    ruleheader_extensionEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end header_extension */

/** 
 * $ANTLR start header_name
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1264:1: header_name : token ;
 */
static belle_sip_messageParser_header_name_return
header_name(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_header_name_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1265:2: ( token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1265:6: token
        {
            FOLLOWPUSH(FOLLOW_token_in_header_name4689);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_nameEx; /* Prevent compiler warnings */
    ruleheader_nameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end header_name */

/** 
 * $ANTLR start header_value
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1267:1: header_value : (~ ( CRLF ) )* ;
 */
static belle_sip_messageParser_header_value_return
header_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_header_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1268:2: ( (~ ( CRLF ) )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1268:6: (~ ( CRLF ) )*
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1268:6: (~ ( CRLF ) )*

            for (;;)
            {
                int alt59=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case DIGIT:
                case DQUOTE:
                case STAR:
                case SEMI:
                case COMMA:
                case SLASH:
                case EQUAL:
                case COLON:
                case OCTET:
                case PLUS:
                case HEX_CHAR:
                case COMMON_CHAR:
                case LAQUOT:
                case RAQUOT:
                case LPAREN:
                case RPAREN:
                case HTAB:
                case SP:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                	{
                		alt59=1;
                	}
                    break;

                }

                switch (alt59) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1268:6: ~ ( CRLF )
            	    {
            	        if ( ((LA(1) >= LWS) && (LA(1) <= 42)) )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else 
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_header_value4706;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_header_value4706);    goto ruleheader_valueEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop59;	/* break out of the loop */
            	    break;
                }
            }
            loop59: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_valueEx; /* Prevent compiler warnings */
    ruleheader_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end header_value */

/** 
 * $ANTLR start message_body
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1270:1: message_body options {greedy=false; } : ( OCTET )+ ;
 */
static void
message_body(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1272:2: ( ( OCTET )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1272:6: ( OCTET )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1272:6: ( OCTET )+
            {
                int cnt60=0;

                for (;;)
                {
                    int alt60=2;
            	switch ( LA(1) ) 
            	{
            	case OCTET:
            		{
            			alt60=1;
            		}
            	    break;

            	}

            	switch (alt60) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1272:6: OCTET
            	        {
            	             MATCHT(OCTET, &FOLLOW_OCTET_in_message_body4736); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemessage_bodyEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt60 >= 1 )
            		{
            		    goto loop60;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulemessage_bodyEx;
            	}
            	cnt60++;
                }
                loop60: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_bodyEx; /* Prevent compiler warnings */
    rulemessage_bodyEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end message_body */

/** 
 * $ANTLR start paramless_uri
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1274:1: paramless_uri returns [belle_sip_uri_t* ret] : sip_schema[$paramless_uri::current] ( ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] ) ( headers[$paramless_uri::current] )? ;
 */
static belle_sip_uri_t*
paramless_uri(pbelle_sip_messageParser ctx)
{   
    belle_sip_uri_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_paramless_uriTop = pbelle_sip_messageParser_paramless_uriPush(ctx);
     	(SCOPE_TOP(paramless_uri))->current= belle_sip_uri_new(); 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1277:4: ( sip_schema[$paramless_uri::current] ( ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] ) ( headers[$paramless_uri::current] )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1277:7: sip_schema[$paramless_uri::current] ( ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] ) ( headers[$paramless_uri::current] )?
        {
            FOLLOWPUSH(FOLLOW_sip_schema_in_paramless_uri4767);
            sip_schema(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparamless_uriEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_paramless_uriPop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1277:43: ( ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] )
            {
                int alt61=2;
                alt61 = cdfa61.predict(ctx, RECOGNIZER, ISTREAM, &cdfa61);
                if  (HASEXCEPTION())
                {
                    goto ruleparamless_uriEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_paramless_uriPop(ctx);

                    return ret;
                }
                switch (alt61) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1277:44: ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] )
            	    {
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1277:44: ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] )
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1277:45: userinfo[$paramless_uri::current] hostport[$paramless_uri::current]
            	        {
            	            FOLLOWPUSH(FOLLOW_userinfo_in_paramless_uri4772);
            	            userinfo(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparamless_uriEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_paramless_uriPop(ctx);

            	                return ret;
            	            }
            	            FOLLOWPUSH(FOLLOW_hostport_in_paramless_uri4775);
            	            hostport(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparamless_uriEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_paramless_uriPop(ctx);

            	                return ret;
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1277:116: hostport[$paramless_uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_hostport_in_paramless_uri4781);
            	        hostport(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_paramless_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1278:4: ( headers[$paramless_uri::current] )?
            {
                int alt62=2;
                switch ( LA(1) ) 
                {
                    case 27:
                    	{
                    		alt62=1;
                    	}
                        break;
                }

                switch (alt62) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1278:4: headers[$paramless_uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_headers_in_paramless_uri4790);
            	        headers(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_paramless_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(paramless_uri))->current;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamless_uriEx; /* Prevent compiler warnings */
    ruleparamless_uriEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(paramless_uri))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_paramless_uriPop(ctx);

    return ret;
}
/* $ANTLR end paramless_uri */

/** 
 * $ANTLR start uri
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1286:1: uri returns [belle_sip_uri_t* ret] : sip_schema[$uri::current] ( ( userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] ) ( uri_parameters[$uri::current] )? ( headers[$uri::current] )? ;
 */
static belle_sip_uri_t*
uri(pbelle_sip_messageParser ctx)
{   
    belle_sip_uri_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_uriTop = pbelle_sip_messageParser_uriPush(ctx);
     	(SCOPE_TOP(uri))->current= belle_sip_uri_new(); 
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1289:4: ( sip_schema[$uri::current] ( ( userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] ) ( uri_parameters[$uri::current] )? ( headers[$uri::current] )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1289:7: sip_schema[$uri::current] ( ( userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] ) ( uri_parameters[$uri::current] )? ( headers[$uri::current] )?
        {
            FOLLOWPUSH(FOLLOW_sip_schema_in_uri4831);
            sip_schema(ctx, 	(SCOPE_TOP(uri))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuriEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_uriPop(ctx);

                return ret;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1289:33: ( ( userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] )
            {
                int alt63=2;
                alt63 = cdfa63.predict(ctx, RECOGNIZER, ISTREAM, &cdfa63);
                if  (HASEXCEPTION())
                {
                    goto ruleuriEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_uriPop(ctx);

                    return ret;
                }
                switch (alt63) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1289:34: ( userinfo[$uri::current] hostport[$uri::current] )
            	    {
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1289:34: ( userinfo[$uri::current] hostport[$uri::current] )
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1289:35: userinfo[$uri::current] hostport[$uri::current]
            	        {
            	            FOLLOWPUSH(FOLLOW_userinfo_in_uri4836);
            	            userinfo(ctx, 	(SCOPE_TOP(uri))->current);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuriEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_uriPop(ctx);

            	                return ret;
            	            }
            	            FOLLOWPUSH(FOLLOW_hostport_in_uri4839);
            	            hostport(ctx, 	(SCOPE_TOP(uri))->current);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuriEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_uriPop(ctx);

            	                return ret;
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1289:86: hostport[$uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_hostport_in_uri4845);
            	        hostport(ctx, 	(SCOPE_TOP(uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1290:4: ( uri_parameters[$uri::current] )?
            {
                int alt64=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case SEMI:
                    		    	{
                    		    		alt64=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                    case SEMI:
                    	{
                    		alt64=1;
                    	}
                        break;
                }

                switch (alt64) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1290:4: uri_parameters[$uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_uri_parameters_in_uri4854);
            	        uri_parameters(ctx, 	(SCOPE_TOP(uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1291:4: ( headers[$uri::current] )?
            {
                int alt65=2;
                switch ( LA(1) ) 
                {
                    case 27:
                    	{
                    		alt65=1;
                    	}
                        break;
                }

                switch (alt65) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1291:4: headers[$uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_headers_in_uri4862);
            	        headers(ctx, 	(SCOPE_TOP(uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(uri))->current;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuriEx; /* Prevent compiler warnings */
    ruleuriEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(uri))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_uriPop(ctx);

    return ret;
}
/* $ANTLR end uri */

/** 
 * $ANTLR start sip_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1299:1: sip_token : {...}? token ;
 */
static void
sip_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1299:10: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1299:13: {...}? token
        {
            if ( !((IS_TOKEN(sip))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(sip)";
                    EXCEPTION->ruleName	 = (void *)"sip_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_sip_token4883);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesip_tokenEx; /* Prevent compiler warnings */
    rulesip_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end sip_token */

/** 
 * $ANTLR start sips_token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1300:1: sips_token : {...}? token ;
 */
static void
sips_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1300:11: ({...}? token )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1300:14: {...}? token
        {
            if ( !((IS_TOKEN(sips))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(sips)";
                    EXCEPTION->ruleName	 = (void *)"sips_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_sips_token4892);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesips_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesips_tokenEx; /* Prevent compiler warnings */
    rulesips_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end sips_token */

/** 
 * $ANTLR start sip_schema
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1302:1: sip_schema[belle_sip_uri_t* uri] : ( sips_token | sip_token ) COLON ;
 */
static void
sip_schema(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1302:35: ( ( sips_token | sip_token ) COLON )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1302:37: ( sips_token | sip_token ) COLON
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1302:37: ( sips_token | sip_token )
            {
                int alt66=2;
                switch ( LA(1) ) 
                {
                case HEX_CHAR:
                case COMMON_CHAR:
                	{

                		{
                		    int LA66_1 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt66=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt66=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 66;
                		        EXCEPTION->state        = 1;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case DIGIT:
                	{

                		{
                		    int LA66_2 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt66=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt66=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 66;
                		        EXCEPTION->state        = 2;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case STAR:
                case LPAREN:
                case RPAREN:
                case 28:
                case 29:
                case 39:
                case 40:
                case 41:
                case 42:
                	{

                		{
                		    int LA66_3 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt66=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt66=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 66;
                		        EXCEPTION->state        = 3;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case 34:
                	{

                		{
                		    int LA66_4 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt66=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt66=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 66;
                		        EXCEPTION->state        = 4;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case PLUS:
                	{

                		{
                		    int LA66_5 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt66=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt66=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 66;
                		        EXCEPTION->state        = 5;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case 35:
                	{

                		{
                		    int LA66_6 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt66=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt66=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 66;
                		        EXCEPTION->state        = 6;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 66;
                    EXCEPTION->state        = 0;


                    goto rulesip_schemaEx;
                }

                switch (alt66) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1302:38: sips_token
            	    {
            	        FOLLOWPUSH(FOLLOW_sips_token_in_sip_schema4903);
            	        sips_token(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesip_schemaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_uri_set_secure(uri,1);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1303:15: sip_token
            	    {
            	        FOLLOWPUSH(FOLLOW_sip_token_in_sip_schema4921);
            	        sip_token(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesip_schemaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(COLON, &FOLLOW_COLON_in_sip_schema4924); 
            if  (HASEXCEPTION())
            {
                goto rulesip_schemaEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesip_schemaEx; /* Prevent compiler warnings */
    rulesip_schemaEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end sip_schema */

/** 
 * $ANTLR start userinfo
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1304:1: userinfo[belle_sip_uri_t* uri] : user ( COLON password )? '@' ;
 */
static void
userinfo(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_userinfoTop = pbelle_sip_messageParser_userinfoPush(ctx);
    	(SCOPE_TOP(userinfo))->current=uri;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1307:8: ( user ( COLON password )? '@' )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1307:10: user ( COLON password )? '@'
        {
            FOLLOWPUSH(FOLLOW_user_in_userinfo4950);
            user(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuserinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_userinfoPop(ctx);

                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1307:15: ( COLON password )?
            {
                int alt67=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt67=1;
                    	}
                        break;
                }

                switch (alt67) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1307:17: COLON password
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_userinfo4954); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserinfoEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_userinfoPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_password_in_userinfo4956);
            	        password(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserinfoEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_userinfoPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(24, &FOLLOW_24_in_userinfo4961); 
            if  (HASEXCEPTION())
            {
                goto ruleuserinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_userinfoPop(ctx);

                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuserinfoEx; /* Prevent compiler warnings */
    ruleuserinfoEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_userinfoPop(ctx);

    return ;
}
/* $ANTLR end userinfo */

/** 
 * $ANTLR start user
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1308:1: user : ( unreserved | escaped | user_unreserved )+ ;
 */
static belle_sip_messageParser_user_return
user(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_user_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1308:17: ( ( unreserved | escaped | user_unreserved )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1308:21: ( unreserved | escaped | user_unreserved )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1308:21: ( unreserved | escaped | user_unreserved )+
            {
                int cnt68=0;

                for (;;)
                {
                    int alt68=4;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case STAR:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case LPAREN:
            	case RPAREN:
            	case 28:
            	case 29:
            	case 39:
            	case 40:
            	case 41:
            	case 42:
            		{
            			alt68=1;
            		}
            	    break;
            	case 34:
            		{
            			alt68=2;
            		}
            	    break;
            	case SEMI:
            	case COMMA:
            	case SLASH:
            	case EQUAL:
            	case PLUS:
            	case 25:
            	case 26:
            	case 27:
            		{
            			alt68=3;
            		}
            	    break;

            	}

            	switch (alt68) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1308:23: unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_unreserved_in_user4984);
            	            unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuserEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1308:37: escaped
            	        {
            	            FOLLOWPUSH(FOLLOW_escaped_in_user4989);
            	            escaped(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuserEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1308:47: user_unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_user_unreserved_in_user4993);
            	            user_unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuserEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt68 >= 1 )
            		{
            		    goto loop68;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleuserEx;
            	}
            	cnt68++;
                }
                loop68: ;	/* Jump to here if this rule does not match */
            }
            if ( BACKTRACKING==0 ) 
            {

                                                                                  char* unescaped_username;
                                                                                  unescaped_username=belle_sip_to_unescaped_string((const char *)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
                                                                                  belle_sip_uri_set_user(	(SCOPE_TOP(userinfo))->current,unescaped_username);
                                                                                  belle_sip_free(unescaped_username);
                                                                                  
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuserEx; /* Prevent compiler warnings */
    ruleuserEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end user */

/** 
 * $ANTLR start user_unreserved
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1314:1: user_unreserved : ( '&' | EQUAL | '+' | '$' | COMMA | SEMI | '?' | SLASH );
 */
static void
user_unreserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1314:17: ( '&' | EQUAL | '+' | '$' | COMMA | SEMI | '?' | SLASH )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:
        {
            if ( ((LA(1) >= SEMI) && (LA(1) <= EQUAL)) || LA(1) == PLUS || ((LA(1) >= 25) && (LA(1) <= 27)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_user_unreserved0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_user_unreserved0);    goto ruleuser_unreservedEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuser_unreservedEx; /* Prevent compiler warnings */
    ruleuser_unreservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end user_unreserved */

/** 
 * $ANTLR start password
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:1: password : ( unreserved | '&' | EQUAL | '+' | '$' | COMMA )* ;
 */
static void
password(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:17: ( ( unreserved | '&' | EQUAL | '+' | '$' | COMMA )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:21: ( unreserved | '&' | EQUAL | '+' | '$' | COMMA )*
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:21: ( unreserved | '&' | EQUAL | '+' | '$' | COMMA )*

            for (;;)
            {
                int alt69=7;
                switch ( LA(1) ) 
                {
                case DIGIT:
                case STAR:
                case HEX_CHAR:
                case COMMON_CHAR:
                case LPAREN:
                case RPAREN:
                case 28:
                case 29:
                case 39:
                case 40:
                case 41:
                case 42:
                	{
                		alt69=1;
                	}
                    break;
                case 25:
                	{
                		alt69=2;
                	}
                    break;
                case EQUAL:
                	{
                		alt69=3;
                	}
                    break;
                case PLUS:
                	{
                		alt69=4;
                	}
                    break;
                case 26:
                	{
                		alt69=5;
                	}
                    break;
                case COMMA:
                	{
                		alt69=6;
                	}
                    break;

                }

                switch (alt69) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:23: unreserved
            	    {
            	        FOLLOWPUSH(FOLLOW_unreserved_in_password5052);
            	        unreserved(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:36: '&'
            	    {
            	         MATCHT(25, &FOLLOW_25_in_password5056); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 3:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:42: EQUAL
            	    {
            	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_password5060); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 4:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:50: '+'
            	    {
            	         MATCHT(PLUS, &FOLLOW_PLUS_in_password5064); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 5:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:56: '$'
            	    {
            	         MATCHT(26, &FOLLOW_26_in_password5068); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 6:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1315:62: COMMA
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_password5072); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop69;	/* break out of the loop */
            	    break;
                }
            }
            loop69: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepasswordEx; /* Prevent compiler warnings */
    rulepasswordEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end password */

/** 
 * $ANTLR start hostport
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1316:1: hostport[belle_sip_uri_t* uri] : host ( COLON port )? ;
 */
static void
hostport(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    belle_sip_messageParser_port_return port71;
    #undef	RETURN_TYPE_port71
    #define	RETURN_TYPE_port71 belle_sip_messageParser_port_return

    const char* host72;
    #undef	RETURN_TYPE_host72
    #define	RETURN_TYPE_host72 const char*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_hostportTop = pbelle_sip_messageParser_hostportPush(ctx);
    	(SCOPE_TOP(hostport))->current=uri;
    host72 = NULL;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1319:9: ( host ( COLON port )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1319:13: host ( COLON port )?
        {
            FOLLOWPUSH(FOLLOW_host_in_hostport5103);
            host72=host(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehostportEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_hostportPop(ctx);

                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1319:18: ( COLON port )?
            {
                int alt70=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt70=1;
                    	}
                        break;
                }

                switch (alt70) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1319:20: COLON port
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_hostport5107); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostportEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostportPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_port_in_hostport5109);
            	        port71=port(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostportEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostportPop(ctx);

            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_uri_set_port(	(SCOPE_TOP(hostport))->current,port71.ret);
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_uri_set_host(	(SCOPE_TOP(hostport))->current,host72);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehostportEx; /* Prevent compiler warnings */
    rulehostportEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_hostportPop(ctx);

    return ;
}
/* $ANTLR end hostport */

/** 
 * $ANTLR start host
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1320:1: host returns [const char* ret] : ( hostname | ipv4address | ipv6reference ) ;
 */
static const char*
host(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_hostname_return hostname73;
    #undef	RETURN_TYPE_hostname73
    #define	RETURN_TYPE_hostname73 belle_sip_messageParser_hostname_return

    belle_sip_messageParser_ipv4address_return ipv4address74;
    #undef	RETURN_TYPE_ipv4address74
    #define	RETURN_TYPE_ipv4address74 belle_sip_messageParser_ipv4address_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_hostTop = pbelle_sip_messageParser_hostPush(ctx);
    	(SCOPE_TOP(host))->current=NULL;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1323:13: ( ( hostname | ipv4address | ipv6reference ) )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1323:17: ( hostname | ipv4address | ipv6reference )
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1323:17: ( hostname | ipv4address | ipv6reference )
            {
                int alt71=3;
                switch ( LA(1) ) 
                {
                case HEX_CHAR:
                case COMMON_CHAR:
                	{
                		alt71=1;
                	}
                    break;
                case DIGIT:
                	{
                		switch ( LA(2) ) 
                		{
                		case DIGIT:
                			{
                				switch ( LA(3) ) 
                				{
                				case DIGIT:
                					{
                						switch ( LA(4) ) 
                						{
                						case 28:
                							{
                								switch ( LA(5) ) 
                								{
                								case HEX_CHAR:
                								case COMMON_CHAR:
                									{
                										alt71=1;
                									}
                								    break;
                								case DIGIT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case 28:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case 28:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																											{
                																												switch ( LA(15) ) 
                																												{
                																												case DIGIT:
                																													{
                																														switch ( LA(16) ) 
                																														{
                																														case DIGIT:
                																														case HEX_CHAR:
                																														case COMMON_CHAR:
                																														case 28:
                																														case 29:
                																															{
                																																alt71=1;
                																															}
                																														    break;
                																														case EOF:
                																														case LWS:
                																														case DQUOTE:
                																														case SEMI:
                																														case COMMA:
                																														case COLON:
                																														case RAQUOT:
                																														case 27:
                																															{
                																																alt71=2;
                																															}
                																														    break;

                																														default:
                																														    if (BACKTRACKING>0)
                																														    {
                																														        FAILEDFLAG = ANTLR3_TRUE;
                																														        pbelle_sip_messageParser_hostPop(ctx);

                																														        return ret;
                																														    }
                																														    CONSTRUCTEX();
                																														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																														    EXCEPTION->message      = (void *)"";
                																														    EXCEPTION->decisionNum  = 71;
                																														    EXCEPTION->state        = 18;


                																														    goto rulehostEx;
                																														}

                																													}
                																												    break;
                																												case HEX_CHAR:
                																												case COMMON_CHAR:
                																												case 28:
                																												case 29:
                																													{
                																														alt71=1;
                																													}
                																												    break;
                																												case EOF:
                																												case LWS:
                																												case DQUOTE:
                																												case SEMI:
                																												case COMMA:
                																												case COLON:
                																												case RAQUOT:
                																												case 27:
                																													{
                																														alt71=2;
                																													}
                																												    break;

                																												default:
                																												    if (BACKTRACKING>0)
                																												    {
                																												        FAILEDFLAG = ANTLR3_TRUE;
                																												        pbelle_sip_messageParser_hostPop(ctx);

                																												        return ret;
                																												    }
                																												    CONSTRUCTEX();
                																												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																												    EXCEPTION->message      = (void *)"";
                																												    EXCEPTION->decisionNum  = 71;
                																												    EXCEPTION->state        = 16;


                																												    goto rulehostEx;
                																												}

                																											}
                																										    break;
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 15;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt71=1;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 13;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case DIGIT:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 14;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case 28:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																											{
                																												switch ( LA(15) ) 
                																												{
                																												case DIGIT:
                																												case HEX_CHAR:
                																												case COMMON_CHAR:
                																												case 28:
                																												case 29:
                																													{
                																														alt71=1;
                																													}
                																												    break;
                																												case EOF:
                																												case LWS:
                																												case DQUOTE:
                																												case SEMI:
                																												case COMMA:
                																												case COLON:
                																												case RAQUOT:
                																												case 27:
                																													{
                																														alt71=2;
                																													}
                																												    break;

                																												default:
                																												    if (BACKTRACKING>0)
                																												    {
                																												        FAILEDFLAG = ANTLR3_TRUE;
                																												        pbelle_sip_messageParser_hostPop(ctx);

                																												        return ret;
                																												    }
                																												    CONSTRUCTEX();
                																												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																												    EXCEPTION->message      = (void *)"";
                																												    EXCEPTION->decisionNum  = 71;
                																												    EXCEPTION->state        = 18;


                																												    goto rulehostEx;
                																												}

                																											}
                																										    break;
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 16;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 15;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt71=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 13;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 12;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case 28:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 11;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 9;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DIGIT:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                														case 29:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 10;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case 28:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case 28:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																											{
                																												switch ( LA(15) ) 
                																												{
                																												case DIGIT:
                																												case HEX_CHAR:
                																												case COMMON_CHAR:
                																												case 28:
                																												case 29:
                																													{
                																														alt71=1;
                																													}
                																												    break;
                																												case EOF:
                																												case LWS:
                																												case DQUOTE:
                																												case SEMI:
                																												case COMMA:
                																												case COLON:
                																												case RAQUOT:
                																												case 27:
                																													{
                																														alt71=2;
                																													}
                																												    break;

                																												default:
                																												    if (BACKTRACKING>0)
                																												    {
                																												        FAILEDFLAG = ANTLR3_TRUE;
                																												        pbelle_sip_messageParser_hostPop(ctx);

                																												        return ret;
                																												    }
                																												    CONSTRUCTEX();
                																												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																												    EXCEPTION->message      = (void *)"";
                																												    EXCEPTION->decisionNum  = 71;
                																												    EXCEPTION->state        = 18;


                																												    goto rulehostEx;
                																												}

                																											}
                																										    break;
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 16;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 15;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt71=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 13;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DIGIT:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 14;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case 28:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 12;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case 28:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 11;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 9;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                												case 29:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 8;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case 28:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case 28:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DIGIT:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 14;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case 28:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 12;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case 28:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                														case 29:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 11;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 9;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case HEX_CHAR:
                										case COMMON_CHAR:
                										case 29:
                											{
                												alt71=1;
                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 71;
                										    EXCEPTION->state        = 7;


                										    goto rulehostEx;
                										}

                									}
                								    break;

                								default:
                								    if (BACKTRACKING>0)
                								    {
                								        FAILEDFLAG = ANTLR3_TRUE;
                								        pbelle_sip_messageParser_hostPop(ctx);

                								        return ret;
                								    }
                								    CONSTRUCTEX();
                								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                								    EXCEPTION->message      = (void *)"";
                								    EXCEPTION->decisionNum  = 71;
                								    EXCEPTION->state        = 5;


                								    goto rulehostEx;
                								}

                							}
                						    break;
                						case DIGIT:
                						case HEX_CHAR:
                						case COMMON_CHAR:
                						case 29:
                							{
                								alt71=1;
                							}
                						    break;

                						default:
                						    if (BACKTRACKING>0)
                						    {
                						        FAILEDFLAG = ANTLR3_TRUE;
                						        pbelle_sip_messageParser_hostPop(ctx);

                						        return ret;
                						    }
                						    CONSTRUCTEX();
                						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                						    EXCEPTION->message      = (void *)"";
                						    EXCEPTION->decisionNum  = 71;
                						    EXCEPTION->state        = 6;


                						    goto rulehostEx;
                						}

                					}
                				    break;
                				case 28:
                					{
                						switch ( LA(4) ) 
                						{
                						case HEX_CHAR:
                						case COMMON_CHAR:
                							{
                								alt71=1;
                							}
                						    break;
                						case DIGIT:
                							{
                								switch ( LA(5) ) 
                								{
                								case DIGIT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case 28:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case 28:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																											{
                																												switch ( LA(15) ) 
                																												{
                																												case DIGIT:
                																												case HEX_CHAR:
                																												case COMMON_CHAR:
                																												case 28:
                																												case 29:
                																													{
                																														alt71=1;
                																													}
                																												    break;
                																												case EOF:
                																												case LWS:
                																												case DQUOTE:
                																												case SEMI:
                																												case COMMA:
                																												case COLON:
                																												case RAQUOT:
                																												case 27:
                																													{
                																														alt71=2;
                																													}
                																												    break;

                																												default:
                																												    if (BACKTRACKING>0)
                																												    {
                																												        FAILEDFLAG = ANTLR3_TRUE;
                																												        pbelle_sip_messageParser_hostPop(ctx);

                																												        return ret;
                																												    }
                																												    CONSTRUCTEX();
                																												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																												    EXCEPTION->message      = (void *)"";
                																												    EXCEPTION->decisionNum  = 71;
                																												    EXCEPTION->state        = 18;


                																												    goto rulehostEx;
                																												}

                																											}
                																										    break;
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 16;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 15;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt71=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 13;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DIGIT:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 14;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case 28:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 12;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case 28:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 11;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 9;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case DIGIT:
                												case HEX_CHAR:
                												case COMMON_CHAR:
                												case 29:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 10;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case 28:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case 28:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DIGIT:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 14;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case 28:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 12;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case 28:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                														case 29:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 11;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 9;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case HEX_CHAR:
                										case COMMON_CHAR:
                										case 29:
                											{
                												alt71=1;
                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 71;
                										    EXCEPTION->state        = 8;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case 28:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case 28:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DIGIT:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 14;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case 28:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                														case 29:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 12;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case 28:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 18;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 16;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 28:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;
                																case EOF:
                																case LWS:
                																case DQUOTE:
                																case SEMI:
                																case COMMA:
                																case COLON:
                																case RAQUOT:
                																case 27:
                																	{
                																		alt71=2;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 15;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 13;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                												case 29:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 11;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case HEX_CHAR:
                										case COMMON_CHAR:
                											{
                												alt71=1;
                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 71;
                										    EXCEPTION->state        = 9;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case HEX_CHAR:
                								case COMMON_CHAR:
                								case 29:
                									{
                										alt71=1;
                									}
                								    break;

                								default:
                								    if (BACKTRACKING>0)
                								    {
                								        FAILEDFLAG = ANTLR3_TRUE;
                								        pbelle_sip_messageParser_hostPop(ctx);

                								        return ret;
                								    }
                								    CONSTRUCTEX();
                								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                								    EXCEPTION->message      = (void *)"";
                								    EXCEPTION->decisionNum  = 71;
                								    EXCEPTION->state        = 7;


                								    goto rulehostEx;
                								}

                							}
                						    break;

                						default:
                						    if (BACKTRACKING>0)
                						    {
                						        FAILEDFLAG = ANTLR3_TRUE;
                						        pbelle_sip_messageParser_hostPop(ctx);

                						        return ret;
                						    }
                						    CONSTRUCTEX();
                						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                						    EXCEPTION->message      = (void *)"";
                						    EXCEPTION->decisionNum  = 71;
                						    EXCEPTION->state        = 5;


                						    goto rulehostEx;
                						}

                					}
                				    break;
                				case HEX_CHAR:
                				case COMMON_CHAR:
                				case 29:
                					{
                						alt71=1;
                					}
                				    break;

                				default:
                				    if (BACKTRACKING>0)
                				    {
                				        FAILEDFLAG = ANTLR3_TRUE;
                				        pbelle_sip_messageParser_hostPop(ctx);

                				        return ret;
                				    }
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 71;
                				    EXCEPTION->state        = 4;


                				    goto rulehostEx;
                				}

                			}
                		    break;
                		case 28:
                			{
                				switch ( LA(3) ) 
                				{
                				case HEX_CHAR:
                				case COMMON_CHAR:
                					{
                						alt71=1;
                					}
                				    break;
                				case DIGIT:
                					{
                						switch ( LA(4) ) 
                						{
                						case DIGIT:
                							{
                								switch ( LA(5) ) 
                								{
                								case DIGIT:
                									{
                										switch ( LA(6) ) 
                										{
                										case 28:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case 28:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																										case 28:
                																										case 29:
                																											{
                																												alt71=1;
                																											}
                																										    break;
                																										case EOF:
                																										case LWS:
                																										case DQUOTE:
                																										case SEMI:
                																										case COMMA:
                																										case COLON:
                																										case RAQUOT:
                																										case 27:
                																											{
                																												alt71=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 71;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt71=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DIGIT:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 14;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case 28:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 12;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case 28:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                														case 29:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 11;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 9;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case DIGIT:
                										case HEX_CHAR:
                										case COMMON_CHAR:
                										case 29:
                											{
                												alt71=1;
                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 71;
                										    EXCEPTION->state        = 10;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case 28:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case 28:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																								case 28:
                																								case 29:
                																									{
                																										alt71=1;
                																									}
                																								    break;
                																								case EOF:
                																								case LWS:
                																								case DQUOTE:
                																								case SEMI:
                																								case COMMA:
                																								case COLON:
                																								case RAQUOT:
                																								case 27:
                																									{
                																										alt71=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 71;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt71=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DIGIT:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 14;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case 28:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                														case 29:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 12;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case 28:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 18;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 16;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 28:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;
                																case EOF:
                																case LWS:
                																case DQUOTE:
                																case SEMI:
                																case COMMA:
                																case COLON:
                																case RAQUOT:
                																case 27:
                																	{
                																		alt71=2;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 15;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 13;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                												case 29:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 11;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case HEX_CHAR:
                										case COMMON_CHAR:
                											{
                												alt71=1;
                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 71;
                										    EXCEPTION->state        = 9;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case HEX_CHAR:
                								case COMMON_CHAR:
                								case 29:
                									{
                										alt71=1;
                									}
                								    break;

                								default:
                								    if (BACKTRACKING>0)
                								    {
                								        FAILEDFLAG = ANTLR3_TRUE;
                								        pbelle_sip_messageParser_hostPop(ctx);

                								        return ret;
                								    }
                								    CONSTRUCTEX();
                								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                								    EXCEPTION->message      = (void *)"";
                								    EXCEPTION->decisionNum  = 71;
                								    EXCEPTION->state        = 8;


                								    goto rulehostEx;
                								}

                							}
                						    break;
                						case 28:
                							{
                								switch ( LA(5) ) 
                								{
                								case DIGIT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case 28:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																						case 28:
                																						case 29:
                																							{
                																								alt71=1;
                																							}
                																						    break;
                																						case EOF:
                																						case LWS:
                																						case DQUOTE:
                																						case SEMI:
                																						case COMMA:
                																						case COLON:
                																						case RAQUOT:
                																						case 27:
                																							{
                																								alt71=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 71;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt71=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DIGIT:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                														case 29:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 14;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case 28:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																				case 28:
                																				case 29:
                																					{
                																						alt71=1;
                																					}
                																				    break;
                																				case EOF:
                																				case LWS:
                																				case DQUOTE:
                																				case SEMI:
                																				case COMMA:
                																				case COLON:
                																				case RAQUOT:
                																				case 27:
                																					{
                																						alt71=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 71;
                																				    EXCEPTION->state        = 18;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 16;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 28:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;
                																case EOF:
                																case LWS:
                																case DQUOTE:
                																case SEMI:
                																case COMMA:
                																case COLON:
                																case RAQUOT:
                																case 27:
                																	{
                																		alt71=2;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 15;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt71=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 13;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                												case 29:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 12;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case 28:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																		case 28:
                																		case 29:
                																			{
                																				alt71=1;
                																			}
                																		    break;
                																		case EOF:
                																		case LWS:
                																		case DQUOTE:
                																		case SEMI:
                																		case COMMA:
                																		case COLON:
                																		case RAQUOT:
                																		case 27:
                																			{
                																				alt71=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 71;
                																		    EXCEPTION->state        = 18;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																case 28:
                																case 29:
                																	{
                																		alt71=1;
                																	}
                																    break;
                																case EOF:
                																case LWS:
                																case DQUOTE:
                																case SEMI:
                																case COMMA:
                																case COLON:
                																case RAQUOT:
                																case 27:
                																	{
                																		alt71=2;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 71;
                																    EXCEPTION->state        = 16;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                														case 28:
                														case 29:
                															{
                																alt71=1;
                															}
                														    break;
                														case EOF:
                														case LWS:
                														case DQUOTE:
                														case SEMI:
                														case COMMA:
                														case COLON:
                														case RAQUOT:
                														case 27:
                															{
                																alt71=2;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 71;
                														    EXCEPTION->state        = 15;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt71=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 71;
                												    EXCEPTION->state        = 13;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case HEX_CHAR:
                										case COMMON_CHAR:
                										case 29:
                											{
                												alt71=1;
                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 71;
                										    EXCEPTION->state        = 11;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case HEX_CHAR:
                								case COMMON_CHAR:
                									{
                										alt71=1;
                									}
                								    break;

                								default:
                								    if (BACKTRACKING>0)
                								    {
                								        FAILEDFLAG = ANTLR3_TRUE;
                								        pbelle_sip_messageParser_hostPop(ctx);

                								        return ret;
                								    }
                								    CONSTRUCTEX();
                								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                								    EXCEPTION->message      = (void *)"";
                								    EXCEPTION->decisionNum  = 71;
                								    EXCEPTION->state        = 9;


                								    goto rulehostEx;
                								}

                							}
                						    break;
                						case HEX_CHAR:
                						case COMMON_CHAR:
                						case 29:
                							{
                								alt71=1;
                							}
                						    break;

                						default:
                						    if (BACKTRACKING>0)
                						    {
                						        FAILEDFLAG = ANTLR3_TRUE;
                						        pbelle_sip_messageParser_hostPop(ctx);

                						        return ret;
                						    }
                						    CONSTRUCTEX();
                						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                						    EXCEPTION->message      = (void *)"";
                						    EXCEPTION->decisionNum  = 71;
                						    EXCEPTION->state        = 7;


                						    goto rulehostEx;
                						}

                					}
                				    break;

                				default:
                				    if (BACKTRACKING>0)
                				    {
                				        FAILEDFLAG = ANTLR3_TRUE;
                				        pbelle_sip_messageParser_hostPop(ctx);

                				        return ret;
                				    }
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 71;
                				    EXCEPTION->state        = 5;


                				    goto rulehostEx;
                				}

                			}
                		    break;
                		case HEX_CHAR:
                		case COMMON_CHAR:
                		case 29:
                			{
                				alt71=1;
                			}
                		    break;

                		default:
                		    if (BACKTRACKING>0)
                		    {
                		        FAILEDFLAG = ANTLR3_TRUE;
                		        pbelle_sip_messageParser_hostPop(ctx);

                		        return ret;
                		    }
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 71;
                		    EXCEPTION->state        = 2;


                		    goto rulehostEx;
                		}

                	}
                    break;
                case 30:
                	{
                		alt71=3;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        pbelle_sip_messageParser_hostPop(ctx);

                        return ret;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 71;
                    EXCEPTION->state        = 0;


                    goto rulehostEx;
                }

                switch (alt71) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1323:18: hostname
            	    {
            	        FOLLOWPUSH(FOLLOW_hostname_in_host5150);
            	        hostname73=hostname(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            	(SCOPE_TOP(host))->current=(const char *)(STRSTREAM->toStringTT(STRSTREAM, hostname73.start, hostname73.stop))->chars;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1324:23: ipv4address
            	    {
            	        FOLLOWPUSH(FOLLOW_ipv4address_in_host5176);
            	        ipv4address74=ipv4address(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            	(SCOPE_TOP(host))->current=(const char *)(STRSTREAM->toStringTT(STRSTREAM, ipv4address74.start, ipv4address74.stop))->chars;
            	        }

            	    }
            	    break;
            	case 3:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1325:23: ipv6reference
            	    {
            	        FOLLOWPUSH(FOLLOW_ipv6reference_in_host5202);
            	        ipv6reference(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=	(SCOPE_TOP(host))->current;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehostEx; /* Prevent compiler warnings */
    rulehostEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_hostPop(ctx);

    return ret;
}
/* $ANTLR end host */

/** 
 * $ANTLR start hostname
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1326:1: hostname : ( domainlabel '.' )* toplabel ( '.' )? ;
 */
static belle_sip_messageParser_hostname_return
hostname(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_hostname_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1326:17: ( ( domainlabel '.' )* toplabel ( '.' )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1326:21: ( domainlabel '.' )* toplabel ( '.' )?
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1326:21: ( domainlabel '.' )*

            for (;;)
            {
                int alt72=2;
                alt72 = cdfa72.predict(ctx, RECOGNIZER, ISTREAM, &cdfa72);
                if  (HASEXCEPTION())
                {
                    goto rulehostnameEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                switch (alt72) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1326:23: domainlabel '.'
            	    {
            	        FOLLOWPUSH(FOLLOW_domainlabel_in_hostname5224);
            	        domainlabel(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostnameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	         MATCHT(28, &FOLLOW_28_in_hostname5226); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostnameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop72;	/* break out of the loop */
            	    break;
                }
            }
            loop72: ; /* Jump out to here if this rule does not match */

            FOLLOWPUSH(FOLLOW_toplabel_in_hostname5231);
            toplabel(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehostnameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1326:51: ( '.' )?
            {
                int alt73=2;
                switch ( LA(1) ) 
                {
                    case 28:
                    	{
                    		alt73=1;
                    	}
                        break;
                }

                switch (alt73) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1326:51: '.'
            	    {
            	         MATCHT(28, &FOLLOW_28_in_hostname5233); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostnameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehostnameEx; /* Prevent compiler warnings */
    rulehostnameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end hostname */

/** 
 * $ANTLR start domainlabel
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:1: domainlabel : ( alphanum | ( alphanum ( alphanum | '-' )* alphanum ) );
 */
static void
domainlabel(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:17: ( alphanum | ( alphanum ( alphanum | '-' )* alphanum ) )
            
            ANTLR3_UINT32 alt75;

            alt75=2;

            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		switch ( LA(2) ) 
            		{
            		case 28:
            			{
            				alt75=1;
            			}
            		    break;
            		case DIGIT:
            		case HEX_CHAR:
            		case COMMON_CHAR:
            		case 29:
            			{
            				alt75=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 75;
            		    EXCEPTION->state        = 1;


            		    goto ruledomainlabelEx;
            		}

            	}
                break;
            case DIGIT:
            	{
            		switch ( LA(2) ) 
            		{
            		case DIGIT:
            		case HEX_CHAR:
            		case COMMON_CHAR:
            		case 29:
            			{
            				alt75=2;
            			}
            		    break;
            		case 28:
            			{
            				alt75=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 75;
            		    EXCEPTION->state        = 2;


            		    goto ruledomainlabelEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 75;
                EXCEPTION->state        = 0;


                goto ruledomainlabelEx;
            }

            switch (alt75) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:21: alphanum
        	    {
        	        FOLLOWPUSH(FOLLOW_alphanum_in_domainlabel5250);
        	        alphanum(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledomainlabelEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:32: ( alphanum ( alphanum | '-' )* alphanum )
        	    {
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:32: ( alphanum ( alphanum | '-' )* alphanum )
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:33: alphanum ( alphanum | '-' )* alphanum
        	        {
        	            FOLLOWPUSH(FOLLOW_alphanum_in_domainlabel5255);
        	            alphanum(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruledomainlabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:42: ( alphanum | '-' )*

        	            for (;;)
        	            {
        	                int alt74=3;
        	                switch ( LA(1) ) 
        	                {
        	                case HEX_CHAR:
        	                case COMMON_CHAR:
        	                	{
        	                		switch ( LA(2) ) 
        	                		{
        	                		case DIGIT:
        	                		case HEX_CHAR:
        	                		case COMMON_CHAR:
        	                		case 29:
        	                			{
        	                				alt74=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case DIGIT:
        	                	{
        	                		switch ( LA(2) ) 
        	                		{
        	                		case DIGIT:
        	                		case HEX_CHAR:
        	                		case COMMON_CHAR:
        	                		case 29:
        	                			{
        	                				alt74=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case 29:
        	                	{
        	                		alt74=2;
        	                	}
        	                    break;

        	                }

        	                switch (alt74) 
        	                {
        	            	case 1:
        	            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:44: alphanum
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_alphanum_in_domainlabel5259);
        	            	        alphanum(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruledomainlabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1328:55: '-'
        	            	    {
        	            	         MATCHT(29, &FOLLOW_29_in_domainlabel5263); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruledomainlabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop74;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop74: ; /* Jump out to here if this rule does not match */

        	            FOLLOWPUSH(FOLLOW_alphanum_in_domainlabel5268);
        	            alphanum(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruledomainlabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledomainlabelEx; /* Prevent compiler warnings */
    ruledomainlabelEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end domainlabel */

/** 
 * $ANTLR start toplabel
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:1: toplabel : ( alpha | ( alpha ( alphanum | '-' )* alphanum ) );
 */
static void
toplabel(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:17: ( alpha | ( alpha ( alphanum | '-' )* alphanum ) )
            
            ANTLR3_UINT32 alt77;

            alt77=2;

            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		switch ( LA(2) ) 
            		{
            		case EOF:
            		case LWS:
            		case DQUOTE:
            		case SEMI:
            		case COMMA:
            		case COLON:
            		case RAQUOT:
            		case 27:
            		case 28:
            			{
            				alt77=1;
            			}
            		    break;
            		case DIGIT:
            		case HEX_CHAR:
            		case COMMON_CHAR:
            		case 29:
            			{
            				alt77=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 77;
            		    EXCEPTION->state        = 1;


            		    goto ruletoplabelEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 77;
                EXCEPTION->state        = 0;


                goto ruletoplabelEx;
            }

            switch (alt77) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:21: alpha
        	    {
        	        FOLLOWPUSH(FOLLOW_alpha_in_toplabel5286);
        	        alpha(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletoplabelEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:29: ( alpha ( alphanum | '-' )* alphanum )
        	    {
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:29: ( alpha ( alphanum | '-' )* alphanum )
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:30: alpha ( alphanum | '-' )* alphanum
        	        {
        	            FOLLOWPUSH(FOLLOW_alpha_in_toplabel5291);
        	            alpha(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruletoplabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:36: ( alphanum | '-' )*

        	            for (;;)
        	            {
        	                int alt76=3;
        	                switch ( LA(1) ) 
        	                {
        	                case HEX_CHAR:
        	                case COMMON_CHAR:
        	                	{
        	                		switch ( LA(2) ) 
        	                		{
        	                		case DIGIT:
        	                		case HEX_CHAR:
        	                		case COMMON_CHAR:
        	                		case 29:
        	                			{
        	                				alt76=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case DIGIT:
        	                	{
        	                		switch ( LA(2) ) 
        	                		{
        	                		case DIGIT:
        	                		case HEX_CHAR:
        	                		case COMMON_CHAR:
        	                		case 29:
        	                			{
        	                				alt76=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case 29:
        	                	{
        	                		alt76=2;
        	                	}
        	                    break;

        	                }

        	                switch (alt76) 
        	                {
        	            	case 1:
        	            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:38: alphanum
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_alphanum_in_toplabel5295);
        	            	        alphanum(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruletoplabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1329:49: '-'
        	            	    {
        	            	         MATCHT(29, &FOLLOW_29_in_toplabel5299); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruletoplabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop76;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop76: ; /* Jump out to here if this rule does not match */

        	            FOLLOWPUSH(FOLLOW_alphanum_in_toplabel5304);
        	            alphanum(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruletoplabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletoplabelEx; /* Prevent compiler warnings */
    ruletoplabelEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end toplabel */

/** 
 * $ANTLR start ipv4address
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1331:1: ipv4address : three_digit '.' three_digit '.' three_digit '.' three_digit ;
 */
static belle_sip_messageParser_ipv4address_return
ipv4address(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_ipv4address_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1331:16: ( three_digit '.' three_digit '.' three_digit '.' three_digit )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1331:19: three_digit '.' three_digit '.' three_digit '.' three_digit
        {
            FOLLOWPUSH(FOLLOW_three_digit_in_ipv4address5318);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(28, &FOLLOW_28_in_ipv4address5320); 
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_three_digit_in_ipv4address5322);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(28, &FOLLOW_28_in_ipv4address5324); 
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_three_digit_in_ipv4address5326);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(28, &FOLLOW_28_in_ipv4address5328); 
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_three_digit_in_ipv4address5330);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleipv4addressEx; /* Prevent compiler warnings */
    ruleipv4addressEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end ipv4address */

/** 
 * $ANTLR start ipv6reference
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1332:1: ipv6reference : '[' ipv6address ']' ;
 */
static void
ipv6reference(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_ipv6address_return ipv6address75;
    #undef	RETURN_TYPE_ipv6address75
    #define	RETURN_TYPE_ipv6address75 belle_sip_messageParser_ipv6address_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1332:16: ( '[' ipv6address ']' )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1332:19: '[' ipv6address ']'
        {
             MATCHT(30, &FOLLOW_30_in_ipv6reference5340); 
            if  (HASEXCEPTION())
            {
                goto ruleipv6referenceEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_ipv6address_in_ipv6reference5342);
            ipv6address75=ipv6address(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv6referenceEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(31, &FOLLOW_31_in_ipv6reference5344); 
            if  (HASEXCEPTION())
            {
                goto ruleipv6referenceEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                	(SCOPE_TOP(host))->current=(const char *)(STRSTREAM->toStringTT(STRSTREAM, ipv6address75.start, ipv6address75.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleipv6referenceEx; /* Prevent compiler warnings */
    ruleipv6referenceEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end ipv6reference */

/** 
 * $ANTLR start ipv6address
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1333:1: ipv6address : hexpart ( COLON ipv4address )? ;
 */
static belle_sip_messageParser_ipv6address_return
ipv6address(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_ipv6address_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1333:16: ( hexpart ( COLON ipv4address )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1333:19: hexpart ( COLON ipv4address )?
        {
            FOLLOWPUSH(FOLLOW_hexpart_in_ipv6address5356);
            hexpart(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv6addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1333:27: ( COLON ipv4address )?
            {
                int alt78=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt78=1;
                    	}
                        break;
                }

                switch (alt78) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1333:29: COLON ipv4address
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_ipv6address5360); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleipv6addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_ipv4address_in_ipv6address5362);
            	        ipv4address(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleipv6addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleipv6addressEx; /* Prevent compiler warnings */
    ruleipv6addressEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end ipv6address */

/** 
 * $ANTLR start hexpart
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:1: hexpart : ( hexseq | hexseq '::' ( hexseq )? | '::' ( hexseq )? );
 */
static void
hexpart(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:16: ( hexseq | hexseq '::' ( hexseq )? | '::' ( hexseq )? )
            
            ANTLR3_UINT32 alt81;

            alt81=3;

            alt81 = cdfa81.predict(ctx, RECOGNIZER, ISTREAM, &cdfa81);
            if  (HASEXCEPTION())
            {
                goto rulehexpartEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt81) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:19: hexseq
        	    {
        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart5381);
        	        hexseq(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:28: hexseq '::' ( hexseq )?
        	    {
        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart5385);
        	        hexseq(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	         MATCHT(32, &FOLLOW_32_in_hexpart5387); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:40: ( hexseq )?
        	        {
        	            int alt79=2;
        	            switch ( LA(1) ) 
        	            {
        	                case DIGIT:
        	                case HEX_CHAR:
        	                	{
        	                		alt79=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt79) 
        	            {
        	        	case 1:
        	        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:42: hexseq
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart5391);
        	        	        hexseq(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulehexpartEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:54: '::' ( hexseq )?
        	    {
        	         MATCHT(32, &FOLLOW_32_in_hexpart5398); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:59: ( hexseq )?
        	        {
        	            int alt80=2;
        	            switch ( LA(1) ) 
        	            {
        	                case DIGIT:
        	                case HEX_CHAR:
        	                	{
        	                		alt80=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt80) 
        	            {
        	        	case 1:
        	        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1334:61: hexseq
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart5402);
        	        	        hexseq(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulehexpartEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulehexpartEx; /* Prevent compiler warnings */
    rulehexpartEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end hexpart */

/** 
 * $ANTLR start hexseq
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1335:1: hexseq : hex4 ( COLON hex4 )* ;
 */
static void
hexseq(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1335:16: ( hex4 ( COLON hex4 )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1335:19: hex4 ( COLON hex4 )*
        {
            FOLLOWPUSH(FOLLOW_hex4_in_hexseq5421);
            hex4(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehexseqEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1335:24: ( COLON hex4 )*

            for (;;)
            {
                int alt82=2;
                switch ( LA(1) ) 
                {
                case COLON:
                	{
                		switch ( LA(2) ) 
                		{
                		case DIGIT:
                			{
                				switch ( LA(3) ) 
                				{
                				case DIGIT:
                					{
                						switch ( LA(4) ) 
                						{
                						case DIGIT:
                							{
                								switch ( LA(5) ) 
                								{
                								case EOF:
                								case LWS:
                								case DIGIT:
                								case SEMI:
                								case COMMA:
                								case COLON:
                								case HEX_CHAR:
                								case 31:
                								case 32:
                									{
                										alt82=1;
                									}
                								    break;

                								}

                							}
                						    break;
                						case EOF:
                						case LWS:
                						case SEMI:
                						case COMMA:
                						case COLON:
                						case HEX_CHAR:
                						case 31:
                						case 32:
                							{
                								alt82=1;
                							}
                						    break;

                						}

                					}
                				    break;
                				case EOF:
                				case LWS:
                				case SEMI:
                				case COMMA:
                				case COLON:
                				case HEX_CHAR:
                				case 31:
                				case 32:
                					{
                						alt82=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case HEX_CHAR:
                			{
                				alt82=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt82) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1335:26: COLON hex4
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_hexseq5425); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehexseqEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_hex4_in_hexseq5427);
            	        hex4(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehexseqEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop82;	/* break out of the loop */
            	    break;
                }
            }
            loop82: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehexseqEx; /* Prevent compiler warnings */
    rulehexseqEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end hexseq */

/** 
 * $ANTLR start hex4
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1336:1: hex4 : ( hexdigit )+ ;
 */
static void
hex4(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1336:16: ( ( hexdigit )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1336:19: ( hexdigit )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1336:19: ( hexdigit )+
            {
                int cnt83=0;

                for (;;)
                {
                    int alt83=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt83=1;
            		}
            	    break;

            	}

            	switch (alt83) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1336:19: hexdigit
            	        {
            	            FOLLOWPUSH(FOLLOW_hexdigit_in_hex45447);
            	            hexdigit(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehex4Ex;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt83 >= 1 )
            		{
            		    goto loop83;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehex4Ex;
            	}
            	cnt83++;
                }
                loop83: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehex4Ex; /* Prevent compiler warnings */
    rulehex4Ex: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end hex4 */

/** 
 * $ANTLR start port
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1338:1: port returns [int ret] : ( DIGIT )+ ;
 */
static belle_sip_messageParser_port_return
port(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_port_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1338:23: ( ( DIGIT )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1338:25: ( DIGIT )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1338:25: ( DIGIT )+
            {
                int cnt84=0;

                for (;;)
                {
                    int alt84=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt84=1;
            		}
            	    break;

            	}

            	switch (alt84) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1338:25: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_port5460); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleportEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt84 >= 1 )
            		{
            		    goto loop84;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleportEx;
            	}
            	cnt84++;
                }
                loop84: ;	/* Jump to here if this rule does not match */
            }
            if ( BACKTRACKING==0 ) 
            {
                 retval.ret=atoi((const char *)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleportEx; /* Prevent compiler warnings */
    ruleportEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end port */

/** 
 * $ANTLR start uri_parameters
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1341:1: uri_parameters[belle_sip_uri_t* uri] : ( semi ( uri_parameter )? )+ ;
 */
static void
uri_parameters(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_uri_parametersTop = pbelle_sip_messageParser_uri_parametersPush(ctx);
    	(SCOPE_TOP(uri_parameters))->current=uri;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1344:2: ( ( semi ( uri_parameter )? )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1344:6: ( semi ( uri_parameter )? )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1344:6: ( semi ( uri_parameter )? )+
            {
                int cnt86=0;

                for (;;)
                {
                    int alt86=2;
            	switch ( LA(1) ) 
            	{
            	case LWS:
            		{
            			switch ( LA(2) ) 
            			{
            			case SEMI:
            				{
            					alt86=1;
            				}
            			    break;

            			}

            		}
            	    break;
            	case SEMI:
            		{
            			alt86=1;
            		}
            	    break;

            	}

            	switch (alt86) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1344:8: semi ( uri_parameter )?
            	        {
            	            FOLLOWPUSH(FOLLOW_semi_in_uri_parameters5492);
            	            semi(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuri_parametersEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_uri_parametersPop(ctx);

            	                return ;
            	            }

            	            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1344:13: ( uri_parameter )?
            	            {
            	                int alt85=2;
            	                switch ( LA(1) ) 
            	                {
            	                    case DIGIT:
            	                    case STAR:
            	                    case SLASH:
            	                    case COLON:
            	                    case PLUS:
            	                    case HEX_CHAR:
            	                    case COMMON_CHAR:
            	                    case LPAREN:
            	                    case RPAREN:
            	                    case 25:
            	                    case 26:
            	                    case 28:
            	                    case 29:
            	                    case 30:
            	                    case 31:
            	                    case 34:
            	                    case 39:
            	                    case 40:
            	                    case 41:
            	                    case 42:
            	                    	{
            	                    		alt85=1;
            	                    	}
            	                        break;
            	                }

            	                switch (alt85) 
            	                {
            	            	case 1:
            	            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1344:13: uri_parameter
            	            	    {
            	            	        FOLLOWPUSH(FOLLOW_uri_parameter_in_uri_parameters5494);
            	            	        uri_parameter(ctx);

            	            	        FOLLOWPOP();
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleuri_parametersEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            pbelle_sip_messageParser_uri_parametersPop(ctx);

            	            	            return ;
            	            	        }

            	            	    }
            	            	    break;

            	                }
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt86 >= 1 )
            		{
            		    goto loop86;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    pbelle_sip_messageParser_uri_parametersPop(ctx);

            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleuri_parametersEx;
            	}
            	cnt86++;
                }
                loop86: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuri_parametersEx; /* Prevent compiler warnings */
    ruleuri_parametersEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_uri_parametersPop(ctx);

    return ;
}
/* $ANTLR end uri_parameters */

/** 
 * $ANTLR start uri_parameter
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1345:1: uri_parameter : other_param ;
 */
static void
uri_parameter(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1346:2: ( other_param )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1346:7: other_param
        {
            FOLLOWPUSH(FOLLOW_other_param_in_uri_parameter5511);
            other_param(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuri_parameterEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuri_parameterEx; /* Prevent compiler warnings */
    ruleuri_parameterEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end uri_parameter */

/** 
 * $ANTLR start other_param
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1347:1: other_param : ( pname | ( pname EQUAL pvalue ) );
 */
static void
other_param(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_pname_return pname76;
    #undef	RETURN_TYPE_pname76
    #define	RETURN_TYPE_pname76 belle_sip_messageParser_pname_return

    belle_sip_messageParser_pname_return pname77;
    #undef	RETURN_TYPE_pname77
    #define	RETURN_TYPE_pname77 belle_sip_messageParser_pname_return

    belle_sip_messageParser_pvalue_return pvalue78;
    #undef	RETURN_TYPE_pvalue78
    #define	RETURN_TYPE_pvalue78 belle_sip_messageParser_pvalue_return

    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1348:1: ( pname | ( pname EQUAL pvalue ) )
            
            ANTLR3_UINT32 alt87;

            alt87=2;

            alt87 = cdfa87.predict(ctx, RECOGNIZER, ISTREAM, &cdfa87);
            if  (HASEXCEPTION())
            {
                goto ruleother_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt87) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1348:4: pname
        	    {
        	        FOLLOWPUSH(FOLLOW_pname_in_other_param5527);
        	        pname76=pname(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	                belle_sip_parameters_set_parameter(BELLE_SIP_PARAMETERS(	(SCOPE_TOP(uri_parameters))->current)
        	                                                  ,(const char *)(STRSTREAM->toStringTT(STRSTREAM, pname76.start, pname76.stop))->chars
        	                                                  ,NULL);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1352:4: ( pname EQUAL pvalue )
        	    {
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1352:4: ( pname EQUAL pvalue )
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1352:5: pname EQUAL pvalue
        	        {
        	            FOLLOWPUSH(FOLLOW_pname_in_other_param5539);
        	            pname77=pname(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleother_paramEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	             MATCHT(EQUAL, &FOLLOW_EQUAL_in_other_param5541); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleother_paramEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            FOLLOWPUSH(FOLLOW_pvalue_in_other_param5543);
        	            pvalue78=pvalue(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleother_paramEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }

        	        if ( BACKTRACKING==0 ) 
        	        {

        	                belle_sip_parameters_set_parameter(BELLE_SIP_PARAMETERS(	(SCOPE_TOP(uri_parameters))->current)
        	                                                  ,(const char *)(STRSTREAM->toStringTT(STRSTREAM, pname77.start, pname77.stop))->chars
        	                                                  ,(const char *)(STRSTREAM->toStringTT(STRSTREAM, pvalue78.start, pvalue78.stop))->chars);
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleother_paramEx; /* Prevent compiler warnings */
    ruleother_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end other_param */

/** 
 * $ANTLR start pname
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1358:1: pname : ( paramchar )+ ;
 */
static belle_sip_messageParser_pname_return
pname(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_pname_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1359:2: ( ( paramchar )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1359:6: ( paramchar )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1359:6: ( paramchar )+
            {
                int cnt88=0;

                for (;;)
                {
                    int alt88=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case STAR:
            	case SLASH:
            	case COLON:
            	case PLUS:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case LPAREN:
            	case RPAREN:
            	case 25:
            	case 26:
            	case 28:
            	case 29:
            	case 30:
            	case 31:
            	case 34:
            	case 39:
            	case 40:
            	case 41:
            	case 42:
            		{
            			alt88=1;
            		}
            	    break;

            	}

            	switch (alt88) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1359:6: paramchar
            	        {
            	            FOLLOWPUSH(FOLLOW_paramchar_in_pname5575);
            	            paramchar(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepnameEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt88 >= 1 )
            		{
            		    goto loop88;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepnameEx;
            	}
            	cnt88++;
                }
                loop88: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepnameEx; /* Prevent compiler warnings */
    rulepnameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end pname */

/** 
 * $ANTLR start pvalue
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1360:1: pvalue : ( paramchar )+ ;
 */
static belle_sip_messageParser_pvalue_return
pvalue(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_pvalue_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1361:2: ( ( paramchar )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1361:6: ( paramchar )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1361:6: ( paramchar )+
            {
                int cnt89=0;

                for (;;)
                {
                    int alt89=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case STAR:
            	case SLASH:
            	case COLON:
            	case PLUS:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case LPAREN:
            	case RPAREN:
            	case 25:
            	case 26:
            	case 28:
            	case 29:
            	case 30:
            	case 31:
            	case 34:
            	case 39:
            	case 40:
            	case 41:
            	case 42:
            		{
            			alt89=1;
            		}
            	    break;

            	}

            	switch (alt89) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1361:6: paramchar
            	        {
            	            FOLLOWPUSH(FOLLOW_paramchar_in_pvalue5598);
            	            paramchar(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepvalueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt89 >= 1 )
            		{
            		    goto loop89;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepvalueEx;
            	}
            	cnt89++;
                }
                loop89: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepvalueEx; /* Prevent compiler warnings */
    rulepvalueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end pvalue */

/** 
 * $ANTLR start paramchar
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1362:1: paramchar : ( param_unreserved | unreserved | escaped );
 */
static void
paramchar(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1363:2: ( param_unreserved | unreserved | escaped )
            
            ANTLR3_UINT32 alt90;

            alt90=3;

            switch ( LA(1) ) 
            {
            case SLASH:
            case COLON:
            case PLUS:
            case 25:
            case 26:
            case 28:
            case 30:
            case 31:
            	{
            		alt90=1;
            	}
                break;
            case DIGIT:
            case STAR:
            case HEX_CHAR:
            case COMMON_CHAR:
            case LPAREN:
            case RPAREN:
            case 29:
            case 39:
            case 40:
            case 41:
            case 42:
            	{
            		alt90=2;
            	}
                break;
            case 34:
            	{
            		alt90=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 90;
                EXCEPTION->state        = 0;


                goto ruleparamcharEx;
            }

            switch (alt90) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1363:6: param_unreserved
        	    {
        	        FOLLOWPUSH(FOLLOW_param_unreserved_in_paramchar5618);
        	        param_unreserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparamcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1363:25: unreserved
        	    {
        	        FOLLOWPUSH(FOLLOW_unreserved_in_paramchar5622);
        	        unreserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparamcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1363:38: escaped
        	    {
        	        FOLLOWPUSH(FOLLOW_escaped_in_paramchar5626);
        	        escaped(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparamcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamcharEx; /* Prevent compiler warnings */
    ruleparamcharEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end paramchar */

/** 
 * $ANTLR start param_unreserved
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1364:1: param_unreserved : ( '[' | ']' | SLASH | COLON | '&' | PLUS | '$' | '.' );
 */
static void
param_unreserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1365:2: ( '[' | ']' | SLASH | COLON | '&' | PLUS | '$' | '.' )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:
        {
            if ( LA(1) == SLASH || LA(1) == COLON || LA(1) == PLUS || ((LA(1) >= 25) && (LA(1) <= 26)) || LA(1) == 28 || ((LA(1) >= 30) && (LA(1) <= 31)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_param_unreserved0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_param_unreserved0);    goto ruleparam_unreservedEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparam_unreservedEx; /* Prevent compiler warnings */
    ruleparam_unreservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end param_unreserved */

/** 
 * $ANTLR start headers
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1367:1: headers[belle_sip_uri_t* uri] : '?' header ( '&' header )* ;
 */
static void
headers(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_headersTop = pbelle_sip_messageParser_headersPush(ctx);
    	(SCOPE_TOP(headers))->current=uri;
    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1370:17: ( '?' header ( '&' header )* )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1370:20: '?' header ( '&' header )*
        {
             MATCHT(27, &FOLLOW_27_in_headers5703); 
            if  (HASEXCEPTION())
            {
                goto ruleheadersEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_headersPop(ctx);

                return ;
            }
            FOLLOWPUSH(FOLLOW_header_in_headers5705);
            header(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheadersEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_headersPop(ctx);

                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1370:31: ( '&' header )*

            for (;;)
            {
                int alt91=2;
                switch ( LA(1) ) 
                {
                case 25:
                	{
                		alt91=1;
                	}
                    break;

                }

                switch (alt91) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1370:33: '&' header
            	    {
            	         MATCHT(25, &FOLLOW_25_in_headers5709); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheadersEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_headersPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_header_in_headers5711);
            	        header(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheadersEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_headersPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop91;	/* break out of the loop */
            	    break;
                }
            }
            loop91: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheadersEx; /* Prevent compiler warnings */
    ruleheadersEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sip_messageParser_headersPop(ctx);

    return ;
}
/* $ANTLR end headers */

/** 
 * $ANTLR start header
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1371:1: header : hname EQUAL ( hvalue )? ;
 */
static void
header(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_hname_return hname79;
    #undef	RETURN_TYPE_hname79
    #define	RETURN_TYPE_hname79 belle_sip_messageParser_hname_return

    belle_sip_messageParser_hvalue_return hvalue80;
    #undef	RETURN_TYPE_hvalue80
    #define	RETURN_TYPE_hvalue80 belle_sip_messageParser_hvalue_return

    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1371:17: ( hname EQUAL ( hvalue )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1371:20: hname EQUAL ( hvalue )?
        {
            FOLLOWPUSH(FOLLOW_hname_in_header5732);
            hname79=hname(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheaderEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(EQUAL, &FOLLOW_EQUAL_in_header5734); 
            if  (HASEXCEPTION())
            {
                goto ruleheaderEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1371:32: ( hvalue )?
            {
                int alt92=2;
                switch ( LA(1) ) 
                {
                    case DIGIT:
                    case STAR:
                    case COLON:
                    case PLUS:
                    case HEX_CHAR:
                    case COMMON_CHAR:
                    case LPAREN:
                    case RPAREN:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 33:
                    case 34:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    	{
                    		alt92=1;
                    	}
                        break;
                }

                switch (alt92) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1371:32: hvalue
            	    {
            	        FOLLOWPUSH(FOLLOW_hvalue_in_header5736);
            	        hvalue80=hvalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheaderEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_uri_set_header(	(SCOPE_TOP(headers))->current,(const char *)(STRSTREAM->toStringTT(STRSTREAM, hname79.start, hname79.stop))->chars,(const char *)(STRSTREAM->toStringTT(STRSTREAM, hvalue80.start, hvalue80.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheaderEx; /* Prevent compiler warnings */
    ruleheaderEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end header */

/** 
 * $ANTLR start hname
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1372:1: hname : ( hnv_unreserved | unreserved | escaped )+ ;
 */
static belle_sip_messageParser_hname_return
hname(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_hname_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1372:17: ( ( hnv_unreserved | unreserved | escaped )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1372:20: ( hnv_unreserved | unreserved | escaped )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1372:20: ( hnv_unreserved | unreserved | escaped )+
            {
                int cnt93=0;

                for (;;)
                {
                    int alt93=4;
            	switch ( LA(1) ) 
            	{
            	case COLON:
            	case PLUS:
            	case 26:
            	case 27:
            	case 30:
            	case 31:
            	case 33:
            		{
            			alt93=1;
            		}
            	    break;
            	case DIGIT:
            	case STAR:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case LPAREN:
            	case RPAREN:
            	case 28:
            	case 29:
            	case 39:
            	case 40:
            	case 41:
            	case 42:
            		{
            			alt93=2;
            		}
            	    break;
            	case 34:
            		{
            			alt93=3;
            		}
            	    break;

            	}

            	switch (alt93) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1372:22: hnv_unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_hnv_unreserved_in_hname5759);
            	            hnv_unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehnameEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1372:39: unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_unreserved_in_hname5763);
            	            unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehnameEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1372:52: escaped
            	        {
            	            FOLLOWPUSH(FOLLOW_escaped_in_hname5767);
            	            escaped(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehnameEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt93 >= 1 )
            		{
            		    goto loop93;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehnameEx;
            	}
            	cnt93++;
                }
                loop93: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehnameEx; /* Prevent compiler warnings */
    rulehnameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end hname */

/** 
 * $ANTLR start hvalue
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1373:1: hvalue : ( hnv_unreserved | unreserved | escaped )+ ;
 */
static belle_sip_messageParser_hvalue_return
hvalue(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_hvalue_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1373:17: ( ( hnv_unreserved | unreserved | escaped )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1373:20: ( hnv_unreserved | unreserved | escaped )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1373:20: ( hnv_unreserved | unreserved | escaped )+
            {
                int cnt94=0;

                for (;;)
                {
                    int alt94=4;
            	switch ( LA(1) ) 
            	{
            	case COLON:
            	case PLUS:
            	case 26:
            	case 27:
            	case 30:
            	case 31:
            	case 33:
            		{
            			alt94=1;
            		}
            	    break;
            	case DIGIT:
            	case STAR:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case LPAREN:
            	case RPAREN:
            	case 28:
            	case 29:
            	case 39:
            	case 40:
            	case 41:
            	case 42:
            		{
            			alt94=2;
            		}
            	    break;
            	case 34:
            		{
            			alt94=3;
            		}
            	    break;

            	}

            	switch (alt94) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1373:22: hnv_unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_hnv_unreserved_in_hvalue5789);
            	            hnv_unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehvalueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1373:39: unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_unreserved_in_hvalue5793);
            	            unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehvalueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1373:52: escaped
            	        {
            	            FOLLOWPUSH(FOLLOW_escaped_in_hvalue5797);
            	            escaped(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehvalueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt94 >= 1 )
            		{
            		    goto loop94;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehvalueEx;
            	}
            	cnt94++;
                }
                loop94: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehvalueEx; /* Prevent compiler warnings */
    rulehvalueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end hvalue */

/** 
 * $ANTLR start hnv_unreserved
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1376:1: hnv_unreserved : ( '[' | ']' | '|' | '?' | COLON | PLUS | '$' );
 */
static void
hnv_unreserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1376:17: ( '[' | ']' | '|' | '?' | COLON | PLUS | '$' )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:
        {
            if ( LA(1) == COLON || LA(1) == PLUS || ((LA(1) >= 26) && (LA(1) <= 27)) || ((LA(1) >= 30) && (LA(1) <= 31)) || LA(1) == 33 )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_hnv_unreserved0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_hnv_unreserved0);    goto rulehnv_unreservedEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehnv_unreservedEx; /* Prevent compiler warnings */
    rulehnv_unreservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end hnv_unreserved */

/** 
 * $ANTLR start escaped
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1377:1: escaped : '%' hexdigit hexdigit ;
 */
static void
escaped(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1377:13: ( '%' hexdigit hexdigit )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1377:16: '%' hexdigit hexdigit
        {
             MATCHT(34, &FOLLOW_34_in_escaped5848); 
            if  (HASEXCEPTION())
            {
                goto ruleescapedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_hexdigit_in_escaped5850);
            hexdigit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleescapedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_hexdigit_in_escaped5852);
            hexdigit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleescapedEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleescapedEx; /* Prevent compiler warnings */
    ruleescapedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end escaped */

/** 
 * $ANTLR start ttl
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1378:1: ttl : three_digit ;
 */
static void
ttl(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1378:5: ( three_digit )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1378:7: three_digit
        {
            FOLLOWPUSH(FOLLOW_three_digit_in_ttl5859);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulettlEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulettlEx; /* Prevent compiler warnings */
    rulettlEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end ttl */

/** 
 * $ANTLR start three_digit
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:1: three_digit : ( DIGIT | ( DIGIT DIGIT ) | ( DIGIT DIGIT DIGIT ) );
 */
static void
three_digit(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:12: ( DIGIT | ( DIGIT DIGIT ) | ( DIGIT DIGIT DIGIT ) )
            
            ANTLR3_UINT32 alt95;

            alt95=3;

            switch ( LA(1) ) 
            {
            case DIGIT:
            	{
            		switch ( LA(2) ) 
            		{
            		case DIGIT:
            			{
            				switch ( LA(3) ) 
            				{
            				case DIGIT:
            					{
            						alt95=3;
            					}
            				    break;
            				case EOF:
            				case LWS:
            				case DQUOTE:
            				case SEMI:
            				case COMMA:
            				case COLON:
            				case RAQUOT:
            				case 27:
            				case 28:
            				case 31:
            					{
            						alt95=2;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return ;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 95;
            				    EXCEPTION->state        = 2;


            				    goto rulethree_digitEx;
            				}

            			}
            		    break;
            		case EOF:
            		case LWS:
            		case DQUOTE:
            		case SEMI:
            		case COMMA:
            		case COLON:
            		case RAQUOT:
            		case 27:
            		case 28:
            		case 31:
            			{
            				alt95=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 95;
            		    EXCEPTION->state        = 1;


            		    goto rulethree_digitEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 95;
                EXCEPTION->state        = 0;


                goto rulethree_digitEx;
            }

            switch (alt95) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:14: DIGIT
        	    {
        	         MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit5865); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethree_digitEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:22: ( DIGIT DIGIT )
        	    {
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:22: ( DIGIT DIGIT )
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:23: DIGIT DIGIT
        	        {
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit5870); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit5872); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;
        	case 3:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:38: ( DIGIT DIGIT DIGIT )
        	    {
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:38: ( DIGIT DIGIT DIGIT )
        	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1379:39: DIGIT DIGIT DIGIT
        	        {
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit5878); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit5880); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit5882); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulethree_digitEx; /* Prevent compiler warnings */
    rulethree_digitEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end three_digit */

/** 
 * $ANTLR start token
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1380:1: token : ( alphanum | mark | '%' | PLUS | '`' )+ ;
 */
static belle_sip_messageParser_token_return
token(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_token_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1381:2: ( ( alphanum | mark | '%' | PLUS | '`' )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1381:6: ( alphanum | mark | '%' | PLUS | '`' )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1381:6: ( alphanum | mark | '%' | PLUS | '`' )+
            {
                int cnt96=0;

                for (;;)
                {
                    int alt96=6;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            		{
            			alt96=1;
            		}
            	    break;
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case 28:
            	case 29:
            	case 39:
            	case 40:
            	case 41:
            	case 42:
            		{
            			alt96=2;
            		}
            	    break;
            	case 34:
            		{
            			alt96=3;
            		}
            	    break;
            	case PLUS:
            		{
            			alt96=4;
            		}
            	    break;
            	case 35:
            		{
            			alt96=5;
            		}
            	    break;

            	}

            	switch (alt96) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1381:7: alphanum
            	        {
            	            FOLLOWPUSH(FOLLOW_alphanum_in_token5903);
            	            alphanum(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1381:18: mark
            	        {
            	            FOLLOWPUSH(FOLLOW_mark_in_token5907);
            	            mark(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1381:25: '%'
            	        {
            	             MATCHT(34, &FOLLOW_34_in_token5911); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 4:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1381:31: PLUS
            	        {
            	             MATCHT(PLUS, &FOLLOW_PLUS_in_token5915); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 5:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1381:38: '`'
            	        {
            	             MATCHT(35, &FOLLOW_35_in_token5919); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt96 >= 1 )
            		{
            		    goto loop96;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletokenEx;
            	}
            	cnt96++;
                }
                loop96: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenEx; /* Prevent compiler warnings */
    ruletokenEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end token */

/** 
 * $ANTLR start reserved
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1383:1: reserved : ( SEMI | SLASH | '?' | COLON | '@' | '&' | EQUAL | PLUS | '$' | COMMA );
 */
static void
reserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1384:2: ( SEMI | SLASH | '?' | COLON | '@' | '&' | EQUAL | PLUS | '$' | COMMA )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:
        {
            if ( ((LA(1) >= SEMI) && (LA(1) <= COLON)) || LA(1) == PLUS || ((LA(1) >= 24) && (LA(1) <= 27)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_reserved0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_reserved0);    goto rulereservedEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereservedEx; /* Prevent compiler warnings */
    rulereservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end reserved */

/** 
 * $ANTLR start unreserved
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1387:1: unreserved : ( alphanum | mark );
 */
static void
unreserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1387:12: ( alphanum | mark )
            
            ANTLR3_UINT32 alt97;

            alt97=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		alt97=1;
            	}
                break;
            case STAR:
            case LPAREN:
            case RPAREN:
            case 28:
            case 29:
            case 39:
            case 40:
            case 41:
            case 42:
            	{
            		alt97=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 97;
                EXCEPTION->state        = 0;


                goto ruleunreservedEx;
            }

            switch (alt97) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1387:16: alphanum
        	    {
        	        FOLLOWPUSH(FOLLOW_alphanum_in_unreserved6026);
        	        alphanum(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunreservedEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1387:26: mark
        	    {
        	        FOLLOWPUSH(FOLLOW_mark_in_unreserved6029);
        	        mark(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunreservedEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleunreservedEx; /* Prevent compiler warnings */
    ruleunreservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end unreserved */

/** 
 * $ANTLR start alphanum
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1388:1: alphanum : ( alpha | DIGIT );
 */
static void
alphanum(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1388:10: ( alpha | DIGIT )
            
            ANTLR3_UINT32 alt98;

            alt98=2;

            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		alt98=1;
            	}
                break;
            case DIGIT:
            	{
            		alt98=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 98;
                EXCEPTION->state        = 0;


                goto rulealphanumEx;
            }

            switch (alt98) 
            {
        	case 1:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1388:15: alpha
        	    {
        	        FOLLOWPUSH(FOLLOW_alpha_in_alphanum6041);
        	        alpha(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulealphanumEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1388:23: DIGIT
        	    {
        	         MATCHT(DIGIT, &FOLLOW_DIGIT_in_alphanum6045); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulealphanumEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulealphanumEx; /* Prevent compiler warnings */
    rulealphanumEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end alphanum */

/** 
 * $ANTLR start hexdigit
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1389:1: hexdigit : ( HEX_CHAR | DIGIT );
 */
static void
hexdigit(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1390:2: ( HEX_CHAR | DIGIT )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:
        {
            if ( LA(1) == DIGIT || LA(1) == HEX_CHAR )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_hexdigit0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_hexdigit0);    goto rulehexdigitEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehexdigitEx; /* Prevent compiler warnings */
    rulehexdigitEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end hexdigit */

/** 
 * $ANTLR start alpha
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1391:1: alpha : ( HEX_CHAR | COMMON_CHAR );
 */
static void
alpha(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1391:7: ( HEX_CHAR | COMMON_CHAR )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:
        {
            if ( ((LA(1) >= HEX_CHAR) && (LA(1) <= COMMON_CHAR)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_alpha0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_alpha0);    goto rulealphaEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealphaEx; /* Prevent compiler warnings */
    rulealphaEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end alpha */

/** 
 * $ANTLR start word
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1393:1: word : ( alphanum | mark | '%' | PLUS | '`' | LAQUOT | RAQUOT | COLON | '\\\\' | DQUOTE | SLASH | '[' | ']' | '?' | '{' | '}' )+ ;
 */
static belle_sip_messageParser_word_return
word(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_word_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1394:2: ( ( alphanum | mark | '%' | PLUS | '`' | LAQUOT | RAQUOT | COLON | '\\\\' | DQUOTE | SLASH | '[' | ']' | '?' | '{' | '}' )+ )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1394:6: ( alphanum | mark | '%' | PLUS | '`' | LAQUOT | RAQUOT | COLON | '\\\\' | DQUOTE | SLASH | '[' | ']' | '?' | '{' | '}' )+
        {
            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1394:6: ( alphanum | mark | '%' | PLUS | '`' | LAQUOT | RAQUOT | COLON | '\\\\' | DQUOTE | SLASH | '[' | ']' | '?' | '{' | '}' )+
            {
                int cnt99=0;

                for (;;)
                {
                    int alt99=17;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            		{
            			alt99=1;
            		}
            	    break;
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case 28:
            	case 29:
            	case 39:
            	case 40:
            	case 41:
            	case 42:
            		{
            			alt99=2;
            		}
            	    break;
            	case 34:
            		{
            			alt99=3;
            		}
            	    break;
            	case PLUS:
            		{
            			alt99=4;
            		}
            	    break;
            	case 35:
            		{
            			alt99=5;
            		}
            	    break;
            	case LAQUOT:
            		{
            			alt99=6;
            		}
            	    break;
            	case RAQUOT:
            		{
            			alt99=7;
            		}
            	    break;
            	case COLON:
            		{
            			alt99=8;
            		}
            	    break;
            	case 36:
            		{
            			alt99=9;
            		}
            	    break;
            	case DQUOTE:
            		{
            			alt99=10;
            		}
            	    break;
            	case SLASH:
            		{
            			alt99=11;
            		}
            	    break;
            	case 30:
            		{
            			alt99=12;
            		}
            	    break;
            	case 31:
            		{
            			alt99=13;
            		}
            	    break;
            	case 27:
            		{
            			alt99=14;
            		}
            	    break;
            	case 37:
            		{
            			alt99=15;
            		}
            	    break;
            	case 38:
            		{
            			alt99=16;
            		}
            	    break;

            	}

            	switch (alt99) 
            	{
            	    case 1:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1394:7: alphanum
            	        {
            	            FOLLOWPUSH(FOLLOW_alphanum_in_word6113);
            	            alphanum(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1394:18: mark
            	        {
            	            FOLLOWPUSH(FOLLOW_mark_in_word6117);
            	            mark(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1394:27: '%'
            	        {
            	             MATCHT(34, &FOLLOW_34_in_word6123); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 4:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1395:25: PLUS
            	        {
            	             MATCHT(PLUS, &FOLLOW_PLUS_in_word6151); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 5:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1395:32: '`'
            	        {
            	             MATCHT(35, &FOLLOW_35_in_word6155); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 6:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1396:22: LAQUOT
            	        {
            	             MATCHT(LAQUOT, &FOLLOW_LAQUOT_in_word6180); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 7:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1396:31: RAQUOT
            	        {
            	             MATCHT(RAQUOT, &FOLLOW_RAQUOT_in_word6184); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 8:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:22: COLON
            	        {
            	             MATCHT(COLON, &FOLLOW_COLON_in_word6209); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 9:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:30: '\\\\'
            	        {
            	             MATCHT(36, &FOLLOW_36_in_word6213); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 10:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:37: DQUOTE
            	        {
            	             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_word6217); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 11:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:46: SLASH
            	        {
            	             MATCHT(SLASH, &FOLLOW_SLASH_in_word6221); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 12:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:54: '['
            	        {
            	             MATCHT(30, &FOLLOW_30_in_word6225); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 13:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:60: ']'
            	        {
            	             MATCHT(31, &FOLLOW_31_in_word6229); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 14:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:66: '?'
            	        {
            	             MATCHT(27, &FOLLOW_27_in_word6233); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 15:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:72: '{'
            	        {
            	             MATCHT(37, &FOLLOW_37_in_word6237); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 16:
            	        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1397:78: '}'
            	        {
            	             MATCHT(38, &FOLLOW_38_in_word6241); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt99 >= 1 )
            		{
            		    goto loop99;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulewordEx;
            	}
            	cnt99++;
                }
                loop99: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewordEx; /* Prevent compiler warnings */
    rulewordEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return retval;
}
/* $ANTLR end word */

/** 
 * $ANTLR start mark
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1402:1: mark : ( '-' | '_' | '.' | '!' | '~' | STAR | '\\'' | LPAREN | RPAREN );
 */
static void
mark(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1402:6: ( '-' | '_' | '.' | '!' | '~' | STAR | '\\'' | LPAREN | RPAREN )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:
        {
            if ( LA(1) == STAR || ((LA(1) >= LPAREN) && (LA(1) <= RPAREN)) || ((LA(1) >= 28) && (LA(1) <= 29)) || ((LA(1) >= 39) && (LA(1) <= 42)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_mark0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_mark0);    goto rulemarkEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemarkEx; /* Prevent compiler warnings */
    rulemarkEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end mark */

/** 
 * $ANTLR start hcolon
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1414:1: hcolon : ( LWS | HTAB )* COLON ( LWS )? ;
 */
static void
hcolon(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1414:8: ( ( LWS | HTAB )* COLON ( LWS )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1414:10: ( LWS | HTAB )* COLON ( LWS )?
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1414:10: ( LWS | HTAB )*

            for (;;)
            {
                int alt100=2;
                switch ( LA(1) ) 
                {
                case LWS:
                case HTAB:
                	{
                		alt100=1;
                	}
                    break;

                }

                switch (alt100) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:
            	    {
            	        if ( LA(1) == LWS || LA(1) == HTAB )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else 
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_hcolon6378;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_hcolon6378);    goto rulehcolonEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop100;	/* break out of the loop */
            	    break;
                }
            }
            loop100: ; /* Jump out to here if this rule does not match */

             MATCHT(COLON, &FOLLOW_COLON_in_hcolon6389); 
            if  (HASEXCEPTION())
            {
                goto rulehcolonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1414:33: ( LWS )?
            {
                int alt101=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt101=1;
                    	}
                        break;
                }

                switch (alt101) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1414:33: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_hcolon6392); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehcolonEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehcolonEx; /* Prevent compiler warnings */
    rulehcolonEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end hcolon */

/** 
 * $ANTLR start ldquot
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1423:1: ldquot : ( LWS )? DQUOTE ;
 */
static void
ldquot(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1423:9: ( ( LWS )? DQUOTE )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1423:12: ( LWS )? DQUOTE
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1423:12: ( LWS )?
            {
                int alt102=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt102=1;
                    	}
                        break;
                }

                switch (alt102) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1423:12: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_ldquot6428); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleldquotEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_ldquot6431); 
            if  (HASEXCEPTION())
            {
                goto ruleldquotEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleldquotEx; /* Prevent compiler warnings */
    ruleldquotEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end ldquot */

/** 
 * $ANTLR start rdquot
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1424:1: rdquot : DQUOTE ( LWS )? ;
 */
static void
rdquot(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1424:8: ( DQUOTE ( LWS )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1424:10: DQUOTE ( LWS )?
        {
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_rdquot6439); 
            if  (HASEXCEPTION())
            {
                goto rulerdquotEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1424:17: ( LWS )?
            {
                int alt103=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt103=1;
                    	}
                        break;
                }

                switch (alt103) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1424:17: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_rdquot6441); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerdquotEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerdquotEx; /* Prevent compiler warnings */
    rulerdquotEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end rdquot */

/** 
 * $ANTLR start semi
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1443:1: semi : ( LWS )? SEMI ( LWS )? ;
 */
static void
semi(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1443:5: ( ( LWS )? SEMI ( LWS )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1443:7: ( LWS )? SEMI ( LWS )?
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1443:7: ( LWS )?
            {
                int alt104=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt104=1;
                    	}
                        break;
                }

                switch (alt104) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1443:7: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_semi6503); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesemiEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(SEMI, &FOLLOW_SEMI_in_semi6506); 
            if  (HASEXCEPTION())
            {
                goto rulesemiEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1443:17: ( LWS )?
            {
                int alt105=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt105=1;
                    	}
                        break;
                }

                switch (alt105) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1443:17: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_semi6508); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesemiEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesemiEx; /* Prevent compiler warnings */
    rulesemiEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end semi */

/** 
 * $ANTLR start comma
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1449:1: comma : ( LWS )? COMMA ( LWS )? ;
 */
static void
comma(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1449:7: ( ( LWS )? COMMA ( LWS )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1449:9: ( LWS )? COMMA ( LWS )?
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1449:9: ( LWS )?
            {
                int alt106=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt106=1;
                    	}
                        break;
                }

                switch (alt106) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1449:9: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_comma6528); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(COMMA, &FOLLOW_COMMA_in_comma6531); 
            if  (HASEXCEPTION())
            {
                goto rulecommaEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1449:20: ( LWS )?
            {
                int alt107=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt107=1;
                    	}
                        break;
                }

                switch (alt107) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1449:20: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_comma6533); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommaEx; /* Prevent compiler warnings */
    rulecommaEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end comma */

/** 
 * $ANTLR start sp_laquot_sp
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1454:1: sp_laquot_sp : ( LWS )? LAQUOT ( LWS )? ;
 */
static void
sp_laquot_sp(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1455:2: ( ( LWS )? LAQUOT ( LWS )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1455:4: ( LWS )? LAQUOT ( LWS )?
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1455:4: ( LWS )?
            {
                int alt108=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt108=1;
                    	}
                        break;
                }

                switch (alt108) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1455:4: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_sp_laquot_sp6553); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesp_laquot_spEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(LAQUOT, &FOLLOW_LAQUOT_in_sp_laquot_sp6556); 
            if  (HASEXCEPTION())
            {
                goto rulesp_laquot_spEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1455:16: ( LWS )?
            {
                int alt109=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt109=1;
                    	}
                        break;
                }

                switch (alt109) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1455:16: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_sp_laquot_sp6558); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesp_laquot_spEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesp_laquot_spEx; /* Prevent compiler warnings */
    rulesp_laquot_spEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end sp_laquot_sp */

/** 
 * $ANTLR start sp_raquot_sp
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1456:1: sp_raquot_sp : ( LWS )? RAQUOT ( LWS )? ;
 */
static void
sp_raquot_sp(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1457:2: ( ( LWS )? RAQUOT ( LWS )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1457:4: ( LWS )? RAQUOT ( LWS )?
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1457:4: ( LWS )?
            {
                int alt110=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt110=1;
                    	}
                        break;
                }

                switch (alt110) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1457:4: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_sp_raquot_sp6567); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesp_raquot_spEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(RAQUOT, &FOLLOW_RAQUOT_in_sp_raquot_sp6570); 
            if  (HASEXCEPTION())
            {
                goto rulesp_raquot_spEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1457:16: ( LWS )?
            {
                int alt111=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt111=1;
                    	}
                        break;
                }

                switch (alt111) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1457:16: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_sp_raquot_sp6572); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesp_raquot_spEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesp_raquot_spEx; /* Prevent compiler warnings */
    rulesp_raquot_spEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end sp_raquot_sp */

/** 
 * $ANTLR start equal
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1474:1: equal : ( LWS )? EQUAL ( LWS )? ;
 */
static void
equal(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1474:6: ( ( LWS )? EQUAL ( LWS )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1475:4: ( LWS )? EQUAL ( LWS )?
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1475:4: ( LWS )?
            {
                int alt112=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt112=1;
                    	}
                        break;
                }

                switch (alt112) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1475:4: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_equal6626); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequalEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(EQUAL, &FOLLOW_EQUAL_in_equal6629); 
            if  (HASEXCEPTION())
            {
                goto ruleequalEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1475:15: ( LWS )?
            {
                int alt113=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt113=1;
                    	}
                        break;
                }

                switch (alt113) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1475:15: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_equal6631); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequalEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleequalEx; /* Prevent compiler warnings */
    ruleequalEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end equal */

/** 
 * $ANTLR start slash
 * /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1480:1: slash : ( LWS )? SLASH ( LWS )? ;
 */
static void
slash(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1480:7: ( ( LWS )? SLASH ( LWS )? )
        // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1480:9: ( LWS )? SLASH ( LWS )?
        {

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1480:9: ( LWS )?
            {
                int alt114=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt114=1;
                    	}
                        break;
                }

                switch (alt114) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1480:9: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_slash6650); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleslashEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(SLASH, &FOLLOW_SLASH_in_slash6653); 
            if  (HASEXCEPTION())
            {
                goto ruleslashEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1480:20: ( LWS )?
            {
                int alt115=2;
                switch ( LA(1) ) 
                {
                    case LWS:
                    	{
                    		alt115=1;
                    	}
                        break;
                }

                switch (alt115) 
                {
            	case 1:
            	    // /Users/karimjimo/Downloads/linphone-iphone/submodules/build/..//belle-sip/src/belle_sip_message.g:1480:20: LWS
            	    {
            	         MATCHT(LWS, &FOLLOW_LWS_in_slash6655); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleslashEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleslashEx; /* Prevent compiler warnings */
    ruleslashEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }


    return ;
}
/* $ANTLR end slash */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
